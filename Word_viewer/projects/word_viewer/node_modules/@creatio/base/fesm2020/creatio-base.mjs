import { classToPlain, Exclude, Expose } from 'class-transformer';
import { __decorate, __metadata } from 'tslib';

/**
 * @public
 * Returns a string represent of date in ISO 8601 without time zone specification(doesn't convert it
 * using local timezone).
 *
 * Example:
 *
 *      const date = new Date(2018, 01, 20, 15, 10, 30);
 *      const result = toLocalISOString(date);
 *      //result: '2018-02-20T15:10:30'
 *
 * @param date Date value.
 */
function ɵtoLocalISOString(date) {
    if (!(date instanceof Date)) {
        throw new TypeError();
    }
    const timeZoneOffset = date.getTimezoneOffset() * 60000;
    return new Date(date.getTime() - timeZoneOffset).toISOString().slice(0, -1);
}
/**
 * @public
 * Returns encoded date in string value.
 * @param date Date value.
 */
function ɵencodeDate(date) {
    return `"${ɵtoLocalISOString(date)}"`;
}

/**
 * @public
 */
var ɵDataSourceScope;
(function (ɵDataSourceScope) {
    ɵDataSourceScope["ViewElement"] = "viewElement";
    ɵDataSourceScope["Page"] = "page";
})(ɵDataSourceScope || (ɵDataSourceScope = {}));

/**
 * @public
 */
var ɵDataSchemaAttributeType;
(function (ɵDataSchemaAttributeType) {
    ɵDataSchemaAttributeType["OwnAttribute"] = "Own";
    ɵDataSchemaAttributeType["ForwardReferenceAttribute"] = "ForwardReference";
    ɵDataSchemaAttributeType["BackReferenceAttribute"] = "BackReference";
    ɵDataSchemaAttributeType["AggregationAttribute"] = "Aggregation";
    ɵDataSchemaAttributeType["FunctionAttribute"] = "Function";
})(ɵDataSchemaAttributeType || (ɵDataSchemaAttributeType = {}));
/**
 * @public
 */
var ɵDataSchemaAttributeUsageType;
(function (ɵDataSchemaAttributeUsageType) {
    ɵDataSchemaAttributeUsageType[ɵDataSchemaAttributeUsageType["General"] = 0] = "General";
    ɵDataSchemaAttributeUsageType[ɵDataSchemaAttributeUsageType["Advanced"] = 1] = "Advanced";
    ɵDataSchemaAttributeUsageType[ɵDataSchemaAttributeUsageType["None"] = 2] = "None";
})(ɵDataSchemaAttributeUsageType || (ɵDataSchemaAttributeUsageType = {}));

/**
 * @public
 */
var ɵDefaultValueSource;
(function (ɵDefaultValueSource) {
    ɵDefaultValueSource[ɵDefaultValueSource["None"] = 0] = "None";
    ɵDefaultValueSource[ɵDefaultValueSource["Const"] = 1] = "Const";
    ɵDefaultValueSource[ɵDefaultValueSource["Settings"] = 2] = "Settings";
    ɵDefaultValueSource[ɵDefaultValueSource["SystemValue"] = 3] = "SystemValue";
    ɵDefaultValueSource[ɵDefaultValueSource["Sequence"] = 4] = "Sequence";
})(ɵDefaultValueSource || (ɵDefaultValueSource = {}));

/**
 * Lookup mode
 * @internal
 */
var LookupMode;
(function (LookupMode) {
    LookupMode["List"] = "List";
    LookupMode["SelectionWindow"] = "SelectionWindow";
})(LookupMode || (LookupMode = {}));

var ɵDataValueType;
(function (ɵDataValueType) {
    ɵDataValueType[ɵDataValueType["Guid"] = 0] = "Guid";
    ɵDataValueType[ɵDataValueType["Text"] = 1] = "Text";
    ɵDataValueType[ɵDataValueType["Integer"] = 4] = "Integer";
    ɵDataValueType[ɵDataValueType["Float"] = 5] = "Float";
    ɵDataValueType[ɵDataValueType["Money"] = 6] = "Money";
    ɵDataValueType[ɵDataValueType["DateTime"] = 7] = "DateTime";
    ɵDataValueType[ɵDataValueType["Date"] = 8] = "Date";
    ɵDataValueType[ɵDataValueType["Time"] = 9] = "Time";
    ɵDataValueType[ɵDataValueType["Lookup"] = 10] = "Lookup";
    ɵDataValueType[ɵDataValueType["Enum"] = 11] = "Enum";
    ɵDataValueType[ɵDataValueType["Boolean"] = 12] = "Boolean";
    ɵDataValueType[ɵDataValueType["Blob"] = 13] = "Blob";
    ɵDataValueType[ɵDataValueType["Image"] = 14] = "Image";
    ɵDataValueType[ɵDataValueType["CUSTOM_OBJECT"] = 15] = "CUSTOM_OBJECT";
    ɵDataValueType[ɵDataValueType["IMAGELOOKUP"] = 16] = "IMAGELOOKUP";
    ɵDataValueType[ɵDataValueType["COLLECTION"] = 17] = "COLLECTION";
    ɵDataValueType[ɵDataValueType["Color"] = 18] = "Color";
    ɵDataValueType[ɵDataValueType["LOCALIZABLE_STRING"] = 19] = "LOCALIZABLE_STRING";
    ɵDataValueType[ɵDataValueType["ENTITY"] = 20] = "ENTITY";
    ɵDataValueType[ɵDataValueType["ENTITY_COLLECTION"] = 21] = "ENTITY_COLLECTION";
    ɵDataValueType[ɵDataValueType["ENTITY_COLUMN_MAPPING_COLLECTION"] = 22] = "ENTITY_COLUMN_MAPPING_COLLECTION";
    ɵDataValueType[ɵDataValueType["HASH_TEXT"] = 23] = "HASH_TEXT";
    ɵDataValueType[ɵDataValueType["SECURE_TEXT"] = 24] = "SECURE_TEXT";
    ɵDataValueType[ɵDataValueType["FILE"] = 25] = "FILE";
    ɵDataValueType[ɵDataValueType["MAPPING"] = 26] = "MAPPING";
    ɵDataValueType[ɵDataValueType["SHORT_TEXT"] = 27] = "SHORT_TEXT";
    ɵDataValueType[ɵDataValueType["MEDIUM_TEXT"] = 28] = "MEDIUM_TEXT";
    ɵDataValueType[ɵDataValueType["MAXSIZE_TEXT"] = 29] = "MAXSIZE_TEXT";
    ɵDataValueType[ɵDataValueType["LONG_TEXT"] = 30] = "LONG_TEXT";
    ɵDataValueType[ɵDataValueType["FLOAT1"] = 31] = "FLOAT1";
    ɵDataValueType[ɵDataValueType["FLOAT2"] = 32] = "FLOAT2";
    ɵDataValueType[ɵDataValueType["FLOAT3"] = 33] = "FLOAT3";
    ɵDataValueType[ɵDataValueType["FLOAT4"] = 34] = "FLOAT4";
    ɵDataValueType[ɵDataValueType["LOCALIZABLE_PARAMETER_VALUES_LIST"] = 35] = "LOCALIZABLE_PARAMETER_VALUES_LIST";
    ɵDataValueType[ɵDataValueType["METADATA_TEXT"] = 36] = "METADATA_TEXT";
    ɵDataValueType[ɵDataValueType["STAGE_INDICATOR"] = 37] = "STAGE_INDICATOR";
    ɵDataValueType[ɵDataValueType["OBJECT_LIST"] = 38] = "OBJECT_LIST";
    ɵDataValueType[ɵDataValueType["COMPOSITE_OBJECT_LIST"] = 39] = "COMPOSITE_OBJECT_LIST";
    ɵDataValueType[ɵDataValueType["FLOAT8"] = 40] = "FLOAT8";
    ɵDataValueType[ɵDataValueType["FILE_LOCATOR"] = 41] = "FILE_LOCATOR";
    ɵDataValueType[ɵDataValueType["PHONE_TEXT"] = 42] = "PHONE_TEXT";
    ɵDataValueType[ɵDataValueType["RICH_TEXT"] = 43] = "RICH_TEXT";
    ɵDataValueType[ɵDataValueType["WEB_TEXT"] = 44] = "WEB_TEXT";
    ɵDataValueType[ɵDataValueType["EMAIL_TEXT"] = 45] = "EMAIL_TEXT";
})(ɵDataValueType || (ɵDataValueType = {}));

var ɵAggregationType;
(function (ɵAggregationType) {
    /** Aggregation function type not defined. */
    ɵAggregationType[ɵAggregationType["None"] = 0] = "None";
    /** Aggregation function type not defined. */
    ɵAggregationType[ɵAggregationType["Count"] = 1] = "Count";
    /** Sum of values of all elements. */
    ɵAggregationType[ɵAggregationType["Sum"] = 2] = "Sum";
    /** Average value for all elements. */
    ɵAggregationType[ɵAggregationType["Avg"] = 3] = "Avg";
    /** The minimum value among all elements. */
    ɵAggregationType[ɵAggregationType["Min"] = 4] = "Min";
    /** The maximum value among all elements. */
    ɵAggregationType[ɵAggregationType["Max"] = 5] = "Max";
    /** Top one record from collection. */
    ɵAggregationType[ɵAggregationType["TopOne"] = 6] = "TopOne";
})(ɵAggregationType || (ɵAggregationType = {}));

var ɵAggregationFunction;
(function (ɵAggregationFunction) {
    /** Aggregation function type not defined. */
    ɵAggregationFunction["None"] = "";
    /** Aggregation function type not defined. */
    ɵAggregationFunction["Count"] = "Count";
    /** Sum of values of all elements. */
    ɵAggregationFunction["Sum"] = "Sum";
    /** Average value for all elements. */
    ɵAggregationFunction["Avg"] = "Avg";
    /** The minimum value among all elements. */
    ɵAggregationFunction["Min"] = "Min";
    /** The maximum value among all elements. */
    ɵAggregationFunction["Max"] = "Max";
    /** Top one record from collection. */
    ɵAggregationFunction["TopOne"] = "TopOne";
})(ɵAggregationFunction || (ɵAggregationFunction = {}));

/**
 * Type of DataSchema. In combination with the name is used for unique identification of {@link DataSchema}.
 */
var ɵDataSchemaType;
(function (ɵDataSchemaType) {
    ɵDataSchemaType["Entity"] = "Entity";
    ɵDataSchemaType["ClientUnit"] = "ClientUnit";
})(ɵDataSchemaType || (ɵDataSchemaType = {}));

var ɵLogicalOperatorType;
(function (ɵLogicalOperatorType) {
    ɵLogicalOperatorType[ɵLogicalOperatorType["And"] = 0] = "And";
    ɵLogicalOperatorType[ɵLogicalOperatorType["Or"] = 1] = "Or";
})(ɵLogicalOperatorType || (ɵLogicalOperatorType = {}));

var ɵAggregationEvalType;
(function (ɵAggregationEvalType) {
    /** The scope of the aggregating function is not defined. */
    ɵAggregationEvalType[ɵAggregationEvalType["None"] = 0] = "None";
    /** Applies to all elements. */
    ɵAggregationEvalType[ɵAggregationEvalType["All"] = 1] = "All";
    /** Applies to unique values. */
    ɵAggregationEvalType[ɵAggregationEvalType["Distinct"] = 2] = "Distinct";
})(ɵAggregationEvalType || (ɵAggregationEvalType = {}));

var ɵArithmeticOperation;
(function (ɵArithmeticOperation) {
    /** Addition. */
    ɵArithmeticOperation[ɵArithmeticOperation["Addition"] = 0] = "Addition";
    /** Subtraction. */
    ɵArithmeticOperation[ɵArithmeticOperation["Subtraction"] = 1] = "Subtraction";
    /** Multiplication. */
    ɵArithmeticOperation[ɵArithmeticOperation["Multiplication"] = 2] = "Multiplication";
    /** Division. */
    ɵArithmeticOperation[ɵArithmeticOperation["Division"] = 3] = "Division";
})(ɵArithmeticOperation || (ɵArithmeticOperation = {}));

/* eslint-disable @typescript-eslint/naming-convention */
var ɵComparisonType;
(function (ɵComparisonType) {
    ɵComparisonType[ɵComparisonType["Between"] = 0] = "Between";
    ɵComparisonType[ɵComparisonType["Contain"] = 11] = "Contain";
    ɵComparisonType[ɵComparisonType["End_with"] = 13] = "End_with";
    ɵComparisonType[ɵComparisonType["Equal"] = 3] = "Equal";
    ɵComparisonType[ɵComparisonType["Exists"] = 15] = "Exists";
    ɵComparisonType[ɵComparisonType["Greater"] = 7] = "Greater";
    ɵComparisonType[ɵComparisonType["Greater_or_equal"] = 8] = "Greater_or_equal";
    ɵComparisonType[ɵComparisonType["Is_not_null"] = 2] = "Is_not_null";
    ɵComparisonType[ɵComparisonType["Is_null"] = 1] = "Is_null";
    ɵComparisonType[ɵComparisonType["Less"] = 5] = "Less";
    ɵComparisonType[ɵComparisonType["Less_or_equal"] = 6] = "Less_or_equal";
    ɵComparisonType[ɵComparisonType["Not_contain"] = 12] = "Not_contain";
    ɵComparisonType[ɵComparisonType["Not_end_with"] = 14] = "Not_end_with";
    ɵComparisonType[ɵComparisonType["Not_equal"] = 4] = "Not_equal";
    ɵComparisonType[ɵComparisonType["Not_exists"] = 16] = "Not_exists";
    ɵComparisonType[ɵComparisonType["Not_start_with"] = 10] = "Not_start_with";
    ɵComparisonType[ɵComparisonType["Start_with"] = 9] = "Start_with";
})(ɵComparisonType || (ɵComparisonType = {}));

var ɵDatePartType;
(function (ɵDatePartType) {
    /** Empty value. */
    ɵDatePartType[ɵDatePartType["None"] = 0] = "None";
    /** Day. */
    ɵDatePartType[ɵDatePartType["Day"] = 1] = "Day";
    /** Week. */
    ɵDatePartType[ɵDatePartType["Week"] = 2] = "Week";
    /** Month. */
    ɵDatePartType[ɵDatePartType["Month"] = 3] = "Month";
    /** Year. */
    ɵDatePartType[ɵDatePartType["Year"] = 4] = "Year";
    /** Day of the week. */
    ɵDatePartType[ɵDatePartType["WeekDay"] = 5] = "WeekDay";
    /** Hour. */
    ɵDatePartType[ɵDatePartType["Hour"] = 6] = "Hour";
    /** Minute. */
    ɵDatePartType[ɵDatePartType["HourMinute"] = 7] = "HourMinute";
})(ɵDatePartType || (ɵDatePartType = {}));

var ɵExpressionType;
(function (ɵExpressionType) {
    ɵExpressionType[ɵExpressionType["SchemaColumn"] = 0] = "SchemaColumn";
    ɵExpressionType[ɵExpressionType["Function"] = 1] = "Function";
    ɵExpressionType[ɵExpressionType["Parameter"] = 2] = "Parameter";
    ɵExpressionType[ɵExpressionType["SubQuery"] = 3] = "SubQuery";
    ɵExpressionType[ɵExpressionType["ArithmeticOperation"] = 4] = "ArithmeticOperation";
})(ɵExpressionType || (ɵExpressionType = {}));

var ɵFilterType;
(function (ɵFilterType) {
    ɵFilterType[ɵFilterType["None"] = 0] = "None";
    ɵFilterType[ɵFilterType["Compare"] = 1] = "Compare";
    ɵFilterType[ɵFilterType["IsNull"] = 2] = "IsNull";
    ɵFilterType[ɵFilterType["Between"] = 3] = "Between";
    ɵFilterType[ɵFilterType["In"] = 4] = "In";
    ɵFilterType[ɵFilterType["Exists"] = 5] = "Exists";
    ɵFilterType[ɵFilterType["FilterGroup"] = 6] = "FilterGroup";
})(ɵFilterType || (ɵFilterType = {}));

var ɵFunctionType;
(function (ɵFunctionType) {
    ɵFunctionType[ɵFunctionType["None"] = 0] = "None";
    /** Substitution by macro. */
    ɵFunctionType[ɵFunctionType["Macros"] = 1] = "Macros";
    /** Aggregating function. */
    ɵFunctionType[ɵFunctionType["Aggregation"] = 2] = "Aggregation";
    /** Date fragment. */
    ɵFunctionType[ɵFunctionType["DatePart"] = 3] = "DatePart";
    /** The size of the value in bytes, used for binary data. */
    ɵFunctionType[ɵFunctionType["Length"] = 4] = "Length";
    /** Window query function */
    ɵFunctionType[ɵFunctionType["Window"] = 5] = "Window";
    /** Date add. */
    ɵFunctionType[ɵFunctionType["DateAdd"] = 6] = "DateAdd";
    /** Date diff. */
    ɵFunctionType[ɵFunctionType["DateDiff"] = 7] = "DateDiff";
})(ɵFunctionType || (ɵFunctionType = {}));

var ɵOrderDirection;
(function (ɵOrderDirection) {
    ɵOrderDirection[ɵOrderDirection["None"] = 0] = "None";
    ɵOrderDirection[ɵOrderDirection["Asc"] = 1] = "Asc";
    ɵOrderDirection[ɵOrderDirection["Desc"] = 2] = "Desc";
})(ɵOrderDirection || (ɵOrderDirection = {}));

var ɵQueryMacrosType;
(function (ɵQueryMacrosType) {
    /** Macro type not defined. */
    ɵQueryMacrosType[ɵQueryMacrosType["None"] = 0] = "None";
    /** Current user. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentUser"] = 1] = "CurrentUser";
    /** Current user contact. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentUserContact"] = 2] = "CurrentUserContact";
    /** Yesterday. */
    ɵQueryMacrosType[ɵQueryMacrosType["Yesterday"] = 3] = "Yesterday";
    /** Today. */
    ɵQueryMacrosType[ɵQueryMacrosType["Today"] = 4] = "Today";
    /** Tomorrow. */
    ɵQueryMacrosType[ɵQueryMacrosType["Tomorrow"] = 5] = "Tomorrow";
    /** Previous week. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousWeek"] = 6] = "PreviousWeek";
    /** This week. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentWeek"] = 7] = "CurrentWeek";
    /** Next week. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextWeek"] = 8] = "NextWeek";
    /** Previous month. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousMonth"] = 9] = "PreviousMonth";
    /** Current month. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentMonth"] = 10] = "CurrentMonth";
    /** Next month. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextMonth"] = 11] = "NextMonth";
    /** Previous quarter. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousQuarter"] = 12] = "PreviousQuarter";
    /** Current quarter. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentQuarter"] = 13] = "CurrentQuarter";
    /** Next quarter. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextQuarter"] = 14] = "NextQuarter";
    /** Previous half of the year. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousHalfYear"] = 15] = "PreviousHalfYear";
    /** Current half-year. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentHalfYear"] = 16] = "CurrentHalfYear";
    /** Next half-year. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextHalfYear"] = 17] = "NextHalfYear";
    /** Last year. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousYear"] = 18] = "PreviousYear";
    /** This year. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentYear"] = 19] = "CurrentYear";
    /** Previous hour. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousHour"] = 20] = "PreviousHour";
    /** Current hour. */
    ɵQueryMacrosType[ɵQueryMacrosType["CurrentHour"] = 21] = "CurrentHour";
    /** Next hour. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextHour"] = 22] = "NextHour";
    /** Next year. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextYear"] = 23] = "NextYear";
    /** Next N Days. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextNDays"] = 24] = "NextNDays";
    /** Previous N days. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousNDays"] = 25] = "PreviousNDays";
    /** Next N hours. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextNHours"] = 26] = "NextNHours";
    /** Previous N hours. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousNHours"] = 27] = "PreviousNHours";
    /** Primary column. */
    ɵQueryMacrosType[ɵQueryMacrosType["PrimaryColumn"] = 34] = "PrimaryColumn";
    /** Primary displayed column. */
    ɵQueryMacrosType[ɵQueryMacrosType["PrimaryDisplayColumn"] = 35] = "PrimaryDisplayColumn";
    /** Primary image display column. */
    ɵQueryMacrosType[ɵQueryMacrosType["PrimaryImageColumn"] = 36] = "PrimaryImageColumn";
    /** Anniversary today. */
    ɵQueryMacrosType[ɵQueryMacrosType["DayOfYearToday"] = 37] = "DayOfYearToday";
    /** Anniversary on the date computed as today plus days offset. */
    ɵQueryMacrosType[ɵQueryMacrosType["DayOfYearTodayPlusDaysOffset"] = 38] = "DayOfYearTodayPlusDaysOffset";
    /** Anniversary on the next several days. */
    ɵQueryMacrosType[ɵQueryMacrosType["NextNDaysOfYear"] = 39] = "NextNDaysOfYear";
    /** Anniversary on the previous several days. */
    ɵQueryMacrosType[ɵQueryMacrosType["PreviousNDaysOfYear"] = 40] = "PreviousNDaysOfYear";
    /** Primary color display column. */
    ɵQueryMacrosType[ɵQueryMacrosType["PrimaryColorColumn"] = 41] = "PrimaryColorColumn";
})(ɵQueryMacrosType || (ɵQueryMacrosType = {}));

class ɵBaseExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [this._instanceOfKey];
    }
    static [Symbol.hasInstance](instance) {
        const instanceOfKeys = instance?.constructor?.['_instanceOfKeys'] ?? [];
        return instanceOfKeys.includes(this._instanceOfKey);
    }
    constructor(config) {
        this.isBlock = false;
        this.isBlock = config?.isBlock;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        throw new Error(`fromJson not supported on expression type ${this.constructor.name}`);
    }
    serializeItem(item) {
        return typeof item.toJson === 'function'
            ? item.toJson()
            : classToPlain(item, {
                exposeUnsetFields: false,
                excludePrefixes: ['_'],
            });
    }
    /**
     * Converts instance to json object.
     * @public
     */
    toJson() {
        return classToPlain(this, {
            exposeUnsetFields: false,
            excludePrefixes: ['_'],
        });
    }
}
/**
 * @internal
 * @dontChange
 */
ɵBaseExpression._instanceOfKey = 'devkit_BaseExpression';

class ɵArithmeticExpression extends ɵBaseExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.expressionType = ɵExpressionType.ArithmeticOperation;
        this.arithmeticOperation = config?.arithmeticOperation;
        this.leftArithmeticOperand = config?.leftArithmeticOperand.clone();
        this.rightArithmeticOperand = config?.rightArithmeticOperand.clone();
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const leftArithmeticOperand = expressionParser?.fromJson(dto['leftArithmeticOperand'], filterParser);
        const rightArithmeticOperand = expressionParser?.fromJson(dto['rightArithmeticOperand'], filterParser);
        const config = {
            leftArithmeticOperand,
            rightArithmeticOperand,
            arithmeticOperation: dto['arithmeticOperation'],
            isBlock: dto['isBlock'],
        };
        return new ɵArithmeticExpression(config);
    }
    clone() {
        return new ɵArithmeticExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵArithmeticExpression._instanceOfKey = 'devkit_ArithmeticExpression';

class ɵColumnExpression extends ɵBaseExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.expressionType = ɵExpressionType.SchemaColumn;
        this.columnPath = config?.columnPath;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto) {
        const expression = new ɵColumnExpression({ columnPath: dto['columnPath'] });
        return expression;
    }
    clone() {
        return new ɵColumnExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵColumnExpression._instanceOfKey = 'devkit_ColumnExpression';

/**
 * Expression parser interface
 * @public
 */
class ɵBaseExpressionParser {
    static fromJson(dto, filterParser) {
        throw new Error('not implemented');
    }
}

class ɵFunctionExpression extends ɵBaseExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.expressionType = ɵExpressionType.Function;
    }
}
/**
 * @internal
 * @dontChange
 */
ɵFunctionExpression._instanceOfKey = 'devkit_FunctionExpression';

class ɵArgumentFunctionExpression extends ɵFunctionExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵFunctionExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.functionArgument = config?.functionArgument.clone();
    }
    toJson() {
        const result = super.toJson();
        if (this.functionArgument) {
            result['functionArgument'] = this.serializeItem(this.functionArgument);
        }
        return result;
    }
}
/**
 * @internal
 * @dontChange
 */
ɵArgumentFunctionExpression._instanceOfKey = 'devkit_ArgumentFunctionExpression';

class ɵAggregationFunctionExpression extends ɵArgumentFunctionExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.functionType = ɵFunctionType.Aggregation;
        this.aggregationType = config?.aggregationType;
        this.aggregationEvalType = config?.aggregationEvalType;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);
        const aggregationType = dto['aggregationType'];
        const aggregationEvalType = dto['aggregationEvalType'];
        return new ɵAggregationFunctionExpression({
            functionArgument,
            aggregationType,
            aggregationEvalType,
            isBlock: dto['isBlock'],
        });
    }
    clone() {
        return new ɵAggregationFunctionExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵAggregationFunctionExpression._instanceOfKey = 'devkit_AggregationFunctionExpression';

class ɵDatePartFunctionExpression extends ɵArgumentFunctionExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.functionType = ɵFunctionType.DatePart;
        this.datePartType = config?.datePartType;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);
        const datePartType = dto['datePartType'];
        return new ɵDatePartFunctionExpression({ functionArgument, datePartType, isBlock: dto['isBlock'] });
    }
    clone() {
        return new ɵDatePartFunctionExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵDatePartFunctionExpression._instanceOfKey = 'devkit_DatePartFunctionExpression';

class ɵLengthFunctionExpression extends ɵArgumentFunctionExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.functionType = ɵFunctionType.Length;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);
        return new ɵLengthFunctionExpression({ functionArgument, isBlock: dto['isBlock'] });
    }
    clone() {
        return new ɵLengthFunctionExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵLengthFunctionExpression._instanceOfKey = 'devkit_LengthFunctionExpression';

class ɵMacrosFunctionExpression extends ɵFunctionExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵFunctionExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.functionType = ɵFunctionType.Macros;
        this.macrosType = config?.macrosType;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto) {
        const expression = new ɵMacrosFunctionExpression({ macrosType: dto['macrosType'] });
        return expression;
    }
    clone() {
        return new ɵMacrosFunctionExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵMacrosFunctionExpression._instanceOfKey = 'devkit_MacrosFunctionExpression';

class ɵWindowFunctionExpression extends ɵArgumentFunctionExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.functionType = ɵFunctionType.Window;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);
        return new ɵWindowFunctionExpression({ functionArgument, isBlock: dto['isBlock'] });
    }
    clone() {
        return new ɵWindowFunctionExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵWindowFunctionExpression._instanceOfKey = 'devkit_WindowFunctionExpression';

class ɵParameterExpression extends ɵBaseExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.expressionType = ɵExpressionType.Parameter;
        const value = config?.value;
        if (value instanceof Date) {
            const cloneDate = new Date();
            cloneDate.setTime(value.getTime());
            this.value = cloneDate;
        }
        else if (!value) {
            this.value = value;
        }
        else {
            this.value = typeof value === 'object' ? { ...value } : value;
        }
        this.dataValueType = config?.dataValueType ?? ɵDataValueType.Text;
        this.parameter = {
            dataValueType: this.dataValueType,
            ...this._getParameterValueMetadata(),
        };
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto) {
        const expression = new ɵParameterExpression(dto['parameter']);
        return expression;
    }
    _convertStringToBlobArray(str) {
        const out = [];
        let position = 0;
        for (let i = 0; i < str.length; i++) {
            const code = str.charCodeAt(i);
            if (code < 128) {
                out[position++] = String.fromCharCode(code);
            }
            else if (code < 2048) {
                /* eslint-disable no-bitwise */
                out[position++] = String.fromCharCode((code >> 6) | 192);
                out[position++] = String.fromCharCode((code & 63) | 128);
            }
            else {
                out[position++] = String.fromCharCode((code >> 12) | 224);
                out[position++] = String.fromCharCode(((code >> 6) & 63) | 128);
                out[position++] = String.fromCharCode((code & 63) | 128);
                /* eslint-enable no-bitwise */
            }
        }
        return out;
    }
    _getParameterValueMetadata() {
        if (this.dataValueType === ɵDataValueType.Blob) {
            return {
                arrayValue: !this.value ? [] : this._convertStringToBlobArray(this.value),
            };
        }
        else if (this.value instanceof Date) {
            return {
                value: ɵencodeDate(this.value),
            };
        }
        else {
            return {
                value: this.value,
            };
        }
    }
    clone() {
        return new ɵParameterExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵParameterExpression._instanceOfKey = 'devkit_ParameterExpression';
__decorate([
    Exclude(),
    __metadata("design:type", Object)
], ɵParameterExpression.prototype, "value", void 0);
__decorate([
    Exclude(),
    __metadata("design:type", Number)
], ɵParameterExpression.prototype, "dataValueType", void 0);

class ɵSubQueryExpression extends ɵBaseExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.expressionType = ɵExpressionType.SubQuery;
        this.columnPath = config?.columnPath;
        const subFilter = config?.subFilters;
        this.subFilters = typeof subFilter?.clone === 'function' ? subFilter.clone() : subFilter;
        this.subOrderDirection = config.subOrderDirection;
        this.subOrderColumn = config.subOrderColumn;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser) {
        const expression = new ɵSubQueryExpression({
            columnPath: dto['columnPath'],
            subFilters: filterParser.fromJson(dto['subFilters']),
            subOrderDirection: dto['subOrderDirection'],
            subOrderColumn: dto['subOrderColumn'],
        });
        return expression;
    }
    clone() {
        return new ɵSubQueryExpression(this);
    }
    toJson() {
        const result = super.toJson();
        if (this.subFilters) {
            result['subFilters'] = this.serializeItem(this.subFilters);
        }
        return result;
    }
}
/**
 * @internal
 * @dontChange
 */
ɵSubQueryExpression._instanceOfKey = 'devkit_SubQueryExpression';

class ɵAggregationSubQueryExpression extends ɵSubQueryExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵSubQueryExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config);
        this.aggregationType = config?.aggregationType;
        this.functionType = config?.functionType;
    }
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser) {
        const subQueryExpression = super.fromJson(dto, filterParser);
        const expression = new ɵAggregationSubQueryExpression({
            aggregationType: dto['aggregationType'],
            functionType: dto['functionType'],
            ...subQueryExpression,
        });
        return expression;
    }
    clone() {
        return new ɵAggregationSubQueryExpression(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵAggregationSubQueryExpression._instanceOfKey = 'devkit_AggregationSubQueryExpression';

/**
 * Function expression resolver.
 * @public
 */
class FunctionExpressionResolver {
    static resolve(dto) {
        const expressionClass = {
            [ɵFunctionType.Macros]: ɵMacrosFunctionExpression,
            [ɵFunctionType.Length]: ɵLengthFunctionExpression,
            [ɵFunctionType.Window]: ɵWindowFunctionExpression,
            [ɵFunctionType.DatePart]: ɵDatePartFunctionExpression,
            [ɵFunctionType.DateAdd]: ɵDatePartFunctionExpression,
            [ɵFunctionType.DateDiff]: ɵDatePartFunctionExpression,
        };
        return expressionClass[dto['functionType']];
    }
}
/**
 * Expression resolver.
 * @public
 */
class ɵExpressionResolver {
    static resolve(expressionType, dto) {
        const expressionClass = {
            [ɵExpressionType.SchemaColumn]: ɵColumnExpression,
            [ɵExpressionType.Parameter]: ɵParameterExpression,
            [ɵExpressionType.SubQuery]: ɵAggregationSubQueryExpression,
            [ɵExpressionType.ArithmeticOperation]: ɵArithmeticExpression,
            [ɵExpressionType.Function]: FunctionExpressionResolver.resolve(dto),
        };
        return expressionClass[expressionType];
    }
}

/**
 * Expression parser.
 * @public
 */
class ɵExpressionParser extends ɵBaseExpressionParser {
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto, filterParser) {
        const expressionType = dto['expressionType'];
        return ɵExpressionResolver.resolve(expressionType, dto).fromJson(dto, filterParser, ɵExpressionParser);
    }
}

const ɵEXPRESSION_TYPE_MOCK = -1;
class ɵExpressionMock extends ɵBaseExpression {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];
    }
    constructor(config) {
        super(config || {});
        this.expressionType = ɵEXPRESSION_TYPE_MOCK;
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    get plainObject() {
        return classToPlain(this, { exposeUnsetFields: false, excludePrefixes: ['_'] });
    }
    clone() {
        return new ɵExpressionMock(this);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵExpressionMock._instanceOfKey = 'devkit_ExpressionMock';

class ɵBaseFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [this._instanceOfKey];
    }
    static [Symbol.hasInstance](instance) {
        const instanceOfKeys = instance?.constructor?.['_instanceOfKeys'] ?? [];
        return instanceOfKeys.includes(this._instanceOfKey);
    }
    constructor(filterType) {
        this.isEnabled = true;
        this.trimDateTimeParameterToDate = false;
        this.filterType = filterType;
    }
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        throw new Error(`fromJson not supported on filter type ${this.constructor.name}`);
    }
    serializeItem(item) {
        return typeof item.toJson === 'function'
            ? item.toJson()
            : classToPlain(item, {
                exposeUnsetFields: false,
                excludePrefixes: ['_'],
            });
    }
    /**
     * Converts instance to json object.
     * @public
     */
    toJson() {
        return classToPlain(this, {
            exposeUnsetFields: false,
            excludePrefixes: ['_'],
        });
    }
}
/**
 * @internal
 * @dontChange
 */
ɵBaseFilter._instanceOfKey = 'devkit_BaseFilter';

class ɵFilterMock extends ɵBaseFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseFilter._instanceOfKeys, this._instanceOfKey];
    }
    constructor(filterType = ɵFilterType.None) {
        super(filterType);
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    get plainObject() {
        return classToPlain(this, { exposeUnsetFields: false, excludePrefixes: ['_'] });
    }
    clone() {
        return new ɵFilterMock(this.filterType);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵFilterMock._instanceOfKey = 'devkit_FilterMock';

const ɵparserMock = {
    fromJson: (data) => ({
        ...data,
        clone: () => data,
    }),
    clone: () => this,
};

class ɵSingleFilter extends ɵBaseFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseFilter._instanceOfKeys, this._instanceOfKey];
    }
    constructor(filterType, comparisonType, leftExpression) {
        super(filterType);
        this.comparisonType = comparisonType;
        this.leftExpression = leftExpression.clone();
    }
    toJson() {
        return {
            ...super.toJson(),
            leftExpression: this.serializeItem(this.leftExpression),
        };
    }
}
/**
 * @internal
 * @dontChange
 */
ɵSingleFilter._instanceOfKey = 'devkit_SingleFilter';

class ɵCompareFilter extends ɵSingleFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];
    }
    constructor(comparisonType, leftExpression, rightExpression) {
        super(ɵFilterType.Compare, comparisonType, leftExpression);
        this.rightExpression = rightExpression.clone();
    }
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const filter = new ɵCompareFilter(dto['comparisonType'], expressionParser.fromJson(dto['leftExpression'], filterParser), expressionParser.fromJson(dto['rightExpression'], filterParser));
        return filter;
    }
    clone() {
        return new ɵCompareFilter(this.comparisonType, this.leftExpression, this.rightExpression);
    }
    toJson() {
        return {
            ...super.toJson(),
            rightExpression: this.serializeItem(this.rightExpression),
        };
    }
}
/**
 * @internal
 * @dontChange
 */
ɵCompareFilter._instanceOfKey = 'devkit_CompareFilter';

class ɵBetweenFilter extends ɵSingleFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];
    }
    constructor(leftExpression, rightLessExpression, rightGreaterExpression) {
        super(ɵFilterType.Between, ɵComparisonType.Between, leftExpression);
        this.rightLessExpression = rightLessExpression.clone();
        this.rightGreaterExpression = rightGreaterExpression.clone();
    }
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const filter = new ɵBetweenFilter(expressionParser.fromJson(dto['leftExpression'], filterParser), expressionParser.fromJson(dto['rightLessExpression'], filterParser), expressionParser.fromJson(dto['rightGreaterExpression'], filterParser));
        return filter;
    }
    clone() {
        return new ɵBetweenFilter(this.leftExpression, this.rightLessExpression, this.rightGreaterExpression);
    }
    toJson() {
        return {
            ...super.toJson(),
            rightLessExpression: this.serializeItem(this.rightLessExpression),
            rightGreaterExpression: this.serializeItem(this.rightGreaterExpression),
        };
    }
}
/**
 * @internal
 * @dontChange
 */
ɵBetweenFilter._instanceOfKey = 'devkit_BetweenFilter';

class ɵExistsFilter extends ɵSingleFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];
    }
    constructor(leftExpression, subFilters, comparisonType = ɵComparisonType.Exists, isAggregative = true) {
        super(ɵFilterType.Exists, comparisonType, leftExpression);
        this.subFilters = subFilters?.clone();
        this.isAggregative = isAggregative;
    }
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const leftExpression = expressionParser.fromJson(dto['leftExpression'], filterParser);
        const subFilters = filterParser.fromJson(dto['subFilters']);
        return new ɵExistsFilter(leftExpression, subFilters, dto['comparisonType'], dto['isAggregative']);
    }
    clone() {
        return new ɵExistsFilter(this.leftExpression, this.subFilters, this.comparisonType, this.isAggregative);
    }
    toJson() {
        const result = super.toJson();
        if (this.subFilters) {
            result['subFilters'] = this.serializeItem(this.subFilters);
        }
        return result;
    }
}
/**
 * @internal
 * @dontChange
 */
ɵExistsFilter._instanceOfKey = 'devkit_ExistsFilter';

class ɵInFilter extends ɵSingleFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];
    }
    constructor(comparisonType, leftExpression, rightExpressions) {
        super(ɵFilterType.In, comparisonType, leftExpression);
        this.rightExpressions = rightExpressions.map((expression) => expression.clone());
    }
    /**
     * Parses in filter from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        const dtoRightExpressions = (dto['rightExpressions'] ?? []);
        return new ɵInFilter(dto['comparisonType'], expressionParser.fromJson(dto['leftExpression'], filterParser), dtoRightExpressions.map((expression) => expressionParser.fromJson(expression, filterParser)));
    }
    clone() {
        return new ɵInFilter(this.comparisonType, this.leftExpression, this.rightExpressions);
    }
    toJson() {
        return {
            ...super.toJson(),
            rightExpressions: this.rightExpressions.map((expression) => this.serializeItem(expression)),
        };
    }
}
/**
 * @internal
 * @dontChange
 */
ɵInFilter._instanceOfKey = 'devkit_InFilter';

class ɵIsNullFilter extends ɵSingleFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];
    }
    constructor(comparisonType, leftExpression) {
        super(ɵFilterType.IsNull, comparisonType, leftExpression);
    }
    get isNull() {
        return this.comparisonType === ɵComparisonType.Is_null;
    }
    /**
     * Parses isNull filter from json.
     * @public
     */
    static fromJson(dto, filterParser, expressionParser) {
        return new ɵIsNullFilter(dto['comparisonType'], expressionParser.fromJson(dto['leftExpression'], filterParser));
    }
    clone() {
        return new ɵIsNullFilter(this.comparisonType, this.leftExpression);
    }
}
/**
 * @internal
 * @dontChange
 */
ɵIsNullFilter._instanceOfKey = 'devkit_IsNullFilter';
__decorate([
    Expose(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], ɵIsNullFilter.prototype, "isNull", null);

/**
 * Empty Guid constant.
 * @public
 */
const ɵEMPTY_GUID = '00000000-0000-0000-0000-000000000000';
/**
 * Regular expression for Guid validation.
 * @public
 */
const validator = new RegExp('^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$', 'i');
/**
 * Generates guid part.
 * @param length Part length.
 * @public
 */
function generateGuidPart(length) {
    let out = '';
    for (let i = 0; i < length; i++) {
        // eslint-disable-next-line no-bitwise
        out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    return out;
}
/**
 * Generates new Guid.
 * @public
 */
function ɵgenerateGuid() {
    return [
        generateGuidPart(2),
        generateGuidPart(1),
        generateGuidPart(1),
        generateGuidPart(1),
        generateGuidPart(3),
    ].join('-');
}
/**
 * Checks if value is Guid.
 * @param value Value for check.
 * @public
 */
function ɵisGuid(value) {
    return Boolean(value) && validator.test(value);
}
/**
 * Checks if Guid is empty value or equal to EMPTY_GUID.
 * @param guid Guid for check.
 * @public
 */
function ɵisEmptyGuid(guid) {
    return !guid || guid === ɵEMPTY_GUID;
}

/**
 * @public
 */
class ɵNextHandlerAlreadySpecifiedException extends Error {
    constructor() {
        super('Next handler already specified');
    }
}

class ɵArgumentEmptyException extends Error {
    // region Constructors: Public
    constructor(argumentName) {
        super(`Argument with name '${argumentName}' is empty.`);
    }
}

class ɵArgumentOutOfRangeException extends Error {
    // region Constructors: Public
    constructor(argumentName) {
        super(`Argument with name '${argumentName}' is out of range.`);
    }
}

class ɵItemNotFoundException extends Error {
    // region Constructors: Public
    constructor(key) {
        super(`Item with key '${key}' does not exist.`);
    }
}

class ɵValidationUtilities {
    // region Methods: Public
    static checkArgumentEmpty(argumentName, argumentValue) {
        if (argumentValue === undefined || argumentValue === null) {
            throw new ɵArgumentEmptyException(argumentName);
        }
    }
    static checkArrayEmpty(argumentName, argumentValue) {
        ɵValidationUtilities.checkArgumentEmpty(argumentName, argumentValue);
        if (argumentValue.length === 0) {
            throw new ɵArgumentEmptyException(argumentName);
        }
    }
    static checkStringIsNotEmpty(argumentName, argumentValue) {
        this.checkArgumentEmpty(argumentName, argumentValue);
        if (argumentValue === '') {
            throw new ɵArgumentEmptyException(argumentName);
        }
        return argumentValue;
    }
    static checkArgumentOutOfRange(argumentName, argumentValue, range) {
        if (range.begin && argumentValue < range.begin) {
            throw new ɵArgumentOutOfRangeException(argumentName);
        }
        if (range.end && argumentValue > range.end) {
            throw new ɵArgumentOutOfRangeException(argumentName);
        }
    }
}

class ɵFilterGroup extends ɵBaseFilter {
    /**
     * @internal
     * @dontChange
     */
    static get _instanceOfKeys() {
        return [...ɵBaseFilter._instanceOfKeys, this._instanceOfKey];
    }
    get items() {
        const result = {};
        this.filters.forEach((filter, key) => {
            result[key] = this.serializeItem(filter);
        });
        return result;
    }
    constructor(logicalOperation = ɵLogicalOperatorType.And) {
        super(ɵFilterType.FilterGroup);
        this.filters = new Map();
        this.logicalOperation = logicalOperation;
    }
    /**
     * Parses filter group from json.
     * @public
     */
    static fromJson(dto, filterParser) {
        const logicalOperation = dto['logicalOperation'];
        const group = new ɵFilterGroup(logicalOperation || ɵLogicalOperatorType.And);
        Object.entries(dto['items']).forEach(([key, filterDTO]) => {
            group.add(filterParser.fromJson(filterDTO), key);
        });
        return group;
    }
    /**
     * Returns filter item by index.
     * @param index Item index.
     * @returns Filter.
     */
    getItemByIndex(index) {
        return this.items[Object.keys(this.items)[index]];
    }
    /**
     * Creates and adds compare filter by value.
     * @param comparisonType Comparison type.
     * @param columnPath Column path.
     * @param parameterValue Parameter value.
     * @param filterKey Filter key.
     */
    addSchemaColumnFilterWithParameter(comparisonType, columnPath, parameterValue, filterKey) {
        const leftExpression = new ɵColumnExpression({ columnPath });
        const rightExpression = new ɵParameterExpression({ value: parameterValue });
        const filter = new ɵCompareFilter(comparisonType, leftExpression, rightExpression);
        this.add(filter, filterKey);
    }
    /**
     * Creates and adds in filter by values.
     * @param comparisonType Comparison type.
     * @param columnPath Column path.
     * @param parameterValues Parameter values.
     * @param filterKey Filter key.
     */
    addSchemaColumnInFilterWithParameters(comparisonType, columnPath, parameterValues, filterKey) {
        const leftExpression = new ɵColumnExpression({ columnPath });
        const expressions = parameterValues.map((singleParameterValue) => new ɵParameterExpression({
            value: singleParameterValue,
        }));
        const filter = new ɵInFilter(comparisonType, leftExpression, expressions);
        this.add(filter, filterKey);
    }
    addSchemaColumnIsNullFilter(columnPath, filterKey) {
        const leftExpression = new ɵColumnExpression({ columnPath });
        const filter = new ɵIsNullFilter(ɵComparisonType.Is_null, leftExpression);
        this.add(filter, filterKey);
    }
    /**
     * Creates and adds not null filter.
     * @param columnPath Column path.
     * @param filterKey Filter key.
     */
    addSchemaColumnIsNotNullFilter(columnPath, filterKey) {
        const leftExpression = new ɵColumnExpression({ columnPath });
        const filter = new ɵIsNullFilter(ɵComparisonType.Is_not_null, leftExpression);
        this.add(filter, filterKey);
    }
    /**
     * Creates and adds filter between less value and greater value.
     * @param columnPath Column path.
     * @param lessParamValue Less parameter value.
     * @param greaterParamValue Greater parameter value.
     * @param filterKey Filter key.
     */
    addSchemaColumnBetweenFilterWithParameters(columnPath, lessParamValue, greaterParamValue, filterKey) {
        const leftExpression = new ɵColumnExpression({ columnPath });
        const rightLessExpression = new ɵParameterExpression({ value: lessParamValue });
        const rightGreaterExpression = new ɵParameterExpression({ value: greaterParamValue });
        const filter = new ɵBetweenFilter(leftExpression, rightLessExpression, rightGreaterExpression);
        this.add(filter, filterKey);
    }
    addExistsFilter(columnPath, subFilters, filterKey) {
        const leftExpression = new ɵColumnExpression({ columnPath });
        const filter = new ɵExistsFilter(leftExpression, subFilters);
        this.add(filter, filterKey);
    }
    addNotExistsFilter(columnPath, subFilters, filterKey) {
        const leftExpression = new ɵColumnExpression({ columnPath });
        const filter = new ɵExistsFilter(leftExpression, subFilters, ɵComparisonType.Not_exists);
        this.add(filter, filterKey);
    }
    add(filter, filterKey) {
        ɵValidationUtilities.checkArgumentEmpty('filter', filter);
        const key = filterKey || ɵgenerateGuid();
        this.filters.set(key, filter);
    }
    clone() {
        const filterGroup = new ɵFilterGroup(this.logicalOperation);
        this.filters.forEach((filter, filterKey) => {
            filterGroup.filters.set(filterKey, filter.clone());
        });
        return filterGroup;
    }
}
/**
 * @internal
 * @dontChange
 */
ɵFilterGroup._instanceOfKey = 'devkit_FilterGroup';
__decorate([
    Exclude(),
    __metadata("design:type", Object)
], ɵFilterGroup.prototype, "filters", void 0);
__decorate([
    Expose(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], ɵFilterGroup.prototype, "items", null);

/**
 * Filter parser interface
 * @public
 */
class ɵBaseFilterParser {
    static fromJson(dto) {
        throw new Error('not implemented');
    }
}

/**
 * Filter resolver.
 * @public
 */
class ɵFilterResolver {
    static resolve(filterType) {
        const filterClass = {
            [ɵFilterType.Compare]: ɵCompareFilter,
            [ɵFilterType.FilterGroup]: ɵFilterGroup,
            [ɵFilterType.In]: ɵInFilter,
            [ɵFilterType.IsNull]: ɵIsNullFilter,
            [ɵFilterType.Exists]: ɵExistsFilter,
            [ɵFilterType.Between]: ɵBetweenFilter,
        };
        return filterClass[filterType];
    }
}

/**
 * Filter parser.
 * @public
 */
class ɵFilterParser extends ɵBaseFilterParser {
    static fromJson(dto) {
        const filterType = dto['filterType'];
        return ɵFilterResolver.resolve(filterType).fromJson(dto, ɵFilterParser, ɵExpressionParser);
    }
}

const ɵDEFAULT_FILTER_PLAIN_OBJ = {
    isEnabled: true,
    trimDateTimeParameterToDate: false,
};
function ɵgetFilterPlainObj(filterPlainObj) {
    return {
        ...ɵDEFAULT_FILTER_PLAIN_OBJ,
        ...filterPlainObj,
    };
}

class ɵBaseQueryColumn {
    constructor(expression) {
        this.orderDirection = ɵOrderDirection.None;
        this.orderPosition = -1;
        this.isVisible = true;
        this.expression = expression;
    }
    /**
     * Adds ordering options.
     * @param orderDirection Direction.
     * @param orderPosition Position.
     * @returns Self.
     */
    withOrdering(orderDirection, orderPosition) {
        ɵValidationUtilities.checkArgumentEmpty('orderDirection', orderDirection);
        ɵValidationUtilities.checkArgumentEmpty('orderPosition', orderPosition);
        ɵValidationUtilities.checkArgumentOutOfRange('orderPosition', orderPosition, { begin: -1 });
        this.orderDirection = orderDirection;
        this.orderPosition = orderPosition;
        return this;
    }
    /**
     * Adds options.
     * @param options Options.
     * @returns Self.
     */
    withOptions(options) {
        ɵValidationUtilities.checkArgumentEmpty('options', options);
        this.isVisible = options.isVisible ?? true;
        return this;
    }
    /**
     * Adds caption.
     * @param caption Caption.
     * @returns Self.
     */
    withCaption(caption) {
        ɵValidationUtilities.checkArgumentEmpty('caption', caption);
        this.caption = caption;
        return this;
    }
}

class ɵArithmeticQueryColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(arithmeticOperation, leftArithmeticOperand, rightArithmeticOperand) {
        super(new ɵArithmeticExpression({ arithmeticOperation, leftArithmeticOperand, rightArithmeticOperand }));
    }
}

class ɵEntityQueryColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(columnPath) {
        super(new ɵColumnExpression({ columnPath }));
    }
}

class ɵParameterQueryColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(value, dataValueType) {
        super(new ɵParameterExpression({ value, dataValueType }));
    }
}

class ɵAggregationSubQueryColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(columnPath, aggregationType, subFilters, subOrderDirection, subOrderColumn) {
        super(new ɵAggregationSubQueryExpression({
            aggregationType,
            columnPath,
            subFilters,
            subOrderDirection,
            subOrderColumn,
        }));
    }
}

class ɵSubQueryColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(columnPath, subFilters) {
        super(new ɵSubQueryExpression({ columnPath, subFilters }));
    }
}

class ɵAggregationFunctionColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(aggregationType, aggregationEvalType, functionArgument) {
        super(new ɵAggregationFunctionExpression({
            aggregationType,
            aggregationEvalType,
            functionArgument,
        }));
    }
}

class ɵDatePartFunctionColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(datePartType, functionArgument) {
        super(new ɵDatePartFunctionExpression({
            datePartType,
            functionArgument,
        }));
    }
    // endregion
    // region Properties: Public
    get datePartType() {
        return this.expression?.datePartType;
    }
}

class ɵLengthFunctionColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(functionArgument) {
        super(new ɵLengthFunctionExpression({ functionArgument }));
    }
}

class ɵMacrosFunctionColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(macrosType) {
        super(new ɵMacrosFunctionExpression({ macrosType }));
    }
}

class ɵWindowFunctionColumn extends ɵBaseQueryColumn {
    // region Constructors: Public
    constructor(functionArgument) {
        super(new ɵWindowFunctionExpression({ functionArgument }));
    }
}

const ɵDEFAULT_COLUMN_PLAIN_OBJ = {
    isVisible: true,
    orderPosition: -1,
    orderDirection: ɵOrderDirection.None,
};
function ɵgetColumnPlainObj(expressionPlainObj) {
    return {
        ...ɵDEFAULT_COLUMN_PLAIN_OBJ,
        expression: expressionPlainObj,
    };
}

/**
 * @public
 */
class ɵBaseQuery {
    // region Constructors: Protected
    constructor(operationType, rootSchemaName) {
        this.operationType = operationType;
        this.rootSchemaName = rootSchemaName;
        ɵValidationUtilities.checkArgumentEmpty('_operationType', operationType);
        ɵValidationUtilities.checkArgumentEmpty('_rootSchemaName', rootSchemaName);
    }
    // endregion
    // region Methods: Public
    getMetadata() {
        return classToPlain(this, { exposeUnsetFields: false, excludePrefixes: ['_'] });
    }
}

/**
 * @public
 */
class ɵBaseFilterableQuery extends ɵBaseQuery {
    constructor(operationType, rootSchemaName) {
        super(operationType, rootSchemaName);
        this.filters = new ɵFilterGroup();
    }
    clearFilters() {
        this.filters.filters.clear();
    }
    getMetadata() {
        return {
            ...super.getMetadata(),
            filters: this.filters.toJson(),
        };
    }
}

/**
 * @public
 */
var ɵQueryOperationType;
(function (ɵQueryOperationType) {
    ɵQueryOperationType[ɵQueryOperationType["Select"] = 0] = "Select";
    ɵQueryOperationType[ɵQueryOperationType["Insert"] = 1] = "Insert";
    ɵQueryOperationType[ɵQueryOperationType["Update"] = 2] = "Update";
    ɵQueryOperationType[ɵQueryOperationType["Delete"] = 3] = "Delete";
    // Batch,
    // ListSelect,
    // FilteredSelect,
    // LookupSelect
})(ɵQueryOperationType || (ɵQueryOperationType = {}));

/**
 * @public
 */
class ɵDeleteQuery extends ɵBaseFilterableQuery {
    // region Constructors: Public
    constructor(rootSchemaName) {
        super(ɵQueryOperationType.Delete, rootSchemaName);
    }
}

/**
 * @public
 */
class ɵEntitySchemaQuery extends ɵBaseFilterableQuery {
    constructor(rootSchemaName) {
        super(ɵQueryOperationType.Select, rootSchemaName);
        this._columns = new Map();
        this.isDistinct = false;
        /**
         * Number of rows to select.
         */
        this.rowCount = -1;
        /**
         * Rows count to skip.
         */
        this.rowsOffset = -1;
        this.useLocalization = true;
        this.useRecordDeactivation = false;
        this._getIsPageable = () => this.rowCount > 0 && this.rowsOffset > -1;
    }
    _internalAddColumn(key, column) {
        if (!this._columns.has(key)) {
            this._columns.set(key, column);
        }
    }
    // endregion
    // region Methods: Public
    /**
     * Returns column instance by column alias.
     * @param columnAlias Column alias.
     * @returns [BaseQueryColumn] Column instance.
     */
    getColumn(columnAlias) {
        if (!this._columns.has(columnAlias)) {
            throw new ɵItemNotFoundException(columnAlias);
        }
        return this.findColumn(columnAlias);
    }
    /**
     * Returns column instance by column alias if not found returns null.
     */
    findColumn(columnAlias) {
        return this._columns.get(columnAlias);
    }
    /**
     * @inheritDoc
     */
    getMetadata() {
        return {
            ...super.getMetadata(),
            columns: {
                items: classToPlain(this._columns, { exposeUnsetFields: false, excludePrefixes: ['_'] }),
            },
            allColumns: false,
            isDistinct: this.isDistinct,
            ignoreDisplayValues: false,
            rowCount: this.rowCount,
            rowsOffset: this.rowsOffset,
            isPageable: this._getIsPageable(),
            conditionalValues: this.conditionalValues ? this.conditionalValues : null,
            isHierarchical: false,
            hierarchicalMaxDepth: 0,
            hierarchicalColumnName: null,
            hierarchicalColumnValue: null,
            useLocalization: this.useLocalization,
            useRecordDeactivation: this.useRecordDeactivation,
        };
    }
    /**
     * Add column.
     * @param column Column path.
     * @param columnAlias Column alias.
     * @returns [BaseQueryColumn] Column instance.
     */
    addColumn(column, columnAlias) {
        this._internalAddColumn(columnAlias, column);
        return column;
    }
    /**
     * Add column by column path.
     * @param columnPath Column path.
     * @param columnAlias Column alias.
     * @returns [EntityQueryColumn] Column instance.
     */
    addSchemaColumn(columnPath, columnAlias) {
        ɵValidationUtilities.checkArgumentEmpty('columnPath', columnPath);
        const column = new ɵEntityQueryColumn(columnPath);
        this._internalAddColumn(columnAlias || columnPath, column);
        return column;
    }
    /**
     * Add aggregation sub query column.
     * @param columnPath Column path.
     * @param aggregationType Aggregation type.
     * @param subFilters Sub query filters.
     * @param columnAlias Column alias.
     * @returns [AggregationSubQueryColumn] Column instance.
     */
    addAggregationSubQueryColumn(columnPath, aggregationType, aggregationConfig, columnAlias) {
        const column = new ɵAggregationSubQueryColumn(columnPath, aggregationType, aggregationConfig.filter, aggregationConfig.sortByDirection, aggregationConfig.sortByColumn);
        this._internalAddColumn(columnAlias || columnPath, column);
        return column;
    }
    /**
     * Add parameter column.
     * @param value Parameter value.
     * @param dataValueType Parameter data value type.
     * @param columnAlias Column alias.
     * @returns [ParameterQueryColumn] Column instance.
     */
    addParameterColumn(value, dataValueType, columnAlias) {
        const column = new ɵParameterQueryColumn(value, dataValueType);
        this._internalAddColumn(columnAlias, column);
        return column;
    }
    /**
     * Add arithmetic column.
     * @param arithmeticOperation Arithmetic operation.
     * @param leftArithmeticOperand Left arithmetic operand expression.
     * @param rightArithmeticOperand Right arithmetic operand expression.
     * @param columnAlias Column alias.
     * @returns [ArithmeticQueryColumn] Column instance.
     */
    addArithmeticColumn(arithmeticOperation, leftArithmeticOperand, rightArithmeticOperand, columnAlias) {
        const column = new ɵArithmeticQueryColumn(arithmeticOperation, leftArithmeticOperand, rightArithmeticOperand);
        this._internalAddColumn(columnAlias, column);
        return column;
    }
    /**
     * Add macros function column.
     * @param queryMacrosType Macros type.
     * @param columnAlias Column alias.
     * @returns [MacrosFunctionColumn] Column instance.
     */
    addMacrosFunctionColumn(queryMacrosType, columnAlias) {
        const column = new ɵMacrosFunctionColumn(queryMacrosType);
        this._internalAddColumn(columnAlias, column);
        return column;
    }
    /**
     * Add date part function column.
     * @param columnPath Column path.
     * @param datePartType Date part type.
     * @param columnAlias Column alias.
     * @returns [DatePartFunctionColumn] Column instance.
     */
    addDatePartFunctionColumn(columnPath, datePartType, columnAlias) {
        const functionArgument = new ɵColumnExpression({ columnPath });
        const column = new ɵDatePartFunctionColumn(datePartType, functionArgument);
        this._internalAddColumn(columnAlias, column);
        return column;
    }
    /**
     * Add aggregation function column.
     * @param columnPath Column path.
     * @param aggregationType Aggregation type.
     * @param columnAlias Column alias.
     * @param aggregationEvalType Aggregation eval type.
     * @returns [AggregationFunctionColumn] Column instance.
     */
    addAggregationFunctionColumn(columnPath, aggregationType, columnAlias, aggregationEvalType = ɵAggregationEvalType.None) {
        const functionArgument = new ɵColumnExpression({ columnPath });
        const column = new ɵAggregationFunctionColumn(aggregationType, aggregationEvalType, functionArgument);
        this._internalAddColumn(columnAlias, column);
        return column;
    }
    /**
     * Add length function column.
     * @param columnPath Column path.
     * @param columnAlias Column alias.
     * @returns [LengthFunctionColumn] Column instance.
     */
    addLengthFunctionColumn(columnPath, columnAlias) {
        const functionArgument = new ɵColumnExpression({ columnPath });
        const column = new ɵLengthFunctionColumn(functionArgument);
        this._internalAddColumn(columnAlias, column);
        return column;
    }
    /**
     * Add window function column.
     * @param columnPath Column path.
     * @param aggregationType Aggregation type.
     * @param columnAlias Column alias.
     * @param aggregationEvalType Aggregation eval type.
     * @returns [WindowFunctionColumn] Column instance.
     */
    addWindowFunctionColumn(columnPath, aggregationType, columnAlias, aggregationEvalType = ɵAggregationEvalType.None) {
        const functionArgument = new ɵAggregationFunctionExpression({
            aggregationType,
            aggregationEvalType,
            functionArgument: new ɵColumnExpression({ columnPath }),
        });
        const column = new ɵWindowFunctionColumn(functionArgument);
        this._internalAddColumn(columnAlias, column);
        return column;
    }
}

/**
 * @public
 */
class ɵInsertQuery extends ɵBaseQuery {
    // endregion
    // region Constructors: Public
    constructor(rootSchemaName) {
        super(ɵQueryOperationType.Insert, rootSchemaName);
        // region Fields: Private
        this._columnValues = new Map();
    }
    // endregion
    // region Properties: Public
    get columnValues() {
        return {
            items: classToPlain(this._columnValues),
        };
    }
    // endregion
    // region Methods: Public
    addColumn(columnName, columnValue, dataValueType) {
        ɵValidationUtilities.checkArgumentEmpty('columnName', columnName);
        this._columnValues.set(columnName, new ɵParameterExpression({ value: columnValue, dataValueType }));
    }
}
__decorate([
    Expose(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], ɵInsertQuery.prototype, "columnValues", null);

/**
 * @public
 */
class ɵUpdateQuery extends ɵBaseFilterableQuery {
    // endregion
    // region Constructors: Public
    constructor(rootSchemaName) {
        super(ɵQueryOperationType.Update, rootSchemaName);
        // region Fields: Private
        this._columnValues = new Map();
        // endregion
        // region Fields: Public
        /**
         * Flag that indicates whether to force save data.
         */
        this.isForceUpdate = false;
    }
    // endregion
    // region Properties: Public
    get columnValues() {
        return {
            items: classToPlain(this._columnValues),
        };
    }
    // endregion
    // region Methods: Public
    addColumn(columnName, columnValue, dataValueType) {
        ɵValidationUtilities.checkArgumentEmpty('columnName', columnName);
        this._columnValues.set(columnName, new ɵParameterExpression({ value: columnValue, dataValueType }));
    }
}
__decorate([
    Expose(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], ɵUpdateQuery.prototype, "columnValues", null);

/**
 * @public
 */
class ɵSelectLocalizationQuery extends ɵEntitySchemaQuery {
}

/**
 * @public
 * @class ɵBaseRequest
 * @describe Base definition of request.
 * @template TEvent
 */
class ɵBaseRequest {
}

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * @public
 */
var ɵModelParameterType;
(function (ɵModelParameterType) {
    ɵModelParameterType["PrimaryColumnValue"] = "primaryColumnValue";
    ɵModelParameterType["Filter"] = "filter";
    ɵModelParameterType["PrimaryDisplayValueFilter"] = "primaryDisplayValueFilter";
    ɵModelParameterType["Empty"] = "empty";
    ɵModelParameterType["Never"] = "never";
})(ɵModelParameterType || (ɵModelParameterType = {}));

/**
 * Generated bundle index. Do not edit.
 */

export { LookupMode, ɵAggregationEvalType, ɵAggregationFunction, ɵAggregationFunctionColumn, ɵAggregationFunctionExpression, ɵAggregationSubQueryColumn, ɵAggregationSubQueryExpression, ɵAggregationType, ɵArgumentEmptyException, ɵArgumentFunctionExpression, ɵArgumentOutOfRangeException, ɵArithmeticExpression, ɵArithmeticOperation, ɵArithmeticQueryColumn, ɵBaseExpression, ɵBaseExpressionParser, ɵBaseFilter, ɵBaseFilterParser, ɵBaseFilterableQuery, ɵBaseQuery, ɵBaseQueryColumn, ɵBaseRequest, ɵBetweenFilter, ɵColumnExpression, ɵCompareFilter, ɵComparisonType, ɵDEFAULT_COLUMN_PLAIN_OBJ, ɵDEFAULT_FILTER_PLAIN_OBJ, ɵDataSchemaAttributeType, ɵDataSchemaAttributeUsageType, ɵDataSchemaType, ɵDataSourceScope, ɵDataValueType, ɵDatePartFunctionColumn, ɵDatePartFunctionExpression, ɵDatePartType, ɵDefaultValueSource, ɵDeleteQuery, ɵEMPTY_GUID, ɵEXPRESSION_TYPE_MOCK, ɵEntityQueryColumn, ɵEntitySchemaQuery, ɵExistsFilter, ɵExpressionMock, ɵExpressionParser, ɵExpressionResolver, ɵExpressionType, ɵFilterGroup, ɵFilterMock, ɵFilterParser, ɵFilterResolver, ɵFilterType, ɵFunctionExpression, ɵFunctionType, ɵInFilter, ɵInsertQuery, ɵIsNullFilter, ɵItemNotFoundException, ɵLengthFunctionColumn, ɵLengthFunctionExpression, ɵLogicalOperatorType, ɵMacrosFunctionColumn, ɵMacrosFunctionExpression, ɵModelParameterType, ɵNextHandlerAlreadySpecifiedException, ɵOrderDirection, ɵParameterExpression, ɵParameterQueryColumn, ɵQueryMacrosType, ɵQueryOperationType, ɵSelectLocalizationQuery, ɵSingleFilter, ɵSubQueryColumn, ɵSubQueryExpression, ɵUpdateQuery, ɵValidationUtilities, ɵWindowFunctionColumn, ɵWindowFunctionExpression, ɵencodeDate, ɵgenerateGuid, ɵgetColumnPlainObj, ɵgetFilterPlainObj, ɵisEmptyGuid, ɵisGuid, ɵparserMock, ɵtoLocalISOString };
//# sourceMappingURL=creatio-base.mjs.map
