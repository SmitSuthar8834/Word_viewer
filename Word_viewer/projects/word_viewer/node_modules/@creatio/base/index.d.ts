declare interface BaseDataSourceFunctionConfig {
    type: ɵFunctionStringType;
}

/* Excluded from this release type: LookupMode */

/**
 * @public
 * @description Represents abstract class.
 */
export declare type ɵAbstractType<T = any> = abstract new (...args: any[]) => T;

export declare type ɵAggregationEval = 'all' | 'distinct' | 'none';

export declare enum ɵAggregationEvalType {
    /** The scope of the aggregating function is not defined. */
    None = 0,
    /** Applies to all elements. */
    All = 1,
    /** Applies to unique values. */
    Distinct = 2
}

export declare enum ɵAggregationFunction {
    /** Aggregation function type not defined. */
    None = "",
    /** Aggregation function type not defined. */
    Count = "Count",
    /** Sum of values of all elements. */
    Sum = "Sum",
    /** Average value for all elements. */
    Avg = "Avg",
    /** The minimum value among all elements. */
    Min = "Min",
    /** The maximum value among all elements. */
    Max = "Max",
    /** Top one record from collection. */
    TopOne = "TopOne"
}

export declare class ɵAggregationFunctionColumn extends ɵBaseQueryColumn<ɵAggregationFunctionExpression> {
    constructor(aggregationType: ɵAggregationType, aggregationEvalType: ɵAggregationEvalType, functionArgument: ɵBaseExpression);
}

export declare class ɵAggregationFunctionExpression extends ɵArgumentFunctionExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly functionType: ɵFunctionType;
    readonly aggregationType: ɵAggregationType;
    readonly aggregationEvalType: ɵAggregationEvalType;
    constructor(config: ɵAggregationFunctionExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser?: TExpressionParser): ɵAggregationFunctionExpression;
    clone(): ɵAggregationFunctionExpression;
}

export declare type ɵAggregationFunctionExpressionConfig = ɵArgumentFunctionExpressionConfig<ɵAggregationFunctionExpression> & Pick<ɵAggregationFunctionExpression, 'aggregationType' | 'aggregationEvalType'>;

export declare class ɵAggregationSubQueryColumn extends ɵBaseQueryColumn<ɵAggregationSubQueryExpression> {
    constructor(columnPath: string, aggregationType: ɵAggregationType, subFilters?: ɵFilterGroup, subOrderDirection?: number, subOrderColumn?: string);
}

export declare class ɵAggregationSubQueryExpression extends ɵSubQueryExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly aggregationType: ɵAggregationType;
    readonly functionType?: ɵFunctionType;
    constructor(config: ɵAggregationSubQueryExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser>(dto: ɵJsonObject, filterParser: TFilterParser): ɵAggregationSubQueryExpression;
    clone(): ɵAggregationSubQueryExpression;
}

export declare type ɵAggregationSubQueryExpressionConfig = ɵSubQueryExpressionConfig & Pick<ɵAggregationSubQueryExpression, 'aggregationType'> & Pick<ɵAggregationSubQueryExpression, 'functionType'>;

export declare enum ɵAggregationType {
    /** Aggregation function type not defined. */
    None = 0,
    /** Aggregation function type not defined. */
    Count = 1,
    /** Sum of values of all elements. */
    Sum = 2,
    /** Average value for all elements. */
    Avg = 3,
    /** The minimum value among all elements. */
    Min = 4,
    /** The maximum value among all elements. */
    Max = 5,
    /** Top one record from collection. */
    TopOne = 6
}

export declare class ɵArgumentEmptyException extends Error {
    constructor(argumentName: string);
}

export declare abstract class ɵArgumentFunctionExpression extends ɵFunctionExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly functionArgument: ɵBaseExpression;
    protected constructor(config: ɵArgumentFunctionExpressionConfig<ɵArgumentFunctionExpression>);
    abstract clone(): ɵArgumentFunctionExpression;
    toJson(): ɵJsonObject;
}

export declare type ɵArgumentFunctionExpressionConfig<TExpression extends ɵArgumentFunctionExpression> = ɵFunctionExpressionConfig<TExpression> & Pick<ɵArgumentFunctionExpression, 'functionArgument'>;

export declare class ɵArgumentOutOfRangeException extends Error {
    constructor(argumentName: string);
}

export declare class ɵArithmeticExpression extends ɵBaseExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly expressionType: ɵExpressionType;
    readonly arithmeticOperation: ɵArithmeticOperation;
    readonly leftArithmeticOperand: ɵBaseExpression;
    readonly rightArithmeticOperand: ɵBaseExpression;
    constructor(config: ɵArithmeticExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser?: TExpressionParser): ɵArithmeticExpression;
    clone(): ɵArithmeticExpression;
}

export declare type ɵArithmeticExpressionConfig = ɵExpressionConfig<ɵArithmeticExpression> & Pick<ɵArithmeticExpression, 'arithmeticOperation' | 'leftArithmeticOperand' | 'rightArithmeticOperand'>;

export declare enum ɵArithmeticOperation {
    /** Addition. */
    Addition = 0,
    /** Subtraction. */
    Subtraction = 1,
    /** Multiplication. */
    Multiplication = 2,
    /** Division. */
    Division = 3
}

export declare class ɵArithmeticQueryColumn extends ɵBaseQueryColumn<ɵArithmeticExpression> {
    constructor(arithmeticOperation: ɵArithmeticOperation, leftArithmeticOperand: ɵBaseExpression, rightArithmeticOperand: ɵBaseExpression);
}

/**
 * @public
 */
declare interface ɵBaseDataSchemaAttributeFunctionConfig {
    type: ɵFunctionStringType;
}

/**
 * @public
 */
export declare interface ɵBaseDataSourceParameter {
    type: ɵModelParameterType;
    value: any;
    relationsConfigs?: ɵDataSourceParameterRelationConfig[];
}

export declare abstract class ɵBaseExpression implements ɵSerializable {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly isBlock: boolean;
    static [Symbol.hasInstance](instance: ɵBaseExpression): boolean;
    abstract readonly expressionType: ɵExpressionType;
    protected constructor(config: ɵExpressionConfig<ɵBaseExpression>);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser?: TExpressionParser): ɵBaseExpression;
    protected serializeItem(item: ɵSerializable): ɵJsonObject;
    abstract clone(): ɵBaseExpression;
    /**
     * Converts instance to json object.
     * @public
     */
    toJson(): ɵJsonObject;
}

/**
 * Expression parser interface
 * @public
 */
export declare class ɵBaseExpressionParser {
    static fromJson(dto: ɵJsonObject, filterParser: typeof ɵBaseFilterParser): unknown;
}

export declare abstract class ɵBaseFilter implements ɵSerializable {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly filterType: ɵFilterType;
    isEnabled: boolean;
    trimDateTimeParameterToDate: boolean;
    static [Symbol.hasInstance](instance: ɵBaseFilter): boolean;
    protected constructor(filterType: ɵFilterType);
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser: TExpressionParser): ɵBaseFilter;
    protected serializeItem(item: ɵSerializable): ɵJsonObject;
    abstract clone(): ɵBaseFilter;
    /**
     * Converts instance to json object.
     * @public
     */
    toJson(): ɵJsonObject;
}

/**
 * @public
 */
export declare abstract class ɵBaseFilterableQuery extends ɵBaseQuery {
    readonly filters: ɵFilterGroup;
    protected constructor(operationType: ɵQueryOperationType, rootSchemaName: string);
    clearFilters(): void;
    getMetadata(): Record<string, unknown>;
}

/**
 * Filter parser interface
 * @public
 */
export declare class ɵBaseFilterParser {
    static fromJson(dto: ɵJsonObject): unknown;
}

export declare interface ɵBaseModel<TLoadOptions extends ɵDataSourceLoadOptions> {
    getSchema(): Promise<ɵDataSchema>;
    load(config?: {
        attributes?: string[] | ɵDataSourceAttribute[];
        parameters?: ɵDataSourceParameters;
        loadOptions?: TLoadOptions;
    }): Promise<ɵJsonArray>;
    insert(dto: ɵJsonObject): Promise<ɵDataSourceSaveResult>;
    update(dto: ɵJsonObject, parameters: ɵDataSourceParameters): Promise<ɵDataSourceSaveResult>;
    copy(primaryColumnValue: string, data: ɵJsonObject): Promise<ɵJsonObject>;
    create(data: ɵJsonObject): Promise<ɵJsonObject>;
    delete(parameters: ɵDataSourceParameters): Promise<ɵDataSourceSaveResult>;
    canSave(params: ɵDataSourceCanExecuteOperationPayload): Promise<ɵDataSourceCanExecuteOperationResult>;
    canDelete(params: ɵDataSourceCanExecuteOperationPayload): Promise<ɵDataSourceCanExecuteOperationResult>;
}

/**
 * @public
 */
export declare abstract class ɵBaseQuery implements ɵMetadataProvider<Record<string, unknown>> {
    readonly operationType: ɵQueryOperationType;
    readonly rootSchemaName: string;
    protected constructor(operationType: ɵQueryOperationType, rootSchemaName: string);
    getMetadata(): Record<string, unknown>;
}

export declare abstract class ɵBaseQueryColumn<TExpression extends ɵBaseExpression = ɵBaseExpression> {
    orderDirection: ɵOrderDirection;
    orderPosition: number;
    isVisible: boolean;
    caption?: string;
    readonly expression: TExpression;
    protected constructor(expression: TExpression);
    /**
     * Adds ordering options.
     * @param orderDirection Direction.
     * @param orderPosition Position.
     * @returns Self.
     */
    withOrdering(orderDirection: ɵOrderDirection, orderPosition: number): this;
    /**
     * Adds options.
     * @param options Options.
     * @returns Self.
     */
    withOptions(options: {
        isVisible?: boolean;
    }): this;
    /**
     * Adds caption.
     * @param caption Caption.
     * @returns Self.
     */
    withCaption(caption: string): this;
}

/**
 * @public
 * @class ɵBaseRequest
 * @describe Base definition of request.
 * @template TEvent
 */
export declare class ɵBaseRequest<TEvent = unknown> {
    /**
     * The type of request.
     * @example
     * 'crt.RequestType'
     */
    readonly type: string;
    /**
     * @deprecated use event binding expression instead.
     *
     * The target event from which this request originated.
     */
    readonly $initialEvent?: TEvent;
    /**
     * The context in which the requests were triggered.
     */
    readonly $context: ɵViewModelContext;
    /**
     * The scope of the request.
     */
    scopes?: string[];
}

/**
 * @public
 * @description Service to working with system settings.
 */
export declare interface ɵBaseSysSettingsService {
    /**
     * Returns value of the specified system setting.
     * @param sysSettingCode Code of system setting.
     * @param defaultValue Default value to be used if system setting has no value.
     */
    getValueByCode<T>(sysSettingCode: string, defaultValue?: T): Promise<T>;
}

export declare class ɵBetweenFilter extends ɵSingleFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly rightLessExpression: ɵBaseExpression;
    readonly rightGreaterExpression: ɵBaseExpression;
    constructor(leftExpression: ɵBaseExpression, rightLessExpression: ɵBaseExpression, rightGreaterExpression: ɵBaseExpression);
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser: TExpressionParser): ɵBetweenFilter;
    clone(): ɵBetweenFilter;
    toJson(): ɵJsonObject;
}

export declare class ɵColumnExpression extends ɵBaseExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly expressionType: ɵExpressionType;
    columnPath: string;
    constructor(config: ɵColumnExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto: ɵJsonObject): ɵColumnExpression;
    clone(): ɵColumnExpression;
}

export declare type ɵColumnExpressionConfig = ɵExpressionConfig<ɵColumnExpression> & Pick<ɵColumnExpression, 'columnPath'>;

export declare class ɵCompareFilter extends ɵSingleFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly rightExpression: ɵBaseExpression;
    constructor(comparisonType: ɵComparisonType, leftExpression: ɵBaseExpression, rightExpression: ɵBaseExpression);
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser: TExpressionParser): ɵCompareFilter;
    clone(): ɵCompareFilter;
    toJson(): ɵJsonObject;
}

export declare enum ɵComparisonType {
    Between = 0,
    Contain = 11,
    End_with = 13,
    Equal = 3,
    Exists = 15,
    Greater = 7,
    Greater_or_equal = 8,
    Is_not_null = 2,
    Is_null = 1,
    Less = 5,
    Less_or_equal = 6,
    Not_contain = 12,
    Not_end_with = 14,
    Not_equal = 4,
    Not_exists = 16,
    Not_start_with = 10,
    Start_with = 9
}

export declare interface ɵConditionalValueItem {
    expressionType: ɵExpressionType;
    parameter: {
        dataValueType: ɵDataValueType;
        value: string;
    };
}

/**
 * @public
 * @description DataSchema describes the structure of the data-object that the application works with.
 * @property {string} name - name of DataSchema.
 * @property {string} type - type of DataSchema.
 * @property {string} primaryAttributeName - name of primary attribute.
 * @property {string} primaryDisplayAttributeName - name of primary display attribute.
 * @property {string} hierarchyAttributeName - name of the column that binds the parent record,
 * for hierarchical entities.
 * @property {string} primaryColorAttributeName - name of the column that defines color.
 */
export declare interface ɵDataSchema {
    name: string;
    /**
     * @description {@link ɵDataSchemaType} type of DataSchema.
     * @public
     */
    type?: ɵDataSchemaType;
    /**
     * @description {@link ɵLocalizableString} localizable caption of DataSchema.
     */
    caption: ɵLocalizableString;
    /**
     * @description {@link ɵDataSchemaAttribute[]} - array of attributes of DataSchema.
     */
    attributes: ɵDataSchemaAttribute[];
    primaryAttributeName?: string;
    primaryDisplayAttributeName?: string;
    hierarchyAttributeName?: string;
    primaryColorAttributeName?: string;
    /**
     * @public
     */
    dataSourceConfig: ɵDataSourceConfig;
}

/**
 * @public
 * @description DataSchemaAttribute describes the structure of the single attribute
 * of data-object that the application works with.
 * @property {string} name - name of DataSchemaAttribute.
 * @property {string} caption - caption of DataSchemaAttribute.
 * @property {string} isValueCloneable - copy this DataSchemaAttribute value when copying object.
 * @property {string} referenceSchemaName - name of refernce DataSchema.
 * @property {boolean} isMasked - is mask used for DataSchemaAttribute.
 * @property {boolean} isFormatValidated - is format validated for DataSchemaAttribute.
 * @property {boolean} isSensitiveData - is data of DataSchemaAttribute sensetive.
 * @property {boolean} isRequired - flag to determine DataSchemaAttribute required or not.
 */
export declare interface ɵDataSchemaAttribute {
    name: string;
    caption: string;
    /**
     * @public
     */
    path: string;
    /**
     * @description {@link ɵDataValueType} - value type of DataSchemaAttribute.
     */
    dataValueType: ɵDataValueType;
    /**
     * @public
     */
    validators: ɵDataSchemaValidatorConfig;
    /**
     * @public
     */
    defaultValue: Promise<ɵJsonData> | unknown;
    /**
     * @public
     */
    defaultValueSchema: ɵDefaultValueSchema;
    isValueCloneable: boolean;
    /**
     * @public
     */
    attributeType: ɵDataSchemaAttributeType;
    referenceSchemaName?: string;
    /**
     * @public
     */
    functionConfig?: ɵDataSchemaAttributeFunctionConfig;
    /**
     * @public
     */
    aggregationConfig?: ɵDataSchemaAttributeAggregationConfig;
    isMasked: boolean;
    isFormatValidated: boolean;
    isSensitiveData: boolean;
    /**
     * @public
     */
    usageType: ɵDataSchemaAttributeUsageType;
    /**
     * @description flag to determine DataSchemaAttribute required or not.
     */
    isRequired: boolean;
    /* Excluded from this release type: lookupMode */
}

/**
 * @public
 */
export declare interface ɵDataSchemaAttributeAggregationConfig {
    aggregationFunction?: ɵAggregationFunction;
    filter?: ɵFilterGroup;
    sortByColumn?: string;
    sortByDirection?: ɵOrderDirection;
}

/**
 * @public
 */
export declare interface ɵDataSchemaAttributeAggregationFunctionConfig extends ɵBaseDataSchemaAttributeFunctionConfig {
    type: 'aggregation';
    aggregation: ɵAggregationFunction;
    aggregationEval: ɵAggregationEval;
}

/**
 * @public
 */
export declare interface ɵDataSchemaAttributeDatePartFunctionConfig extends ɵBaseDataSchemaAttributeFunctionConfig {
    type: 'datePart';
    datePart: ɵDatePart;
}

/**
 * @public
 */
export declare type ɵDataSchemaAttributeFunctionConfig = ɵDataSchemaAttributeAggregationFunctionConfig | ɵDataSchemaAttributeDatePartFunctionConfig;

/**
 * @public
 */
export declare enum ɵDataSchemaAttributeType {
    OwnAttribute = "Own",
    ForwardReferenceAttribute = "ForwardReference",
    BackReferenceAttribute = "BackReference",
    AggregationAttribute = "Aggregation",
    FunctionAttribute = "Function"
}

/**
 * @public
 */
export declare enum ɵDataSchemaAttributeUsageType {
    General = 0,
    Advanced = 1,
    None = 2
}

/**
 * @public
 */
export declare interface ɵDataSchemaAttributeValidatorConfig {
    type: string;
    disabled?: boolean;
    params?: {
        [key: string]: unknown;
    };
}

/**
 * Type of DataSchema. In combination with the name is used for unique identification of {@link DataSchema}.
 */
export declare enum ɵDataSchemaType {
    Entity = "Entity",
    ClientUnit = "ClientUnit"
}

/**
 * @public
 */
export declare interface ɵDataSchemaValidatorConfig {
    [name: string]: ɵDataSchemaAttributeValidatorConfig;
}

export declare interface ɵDataSourceAggregationConfig {
    aggregationFunction?: ɵAggregationFunction;
    filter?: ɵFilterGroup;
    sortByColumn?: string;
    sortByDirection?: ɵOrderDirection;
}

export declare interface ɵDataSourceAggregationFunctionConfig extends BaseDataSourceFunctionConfig {
    type: 'aggregation';
    aggregation: ɵAggregationFunction;
    aggregationEval: ɵAggregationEval;
}

/**
 * @public
 */
export declare interface ɵDataSourceAttribute {
    type?: ɵDataSourceAttributeType;
    name: string;
    path: string;
    caption?: string;
    dataValueType?: ɵDataValueType;
    functionConfig?: ɵDataSourceFunctionConfig;
    aggregationConfig?: ɵDataSourceAggregationConfig;
}

/**
 * @public
 */
export declare type ɵDataSourceAttributeType = 'default' | 'aggregation' | 'function';

export declare interface ɵDataSourceCanExecuteOperationPayload {
    primaryColumnValue?: string;
}

export declare interface ɵDataSourceCanExecuteOperationResult {
    result: boolean;
    message?: string;
}

/**
 * @public
 */
export declare interface ɵDataSourceConfig {
    type: string;
    config?: ɵDataSourceInstanceConfig;
    /**
     * @deprecated Use scope instead.
     */
    hiddenInPageDesigner?: boolean;
    scope?: ɵDataSourceScope;
    disableSync?: boolean;
}

export declare interface ɵDataSourceDatePartFunctionConfig extends BaseDataSourceFunctionConfig {
    type: 'datePart';
    datePart: ɵDatePart;
}

export declare type ɵDataSourceFunctionConfig = ɵDataSourceAggregationFunctionConfig | ɵDataSourceDatePartFunctionConfig;

/**
 * @public
 */
export declare interface ɵDataSourceInsertResult extends ɵDataSourceSaveResult {
    primaryAttributes: Array<Record<string, unknown>>;
}

/**
 * @public
 */
export declare interface ɵDataSourceInstanceConfig {
    [key: string]: any;
}

/**
 * @public
 */
export declare interface ɵDataSourceLoadOptions {
    pagingConfig?: ɵDataSourcePagingConfig;
    sortingConfig?: ɵDataSourceSortingConfig;
}

/**
 * @public
 */
export declare interface ɵDataSourcePagingConfig {
    rowsOffset: number;
    rowCount: number;
}

/**
 * @public
 */
export declare type ɵDataSourceParameter = ɵBaseDataSourceParameter | ɵPrimaryDisplayFilterDataSourceParameter;

/**
 * @public
 */
export declare interface ɵDataSourceParameterRelationConfig {
    dataSchemaName: string;
    attributePath: string;
    relationPath: string;
    /**
     * @public
     */
    useAttributeValue?: boolean;
    /**
     * @public
     */
    value?: unknown;
}

/**
 * @public
 */
export declare type ɵDataSourceParameters = ɵDataSourceParameter[];

/**
 * @public
 * @description Data source save response
 * @property {boolean} success - indicates whether operation was success.
 * @property {number} rowsAffected - count of affected rows.
 * @property {string} errorInfo - error message.
 */
export declare interface ɵDataSourceSaveResult {
    /**
     * @description Indicates whether operation was success.
     */
    success: boolean;
    /**
     * @description Count of affected rows.
     */
    rowsAffected: number;
    /**
     * @description Error message.
     */
    errorInfo?: string;
}

/**
 * @public
 */
export declare enum ɵDataSourceScope {
    ViewElement = "viewElement",
    Page = "page"
}

/**
 * @public
 */
export declare interface ɵDataSourceSortingConfig {
    columns: ɵSortColumnOptions[];
}

export declare enum ɵDataValueType {
    Guid = 0,
    Text = 1,
    Integer = 4,
    Float = 5,
    Money = 6,
    DateTime = 7,
    Date = 8,
    Time = 9,
    Lookup = 10,
    Enum = 11,
    Boolean = 12,
    Blob = 13,
    Image = 14,
    CUSTOM_OBJECT = 15,
    IMAGELOOKUP = 16,
    COLLECTION = 17,
    Color = 18,
    LOCALIZABLE_STRING = 19,
    ENTITY = 20,
    ENTITY_COLLECTION = 21,
    ENTITY_COLUMN_MAPPING_COLLECTION = 22,
    HASH_TEXT = 23,
    SECURE_TEXT = 24,
    FILE = 25,
    MAPPING = 26,
    SHORT_TEXT = 27,
    MEDIUM_TEXT = 28,
    MAXSIZE_TEXT = 29,
    LONG_TEXT = 30,
    FLOAT1 = 31,
    FLOAT2 = 32,
    FLOAT3 = 33,
    FLOAT4 = 34,
    LOCALIZABLE_PARAMETER_VALUES_LIST = 35,
    METADATA_TEXT = 36,
    STAGE_INDICATOR = 37,
    OBJECT_LIST = 38,
    COMPOSITE_OBJECT_LIST = 39,
    FLOAT8 = 40,
    FILE_LOCATOR = 41,
    PHONE_TEXT = 42,
    RICH_TEXT = 43,
    WEB_TEXT = 44,
    EMAIL_TEXT = 45
}

/**
 * @public
 * @description type of date part
 */
export declare type ɵDatePart = 'minute' | 'hour' | 'day' | 'weekday' | 'week' | 'month' | 'year' | 'none';

export declare class ɵDatePartFunctionColumn extends ɵBaseQueryColumn<ɵDatePartFunctionExpression> {
    constructor(datePartType: ɵDatePartType, functionArgument: ɵBaseExpression);
    get datePartType(): ɵDatePartType;
}

export declare class ɵDatePartFunctionExpression extends ɵArgumentFunctionExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly functionType: ɵFunctionType;
    readonly datePartType: ɵDatePartType;
    constructor(config: ɵDatePartFunctionExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser?: TExpressionParser): ɵDatePartFunctionExpression;
    clone(): ɵDatePartFunctionExpression;
}

export declare type ɵDatePartFunctionExpressionConfig = ɵArgumentFunctionExpressionConfig<ɵDatePartFunctionExpression> & Pick<ɵDatePartFunctionExpression, 'datePartType'>;

export declare enum ɵDatePartType {
    /** Empty value. */
    None = 0,
    /** Day. */
    Day = 1,
    /** Week. */
    Week = 2,
    /** Month. */
    Month = 3,
    /** Year. */
    Year = 4,
    /** Day of the week. */
    WeekDay = 5,
    /** Hour. */
    Hour = 6,
    /** Minute. */
    HourMinute = 7
}

export declare const ɵDEFAULT_COLUMN_PLAIN_OBJ: object;

export declare const ɵDEFAULT_FILTER_PLAIN_OBJ: object;

/**
 * @public
 */
export declare interface ɵDefaultValueSchema {
    valueSourceType: ɵDefaultValueSource;
    value: any;
    valueSource?: string;
    sequenceNumberOfChars?: number;
    sequencePrefix?: string;
}

/**
 * @public
 */
export declare enum ɵDefaultValueSource {
    None = 0,
    Const = 1,
    Settings = 2,
    SystemValue = 3,
    Sequence = 4
}

/**
 * @public
 */
export declare class ɵDeleteQuery extends ɵBaseFilterableQuery {
    constructor(rootSchemaName: string);
}

/**
 * Empty Guid constant.
 * @public
 */
export declare const ɵEMPTY_GUID = "00000000-0000-0000-0000-000000000000";

/**
 * @public
 * Returns encoded date in string value.
 * @param date Date value.
 */
export declare function ɵencodeDate(date: Date): string;

export declare type ɵEntityColumnValue = boolean | number | string | ɵGuid | Date | ɵLookupValue | null;

export declare class ɵEntityQueryColumn extends ɵBaseQueryColumn<ɵColumnExpression> {
    constructor(columnPath: string);
}

/**
 * @public
 */
export declare class ɵEntitySchemaQuery extends ɵBaseFilterableQuery {
    private _columns;
    isDistinct: boolean;
    /**
     * Number of rows to select.
     */
    rowCount: number;
    /**
     * Rows count to skip.
     */
    rowsOffset: number;
    /**
     * Query conditional values
     */
    conditionalValues?: null | {
        items: unknown;
    };
    useLocalization: boolean;
    useRecordDeactivation: boolean;
    constructor(rootSchemaName: string);
    private _internalAddColumn;
    private _getIsPageable;
    /**
     * Returns column instance by column alias.
     * @param columnAlias Column alias.
     * @returns [BaseQueryColumn] Column instance.
     */
    getColumn(columnAlias: string): ɵBaseQueryColumn;
    /**
     * Returns column instance by column alias if not found returns null.
     */
    findColumn(columnAlias: string): ɵBaseQueryColumn;
    /**
     * @inheritDoc
     */
    getMetadata(): Record<string, unknown>;
    /**
     * Add column.
     * @param column Column path.
     * @param columnAlias Column alias.
     * @returns [BaseQueryColumn] Column instance.
     */
    addColumn(column: ɵBaseQueryColumn, columnAlias: string): ɵBaseQueryColumn;
    /**
     * Add column by column path.
     * @param columnPath Column path.
     * @param columnAlias Column alias.
     * @returns [EntityQueryColumn] Column instance.
     */
    addSchemaColumn(columnPath: string, columnAlias?: string): ɵEntityQueryColumn;
    /**
     * Add aggregation sub query column.
     * @param columnPath Column path.
     * @param aggregationType Aggregation type.
     * @param subFilters Sub query filters.
     * @param columnAlias Column alias.
     * @returns [AggregationSubQueryColumn] Column instance.
     */
    addAggregationSubQueryColumn(columnPath: string, aggregationType: ɵAggregationType, aggregationConfig: ɵDataSourceAggregationConfig, columnAlias?: string): ɵAggregationSubQueryColumn;
    /**
     * Add parameter column.
     * @param value Parameter value.
     * @param dataValueType Parameter data value type.
     * @param columnAlias Column alias.
     * @returns [ParameterQueryColumn] Column instance.
     */
    addParameterColumn(value: ɵEntityColumnValue, dataValueType: ɵDataValueType, columnAlias: string): ɵParameterQueryColumn;
    /**
     * Add arithmetic column.
     * @param arithmeticOperation Arithmetic operation.
     * @param leftArithmeticOperand Left arithmetic operand expression.
     * @param rightArithmeticOperand Right arithmetic operand expression.
     * @param columnAlias Column alias.
     * @returns [ArithmeticQueryColumn] Column instance.
     */
    addArithmeticColumn(arithmeticOperation: ɵArithmeticOperation, leftArithmeticOperand: ɵBaseExpression, rightArithmeticOperand: ɵBaseExpression, columnAlias: string): ɵArithmeticQueryColumn;
    /**
     * Add macros function column.
     * @param queryMacrosType Macros type.
     * @param columnAlias Column alias.
     * @returns [MacrosFunctionColumn] Column instance.
     */
    addMacrosFunctionColumn(queryMacrosType: ɵQueryMacrosType, columnAlias: string): ɵMacrosFunctionColumn;
    /**
     * Add date part function column.
     * @param columnPath Column path.
     * @param datePartType Date part type.
     * @param columnAlias Column alias.
     * @returns [DatePartFunctionColumn] Column instance.
     */
    addDatePartFunctionColumn(columnPath: string, datePartType: ɵDatePartType, columnAlias: string): ɵDatePartFunctionColumn;
    /**
     * Add aggregation function column.
     * @param columnPath Column path.
     * @param aggregationType Aggregation type.
     * @param columnAlias Column alias.
     * @param aggregationEvalType Aggregation eval type.
     * @returns [AggregationFunctionColumn] Column instance.
     */
    addAggregationFunctionColumn(columnPath: string, aggregationType: ɵAggregationType, columnAlias: string, aggregationEvalType?: ɵAggregationEvalType): ɵAggregationFunctionColumn;
    /**
     * Add length function column.
     * @param columnPath Column path.
     * @param columnAlias Column alias.
     * @returns [LengthFunctionColumn] Column instance.
     */
    addLengthFunctionColumn(columnPath: string, columnAlias: string): ɵLengthFunctionColumn;
    /**
     * Add window function column.
     * @param columnPath Column path.
     * @param aggregationType Aggregation type.
     * @param columnAlias Column alias.
     * @param aggregationEvalType Aggregation eval type.
     * @returns [WindowFunctionColumn] Column instance.
     */
    addWindowFunctionColumn(columnPath: string, aggregationType: ɵAggregationType, columnAlias: string, aggregationEvalType?: ɵAggregationEvalType): ɵWindowFunctionColumn;
}

export declare class ɵExistsFilter extends ɵSingleFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly subFilters?: ɵFilterGroup;
    readonly isAggregative: boolean;
    constructor(leftExpression: ɵBaseExpression, subFilters?: ɵFilterGroup, comparisonType?: ɵComparisonType, isAggregative?: boolean);
    /**
     * Parses filter from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser: TExpressionParser): ɵExistsFilter;
    clone(): ɵExistsFilter;
    toJson(): ɵJsonObject;
}

export declare const ɵEXPRESSION_TYPE_MOCK: ɵExpressionType;

export declare type ɵExpressionConfig<TExpression extends ɵBaseExpression> = Partial<Omit<TExpression, 'expressionType'>>;

export declare class ɵExpressionMock extends ɵBaseExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly expressionType: ɵExpressionType;
    constructor(config?: ɵExpressionConfig<ɵExpressionMock>);
    get plainObject(): object;
    clone(): ɵExpressionMock;
}

/**
 * Expression parser.
 * @public
 */
export declare class ɵExpressionParser extends ɵBaseExpressionParser {
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto: ɵJsonObject, filterParser: typeof ɵBaseFilterParser): ɵBaseExpression;
}

/**
 * Expression resolver.
 * @public
 */
export declare class ɵExpressionResolver {
    static resolve(expressionType: ɵExpressionType, dto: ɵJsonObject): typeof ɵBaseExpression;
}

export declare enum ɵExpressionType {
    SchemaColumn = 0,
    Function = 1,
    Parameter = 2,
    SubQuery = 3,
    ArithmeticOperation = 4
}

export declare class ɵFilterGroup extends ɵBaseFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    filters: Map<string, ɵBaseFilter>;
    get items(): {
        [key: string]: ɵBaseFilter;
    };
    logicalOperation: ɵLogicalOperatorType;
    constructor(logicalOperation?: ɵLogicalOperatorType);
    /**
     * Parses filter group from json.
     * @public
     */
    static fromJson<T extends typeof ɵBaseFilterParser>(dto: ɵJsonObject, filterParser: T): ɵFilterGroup;
    /**
     * Returns filter item by index.
     * @param index Item index.
     * @returns Filter.
     */
    getItemByIndex(index: number): ɵBaseFilter;
    /**
     * Creates and adds compare filter by value.
     * @param comparisonType Comparison type.
     * @param columnPath Column path.
     * @param parameterValue Parameter value.
     * @param filterKey Filter key.
     */
    addSchemaColumnFilterWithParameter(comparisonType: ɵComparisonType, columnPath: string, parameterValue: ɵEntityColumnValue, filterKey?: string): void;
    /**
     * Creates and adds in filter by values.
     * @param comparisonType Comparison type.
     * @param columnPath Column path.
     * @param parameterValues Parameter values.
     * @param filterKey Filter key.
     */
    addSchemaColumnInFilterWithParameters(comparisonType: ɵComparisonType, columnPath: string, parameterValues: ɵEntityColumnValue[], filterKey?: string): void;
    addSchemaColumnIsNullFilter(columnPath: string, filterKey?: string): void;
    /**
     * Creates and adds not null filter.
     * @param columnPath Column path.
     * @param filterKey Filter key.
     */
    addSchemaColumnIsNotNullFilter(columnPath: string, filterKey?: string): void;
    /**
     * Creates and adds filter between less value and greater value.
     * @param columnPath Column path.
     * @param lessParamValue Less parameter value.
     * @param greaterParamValue Greater parameter value.
     * @param filterKey Filter key.
     */
    addSchemaColumnBetweenFilterWithParameters(columnPath: string, lessParamValue: Date | number, greaterParamValue: Date | number, filterKey?: string): void;
    addExistsFilter(columnPath: string, subFilters?: ɵFilterGroup, filterKey?: string): void;
    addNotExistsFilter(columnPath: string, subFilters?: ɵFilterGroup, filterKey?: string): void;
    add(filter: ɵBaseFilter, filterKey?: string): void;
    clone(): ɵFilterGroup;
}

export declare class ɵFilterMock extends ɵBaseFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    constructor(filterType?: ɵFilterType);
    get plainObject(): object;
    clone(): ɵFilterMock;
}

/**
 * Filter parser.
 * @public
 */
export declare class ɵFilterParser extends ɵBaseFilterParser {
    static fromJson(dto: ɵJsonObject): ɵBaseFilter;
}

/**
 * Filter resolver.
 * @public
 */
export declare class ɵFilterResolver {
    static resolve(filterType: ɵFilterType): typeof ɵBaseFilter;
}

export declare enum ɵFilterType {
    None = 0,
    Compare = 1,
    IsNull = 2,
    Between = 3,
    In = 4,
    Exists = 5,
    FilterGroup = 6
}

export declare abstract class ɵFunctionExpression extends ɵBaseExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly expressionType: ɵExpressionType;
    abstract readonly functionType: ɵFunctionType;
    protected constructor(config: ɵFunctionExpressionConfig<ɵFunctionExpression>);
    abstract clone(): ɵFunctionExpression;
}

export declare type ɵFunctionExpressionConfig<TExpression extends ɵFunctionExpression> = Omit<ɵExpressionConfig<TExpression>, 'functionType'>;

/**
 * @public
 * @description type of function
 */
export declare type ɵFunctionStringType = 'aggregation' | 'datePart' | 'none';

export declare enum ɵFunctionType {
    None = 0,
    /** Substitution by macro. */
    Macros = 1,
    /** Aggregating function. */
    Aggregation = 2,
    /** Date fragment. */
    DatePart = 3,
    /** The size of the value in bytes, used for binary data. */
    Length = 4,
    /** Window query function */
    Window = 5,
    /** Date add. */
    DateAdd = 6,
    /** Date diff. */
    DateDiff = 7
}

/**
 * Generates new Guid.
 * @public
 */
export declare function ɵgenerateGuid(): ɵGuid;

export declare function ɵgetColumnPlainObj(expressionPlainObj?: object): object;

export declare function ɵgetFilterPlainObj(filterPlainObj?: object): object;

/**
 * Type for Guid value.
 * @public
 */
export declare type ɵGuid = string;

export declare class ɵInFilter extends ɵSingleFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly rightExpressions: ɵBaseExpression[];
    constructor(comparisonType: ɵComparisonType, leftExpression: ɵBaseExpression, rightExpressions: ɵBaseExpression[]);
    /**
     * Parses in filter from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser: TExpressionParser): ɵInFilter;
    clone(): ɵInFilter;
    toJson(): ɵJsonObject;
}

/**
 * @public
 */
export declare class ɵInsertQuery extends ɵBaseQuery {
    private _columnValues;
    constructor(rootSchemaName: string);
    get columnValues(): {
        items: {
            [key: string]: ɵParameterExpression;
        };
    };
    addColumn(columnName: string, columnValue: ɵEntityColumnValue, dataValueType: ɵDataValueType): void;
}

/**
 * Checks if Guid is empty value or equal to EMPTY_GUID.
 * @param guid Guid for check.
 * @public
 */
export declare function ɵisEmptyGuid(guid: ɵGuid | undefined): boolean;

/**
 * Checks if value is Guid.
 * @param value Value for check.
 * @public
 */
export declare function ɵisGuid(value: unknown): boolean;

export declare class ɵIsNullFilter extends ɵSingleFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    constructor(comparisonType: ɵComparisonType, leftExpression: ɵBaseExpression);
    get isNull(): boolean;
    /**
     * Parses isNull filter from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser: TExpressionParser): ɵIsNullFilter;
    clone(): ɵIsNullFilter;
}

export declare class ɵItemNotFoundException extends Error {
    constructor(key: string);
}

/**
 * @public
 */
export declare type ɵJsonArray = Array<ɵJsonData>;

/**
 * @public
 */
export declare type ɵJsonData = string | number | boolean | null | undefined | ɵJsonObject | ɵJsonArray;

/**
 * @public
 */
export declare interface ɵJsonObject {
    [key: string]: ɵJsonData;
}

export declare class ɵLengthFunctionColumn extends ɵBaseQueryColumn<ɵLengthFunctionExpression> {
    constructor(functionArgument: ɵColumnExpression);
}

export declare class ɵLengthFunctionExpression extends ɵArgumentFunctionExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly functionType: ɵFunctionType;
    readonly functionArgument: ɵColumnExpression;
    constructor(config: ɵLengthFunctionExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser?: TExpressionParser): ɵLengthFunctionExpression;
    clone(): ɵLengthFunctionExpression;
}

export declare type ɵLengthFunctionExpressionConfig = ɵArgumentFunctionExpressionConfig<ɵLengthFunctionExpression>;

/**
 * @public
 * @description contract for localizable string
 *
 * @example
 * const localizableString = {
 * 	"en-US": 'localizable string'
 * }
 */
export declare type ɵLocalizableString = string | Record<string, unknown>;

/**
 * @public
 * @description Function that takes a key to translate, and returns the translated value.
 */
export declare type ɵLocalizeFn = (key: string) => string;

export declare enum ɵLogicalOperatorType {
    And = 0,
    Or = 1
}

/**
 * @public
 * @description Required shape for lookup.
 * @extends {ɵJsonObject}
 * @property {string} displayValue - Value witch will be displayed in lookup
 * @property {string} primaryImageValue - Image for lookup value
 * @property {ɵGuid} value - {@link ɵGuid} - actual lookup value
 * @property {string} primaryColorValue - display color of lookup value
 */
export declare interface ɵLookupValue extends ɵJsonObject {
    /**
     * @description Value witch will be displayed in lookup
     */
    displayValue: string;
    /**
     * @description Image for lookup value
     */
    primaryImageValue?: string;
    /**
     * @description actual lookup value
     */
    value: ɵGuid;
    /**
     * @description display color of lookup value
     */
    primaryColorValue?: string;
}

/**
 * @public
 * @description Lookup value with code
 * @extends {ɵLookupValue}
 * @property {string} code - code of lookup value
 */
export declare interface ɵLookupValueWithCode extends ɵLookupValue {
    /**
     * @description code of lookup value
     */
    code: string;
}

export declare class ɵMacrosFunctionColumn extends ɵBaseQueryColumn<ɵMacrosFunctionExpression> {
    constructor(macrosType: ɵQueryMacrosType);
}

export declare class ɵMacrosFunctionExpression extends ɵFunctionExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly functionType: ɵFunctionType;
    readonly macrosType: ɵQueryMacrosType;
    constructor(config: ɵMacrosFunctionExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto: ɵJsonObject): ɵMacrosFunctionExpression;
    clone(): ɵMacrosFunctionExpression;
}

export declare type ɵMacrosFunctionExpressionConfig = ɵFunctionExpressionConfig<ɵMacrosFunctionExpression> & Pick<ɵMacrosFunctionExpression, 'macrosType'>;

/**
 * @public
 */
export declare interface ɵMetadataProvider<T> {
    getMetadata(): T;
}

/**
 * @public
 */
export declare enum ɵModelParameterType {
    PrimaryColumnValue = "primaryColumnValue",
    Filter = "filter",
    PrimaryDisplayValueFilter = "primaryDisplayValueFilter",
    Empty = "empty",
    Never = "never"
}

/**
 * @public
 */
export declare class ɵNextHandlerAlreadySpecifiedException extends Error {
    constructor();
}

export declare enum ɵOrderDirection {
    None = 0,
    Asc = 1,
    Desc = 2
}

export declare class ɵParameterExpression extends ɵBaseExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly expressionType: ɵExpressionType;
    readonly value: ɵEntityColumnValue;
    readonly dataValueType: ɵDataValueType;
    readonly parameter: {
        value?: ɵEntityColumnValue;
        arrayValue?: string[];
        dataValueType: ɵDataValueType;
    };
    constructor(config: ɵParameterExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson(dto: ɵJsonObject): ɵParameterExpression;
    private _convertStringToBlobArray;
    private _getParameterValueMetadata;
    clone(): ɵParameterExpression;
}

export declare type ɵParameterExpressionConfig = ɵExpressionConfig<ɵParameterExpression> & Pick<ɵParameterExpression, 'value'>;

export declare class ɵParameterQueryColumn extends ɵBaseQueryColumn<ɵParameterExpression> {
    constructor(value: ɵEntityColumnValue, dataValueType?: ɵDataValueType);
}

export declare const ɵparserMock: {
    fromJson: (data: any) => any;
    clone: () => undefined;
};

/**
 * @public
 */
export declare interface ɵPrimaryDisplayFilterDataSourceParameter extends ɵBaseDataSourceParameter {
    type: ɵModelParameterType.PrimaryDisplayValueFilter;
    value: string;
    comparisonType: ɵComparisonType;
}

export declare enum ɵQueryMacrosType {
    /** Macro type not defined. */
    None = 0,
    /** Current user. */
    CurrentUser = 1,
    /** Current user contact. */
    CurrentUserContact = 2,
    /** Yesterday. */
    Yesterday = 3,
    /** Today. */
    Today = 4,
    /** Tomorrow. */
    Tomorrow = 5,
    /** Previous week. */
    PreviousWeek = 6,
    /** This week. */
    CurrentWeek = 7,
    /** Next week. */
    NextWeek = 8,
    /** Previous month. */
    PreviousMonth = 9,
    /** Current month. */
    CurrentMonth = 10,
    /** Next month. */
    NextMonth = 11,
    /** Previous quarter. */
    PreviousQuarter = 12,
    /** Current quarter. */
    CurrentQuarter = 13,
    /** Next quarter. */
    NextQuarter = 14,
    /** Previous half of the year. */
    PreviousHalfYear = 15,
    /** Current half-year. */
    CurrentHalfYear = 16,
    /** Next half-year. */
    NextHalfYear = 17,
    /** Last year. */
    PreviousYear = 18,
    /** This year. */
    CurrentYear = 19,
    /** Previous hour. */
    PreviousHour = 20,
    /** Current hour. */
    CurrentHour = 21,
    /** Next hour. */
    NextHour = 22,
    /** Next year. */
    NextYear = 23,
    /** Next N Days. */
    NextNDays = 24,
    /** Previous N days. */
    PreviousNDays = 25,
    /** Next N hours. */
    NextNHours = 26,
    /** Previous N hours. */
    PreviousNHours = 27,
    /** Primary column. */
    PrimaryColumn = 34,
    /** Primary displayed column. */
    PrimaryDisplayColumn = 35,
    /** Primary image display column. */
    PrimaryImageColumn = 36,
    /** Anniversary today. */
    DayOfYearToday = 37,
    /** Anniversary on the date computed as today plus days offset. */
    DayOfYearTodayPlusDaysOffset = 38,
    /** Anniversary on the next several days. */
    NextNDaysOfYear = 39,
    /** Anniversary on the previous several days. */
    PreviousNDaysOfYear = 40,
    /** Primary color display column. */
    PrimaryColorColumn = 41
}

/**
 * @public
 */
export declare enum ɵQueryOperationType {
    Select = 0,
    Insert = 1,
    Update = 2,
    Delete = 3
}

/**
 * @public
 * @description Interface to defining request handler in handler chain.
 * @interface ɵRequestHandler
 * @template TRequest
 * @template TResult
 */
export declare interface ɵRequestHandler<TRequest = ɵBaseRequest, TResult = unknown> {
    /**
     * @description Abstract async method which contains logic to handle request properly.
     * @param {TRequest} request - {@link BaseRequest}
     */
    handle(request: TRequest): Promise<TResult>;
    /**
     * @description Method to set request handler in handler chain.
     * @param {ɵRequestHandler} next - link for next request handler - {@link ɵRequestHandler}
     */
    setNext(next: ɵRequestHandler): void;
}

/**
 * @public
 * @description Function that takes a injection token, and returns dependency instance.
 */
export declare type ɵResolveDependencyFn = (token: unknown) => unknown;

/**
 * @public
 */
export declare class ɵSelectLocalizationQuery extends ɵEntitySchemaQuery {
}

export declare interface ɵSerializable {
    toJson(): ɵJsonObject;
}

export declare abstract class ɵSingleFilter extends ɵBaseFilter {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly comparisonType: ɵComparisonType;
    readonly leftExpression: ɵBaseExpression;
    protected constructor(filterType: ɵFilterType, comparisonType: ɵComparisonType, leftExpression: ɵBaseExpression);
    toJson(): ɵJsonObject;
}

/**
 * @public
 */
export declare interface ɵSortColumnOptions {
    columnName: string;
    direction: ɵSortDirection;
}

/**
 * @public
 * @description sorting direction
 */
export declare type ɵSortDirection = 'asc' | 'desc' | 'none';

export declare class ɵSubQueryColumn extends ɵBaseQueryColumn<ɵSubQueryExpression> {
    constructor(columnPath: string, subFilters?: ɵFilterGroup);
}

export declare class ɵSubQueryExpression extends ɵBaseExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly expressionType: ɵExpressionType;
    columnPath: string;
    readonly subFilters: ɵFilterGroup;
    readonly subOrderDirection?: number;
    readonly subOrderColumn?: string;
    constructor(config: ɵSubQueryExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser>(dto: ɵJsonObject, filterParser: TFilterParser): ɵSubQueryExpression;
    clone(): ɵSubQueryExpression;
    toJson(): ɵJsonObject;
}

export declare type ɵSubQueryExpressionConfig = ɵExpressionConfig<ɵSubQueryExpression> & Pick<ɵSubQueryExpression, 'columnPath'>;

/**
 * @public
 * Returns a string represent of date in ISO 8601 without time zone specification(doesn't convert it
 * using local timezone).
 *
 * Example:
 *
 *      const date = new Date(2018, 01, 20, 15, 10, 30);
 *      const result = toLocalISOString(date);
 *      //result: '2018-02-20T15:10:30'
 *
 * @param date Date value.
 */
export declare function ɵtoLocalISOString(date: Date): string;

/**
 * @public
 * @description Shape for generic type.
 */
export declare type ɵType<T = any> = new (...args: any[]) => T;

/**
 * @public
 */
export declare class ɵUpdateQuery extends ɵBaseFilterableQuery {
    private _columnValues;
    /**
     * Flag that indicates whether to force save data.
     */
    isForceUpdate: boolean;
    constructor(rootSchemaName: string);
    get columnValues(): {
        items: {
            [key: string]: ɵParameterExpression;
        };
    };
    addColumn(columnName: string, columnValue: ɵEntityColumnValue, dataValueType: ɵDataValueType): void;
}

export declare class ɵValidationUtilities {
    static checkArgumentEmpty<T>(argumentName: string, argumentValue: T | null | undefined): asserts argumentValue is T;
    static checkArrayEmpty<T>(argumentName: string, argumentValue: ArrayLike<T>): void;
    static checkStringIsNotEmpty(argumentName: string, argumentValue: string): string;
    static checkArgumentOutOfRange(argumentName: string, argumentValue: number, range: {
        begin?: number;
        end?: number;
    }): void;
}

/**
 * @public
 * @description Interface describes view model context.
 * Could contain any pair of key-value
 */
export declare interface ɵViewModelContext {
    [key: string]: any;
}

export declare class ɵWindowFunctionColumn extends ɵBaseQueryColumn<ɵWindowFunctionExpression> {
    constructor(functionArgument: ɵAggregationFunctionExpression);
}

export declare class ɵWindowFunctionExpression extends ɵArgumentFunctionExpression {
    /* Excluded from this release type: _instanceOfKey */
    /* Excluded from this release type: _instanceOfKeys */
    readonly functionType: ɵFunctionType;
    readonly functionArgument: ɵAggregationFunctionExpression;
    constructor(config: ɵWindowFunctionExpressionConfig);
    /**
     * Parses expression from json.
     * @public
     */
    static fromJson<TFilterParser extends typeof ɵBaseFilterParser, TExpressionParser extends typeof ɵBaseExpressionParser>(dto: ɵJsonObject, filterParser: TFilterParser, expressionParser?: TExpressionParser): ɵWindowFunctionExpression;
    clone(): ɵWindowFunctionExpression;
}

export declare type ɵWindowFunctionExpressionConfig = ɵArgumentFunctionExpressionConfig<ɵWindowFunctionExpression>;

export { }
