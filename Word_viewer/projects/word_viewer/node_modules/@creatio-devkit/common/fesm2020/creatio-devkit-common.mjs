import { ɵAggregationType, ɵAggregationFunction, ɵAggregationEvalType, ɵDatePartType, ɵFunctionType, ɵOrderDirection, ɵgenerateGuid, ɵNextHandlerAlreadySpecifiedException, ɵBaseRequest } from '@creatio/base';
export { ɵAggregationEvalType as AggregationEvalType, ɵAggregationFunction as AggregationFunction, ɵAggregationFunctionColumn as AggregationFunctionColumn, ɵAggregationFunctionExpression as AggregationFunctionExpression, ɵAggregationSubQueryColumn as AggregationSubQueryColumn, ɵAggregationSubQueryExpression as AggregationSubQueryExpression, ɵAggregationType as AggregationType, ɵArgumentEmptyException as ArgumentEmptyException, ɵArgumentFunctionExpression as ArgumentFunctionExpression, ɵArgumentOutOfRangeException as ArgumentOutOfRangeException, ɵArithmeticExpression as ArithmeticExpression, ɵArithmeticOperation as ArithmeticOperation, ɵArithmeticQueryColumn as ArithmeticQueryColumn, ɵBaseExpression as BaseExpression, ɵBaseExpressionParser as BaseExpressionParser, ɵBaseFilter as BaseFilter, ɵBaseFilterParser as BaseFilterParser, ɵBaseFilterableQuery as BaseFilterableQuery, ɵBaseQuery as BaseQuery, ɵBaseQueryColumn as BaseQueryColumn, ɵBaseRequest as BaseRequest, ɵBetweenFilter as BetweenFilter, ɵColumnExpression as ColumnExpression, ɵCompareFilter as CompareFilter, ɵComparisonType as ComparisonType, ɵDEFAULT_COLUMN_PLAIN_OBJ as DEFAULT_COLUMN_PLAIN_OBJ, ɵDEFAULT_FILTER_PLAIN_OBJ as DEFAULT_FILTER_PLAIN_OBJ, ɵDataSchemaAttributeType as DataSchemaAttributeType, ɵDataSchemaAttributeUsageType as DataSchemaAttributeUsageType, ɵDataSchemaType as DataSchemaType, ɵDataSourceScope as DataSourceScope, ɵDataValueType as DataValueType, ɵDatePartFunctionColumn as DatePartFunctionColumn, ɵDatePartFunctionExpression as DatePartFunctionExpression, ɵDatePartType as DatePartType, ɵDefaultValueSource as DefaultValueSource, ɵDeleteQuery as DeleteQuery, ɵEMPTY_GUID as EMPTY_GUID, ɵEntityQueryColumn as EntityQueryColumn, ɵEntitySchemaQuery as EntitySchemaQuery, ɵExistsFilter as ExistsFilter, ɵExpressionMock as ExpressionMock, ɵExpressionParser as ExpressionParser, ɵExpressionResolver as ExpressionResolver, ɵExpressionType as ExpressionType, ɵFilterGroup as FilterGroup, ɵFilterMock as FilterMock, ɵFilterParser as FilterParser, ɵFilterResolver as FilterResolver, ɵFilterType as FilterType, ɵFunctionExpression as FunctionExpression, ɵFunctionType as FunctionType, ɵInFilter as InFilter, ɵInsertQuery as InsertQuery, ɵIsNullFilter as IsNullFilter, ɵItemNotFoundException as ItemNotFoundException, ɵLengthFunctionColumn as LengthFunctionColumn, ɵLengthFunctionExpression as LengthFunctionExpression, ɵLogicalOperatorType as LogicalOperatorType, ɵMacrosFunctionColumn as MacrosFunctionColumn, ɵMacrosFunctionExpression as MacrosFunctionExpression, ɵModelParameterType as ModelParameterType, ɵNextHandlerAlreadySpecifiedException as NextHandlerAlreadySpecifiedException, ɵOrderDirection as OrderDirection, ɵParameterExpression as ParameterExpression, ɵParameterQueryColumn as ParameterQueryColumn, ɵQueryMacrosType as QueryMacrosType, ɵQueryOperationType as QueryOperationType, ɵSelectLocalizationQuery as SelectLocalizationQuery, ɵSingleFilter as SingleFilter, ɵSubQueryColumn as SubQueryColumn, ɵSubQueryExpression as SubQueryExpression, ɵUpdateQuery as UpdateQuery, ɵValidationUtilities as ValidationUtilities, ɵWindowFunctionColumn as WindowFunctionColumn, ɵWindowFunctionExpression as WindowFunctionExpression, ɵencodeDate as encodeDate, ɵgenerateGuid as generateGuid, ɵgetColumnPlainObj as getColumnPlainObj, ɵgetFilterPlainObj as getFilterPlainObj, ɵisEmptyGuid as isEmptyGuid, ɵisGuid as isGuid, ɵparserMock as parserMock, ɵtoLocalISOString as toLocalISOString } from '@creatio/base';
import { get, set, upperFirst, camelCase, isEqual, cloneDeep } from 'lodash';
import 'reflect-metadata';
import { __decorate, __metadata } from 'tslib';

/**
 * @internal
 */
function toAggregationType(aggregationFunction) {
    switch (aggregationFunction) {
        case ɵAggregationFunction.Count:
            return ɵAggregationType.Count;
        case ɵAggregationFunction.Sum:
            return ɵAggregationType.Sum;
        case ɵAggregationFunction.Avg:
            return ɵAggregationType.Avg;
        case ɵAggregationFunction.Min:
            return ɵAggregationType.Min;
        case ɵAggregationFunction.Max:
            return ɵAggregationType.Max;
        case ɵAggregationFunction.TopOne:
            return ɵAggregationType.TopOne;
        default:
            return ɵAggregationType.None;
    }
}
/**
 * @internal
 */
function toAggregationFunction(aggregationType) {
    switch (aggregationType) {
        case ɵAggregationType.Count:
            return ɵAggregationFunction.Count;
        case ɵAggregationType.Sum:
            return ɵAggregationFunction.Sum;
        case ɵAggregationType.Avg:
            return ɵAggregationFunction.Avg;
        case ɵAggregationType.Min:
            return ɵAggregationFunction.Min;
        case ɵAggregationType.Max:
            return ɵAggregationFunction.Max;
        case ɵAggregationType.TopOne:
            return ɵAggregationFunction.TopOne;
        default:
            return ɵAggregationFunction.None;
    }
}
/**
 * @internal
 */
function toAggregationEvalType(aggregationEval) {
    switch (aggregationEval) {
        case 'all':
            return ɵAggregationEvalType.All;
        case 'distinct':
            return ɵAggregationEvalType.Distinct;
        default:
            return ɵAggregationEvalType.None;
    }
}
/**
 * @internal
 */
function toAggregationEval(aggregationEvalType) {
    switch (aggregationEvalType) {
        case ɵAggregationEvalType.All:
            return 'all';
        case ɵAggregationEvalType.Distinct:
            return 'distinct';
        default:
            return 'none';
    }
}

/**
 * @internal
 */
function toDatePartType(aggregationFunction) {
    switch (aggregationFunction) {
        case 'minute':
            return ɵDatePartType.HourMinute;
        case 'hour':
            return ɵDatePartType.Hour;
        case 'day':
            return ɵDatePartType.Day;
        case 'weekday':
            return ɵDatePartType.WeekDay;
        case 'week':
            return ɵDatePartType.Week;
        case 'month':
            return ɵDatePartType.Month;
        case 'year':
            return ɵDatePartType.Year;
        default:
            return ɵDatePartType.None;
    }
}
/**
 * @internal
 */
function toDatePart(aggregationType) {
    switch (aggregationType) {
        case ɵDatePartType.HourMinute:
            return 'minute';
        case ɵDatePartType.Hour:
            return 'hour';
        case ɵDatePartType.Day:
            return 'day';
        case ɵDatePartType.WeekDay:
            return 'weekday';
        case ɵDatePartType.Week:
            return 'week';
        case ɵDatePartType.Month:
            return 'month';
        case ɵDatePartType.Year:
            return 'year';
        default:
            return 'none';
    }
}

/**
 * @internal
 */
function toStringFunctionType(functionType) {
    switch (functionType) {
        case ɵFunctionType.Aggregation:
            return 'aggregation';
        case ɵFunctionType.DatePart:
            return 'datePart';
        default:
            return 'none';
    }
}
/**
 * @internal
 */
function toNumericFunctionType(functionType) {
    switch (functionType) {
        case 'aggregation':
            return ɵFunctionType.Aggregation;
        case 'datePart':
            return ɵFunctionType.DatePart;
        default:
            return ɵFunctionType.None;
    }
}

/**
 * @internal
 */
function toOrderDirection(sortDirection) {
    switch (sortDirection) {
        case 'asc':
            return ɵOrderDirection.Asc;
        case 'desc':
            return ɵOrderDirection.Desc;
        default:
            return ɵOrderDirection.None;
    }
}
/**
 * @internal
 */
function toSortDirection(orderDirection) {
    switch (orderDirection) {
        case ɵOrderDirection.Asc:
            return 'asc';
        case ɵOrderDirection.Desc:
            return 'desc';
        default:
            return 'none';
    }
}

/**
 * @internal
 */
const crtInputPrefix = 'crtInput:';
/**
 * @internal
 */
const crtOutputPrefix = 'crtOutput:';
/**
 * @internal
 */
const crtValidationInputPrefix = 'crtValidationInput:';
/**
 * @internal
 */
const crtInjectPrefix = 'crtInject:';

/**
 * @internal
 * @hostPublicApi
 */
var ViewElementGroupType;
(function (ViewElementGroupType) {
    ViewElementGroupType["Charts"] = "Charts";
    ViewElementGroupType["Components"] = "Components";
    ViewElementGroupType["LayoutElements"] = "LayoutElements";
    ViewElementGroupType["Inputs"] = "Inputs";
    ViewElementGroupType["CustomElements"] = "CustomElements";
})(ViewElementGroupType || (ViewElementGroupType = {}));

/**
 * @internal
 * @hostPublicApi
 */
var ViewElementDataGroupType;
(function (ViewElementDataGroupType) {
    ViewElementDataGroupType["Data"] = "Data";
})(ViewElementDataGroupType || (ViewElementDataGroupType = {}));
/**
 * @internal
 * @hostPublicApi
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const DesignerToolGroupType = { ...ViewElementDataGroupType, ...ViewElementGroupType };

/**
 * Handler source types in order of call priority.
 * @internal
 * @hostPublicApi
 */
var HandlerSourceType;
(function (HandlerSourceType) {
    HandlerSourceType[HandlerSourceType["Schema"] = 0] = "Schema";
    HandlerSourceType[HandlerSourceType["Remote"] = 1] = "Remote";
    HandlerSourceType[HandlerSourceType["Host"] = 2] = "Host";
})(HandlerSourceType || (HandlerSourceType = {}));

/**
 * @internal
 */
var ModelInPageAction;
(function (ModelInPageAction) {
    ModelInPageAction["Edit"] = "edit";
    ModelInPageAction["Add"] = "add";
    ModelInPageAction["Copy"] = "copy";
})(ModelInPageAction || (ModelInPageAction = {}));

const global$3 = window;
/**
 * @public
 * @description For internal use only.
 * @hostPublicApi
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class ɵBaseRegistry {
    constructor() {
        /**
         * @hostPubicApi available through window.creatio.registry.<registryKey>.store
         */
        this.store = {
            typeInfos: new Map(),
        };
    }
    static get store() {
        if (!this._instance) {
            let globalInstance = get(global$3, this._prefix + this.registryKey);
            if (!globalInstance) {
                globalInstance = new this();
                set(global$3, this._prefix + this.registryKey, globalInstance);
            }
            this._instance = globalInstance;
        }
        return this._instance.store;
    }
}
ɵBaseRegistry._prefix = 'creatio.registry.';

/**
 * @internal
 */
class PkgTopology extends ɵBaseRegistry {
    static get items() {
        return this.store.typeInfos;
    }
    static get(pkgName) {
        const order = this.items.get(pkgName);
        if (order === undefined) {
            throw new Error(`Package with name ${pkgName} not found in topology`);
        }
        return order;
    }
}
PkgTopology.registryKey = 'pkgTopology';

/**
 * @internal
 */
class HandlersOrderComparer {
    constructor(_request) {
        this._request = _request;
        const scopesOrderEntries = [...(this._request.scopes ?? [])].reverse().map((scope, index) => [scope, index]);
        this._scopesOrder = Object.fromEntries(scopesOrderEntries);
    }
    _getOrderByScopes(handler) {
        if (!handler.scopes) {
            return Number.MAX_VALUE;
        }
        const scopesOrder = handler.scopes.filter((s) => s in this._scopesOrder).map((s) => this._scopesOrder[s]);
        return Math.min(...scopesOrder);
    }
    _getOrderByPkgTopology(handler) {
        if (handler.source.type === HandlerSourceType.Host) {
            return Number.MAX_VALUE;
        }
        return PkgTopology.get(handler.source.packageName);
    }
    compare(a, b) {
        const aScopeOrder = this._getOrderByScopes(a);
        const bScopeOrder = this._getOrderByScopes(b);
        let diff = aScopeOrder - bScopeOrder;
        if (diff) {
            return diff;
        }
        const aPkgTopologyOrder = this._getOrderByPkgTopology(a);
        const bPkgTopologyOrder = this._getOrderByPkgTopology(b);
        diff = aPkgTopologyOrder - bPkgTopologyOrder;
        if (diff) {
            return diff;
        }
        diff = a.source.type - b.source.type;
        return diff;
    }
}

/**
 * @internal
 * @hostPublicApi available through window.handlerChain
 */
class InternalHandlerChain {
    constructor() {
        this._handlers = [];
        this._requestListeners = new Map();
        this._handlersCache = new Map();
        this._handlersScopesByContextId = new Map();
        /**
         * @hostPublicApi
         */
        this.handlerChain$ = {
            /**
             * @hostPublicApi
             */
            process: async (request) => {
                const handler = this._getHandler(request);
                this._requestListeners.forEach((listener) => listener?.(request));
                return handler?.handle(request);
            },
            /**
             * @hostPublicApi
             */
            register: (info) => {
                this._handlersCache.delete(info.requestType);
                this._handlers.push(info);
                return () => {
                    const index = this._handlers.indexOf(info);
                    if (index > -1) {
                        this._handlers.splice(index, 1);
                        this._handlersCache.delete(info.requestType);
                    }
                    else {
                        console.warn(`${info?.requestType} not found to unsubscribe`);
                    }
                };
            },
            /**
             * @hostPublicApi
             */
            subscribe: (callback, context) => {
                if (!callback) {
                    return () => void 0;
                }
                const listenerId = ɵgenerateGuid();
                const listenerFn = (request) => {
                    if (!context || request.$context === context) {
                        callback(request);
                    }
                };
                this._requestListeners.set(listenerId, listenerFn);
                return () => this._requestListeners.delete(listenerId);
            },
        };
    }
    /**
     * @hostPublicApi
     */
    clearContextedHandlersCache(contextId) {
        const configs = this._handlersScopesByContextId.get(contextId) ?? [];
        return configs.every(({ requestType, scope }) => this._handlersCache.get(requestType)?.delete(scope));
    }
    _getHandler(request) {
        return this._hasCacheHandler(request) ? this._getCacheHandler(request) : this._buildHandlersChain(request);
    }
    _getCacheHandler(request) {
        const map = this._handlersCache.get(request.type);
        const key = this._getCacheScopesKey(request);
        return map.get(key);
    }
    _hasCacheHandler(request) {
        const map = this._handlersCache.get(request.type);
        const key = this._getCacheScopesKey(request);
        return map && map.has(key);
    }
    _getCacheScopesKey(request) {
        const injectionContextKey = this._getInjectionContext(request?.$context)?.id ?? '';
        return (request.scopes || ['']).join('_').concat(injectionContextKey);
    }
    _getInjectionContext(viewModel) {
        return (viewModel?.['_injectionContext'] ||
            (viewModel?.['parent'] && this._getInjectionContext(viewModel['parent'])));
    }
    _setContextedScopes(request, scope) {
        const injectionContext = this._getInjectionContext(request?.$context)?.id;
        const configs = this._handlersScopesByContextId.has(injectionContext)
            ? this._handlersScopesByContextId.get(injectionContext)
            : [];
        configs.push({ requestType: request.type, scope });
        this._handlersScopesByContextId.set(injectionContext, configs);
    }
    _setCacheHandler(request, handler) {
        const map = this._handlersCache.has(request.type)
            ? this._handlersCache.get(request.type)
            : new Map();
        const key = this._getCacheScopesKey(request);
        map.set(key, handler);
        if (this._getInjectionContext(request?.$context)?.id) {
            this._setContextedScopes(request, key);
        }
        this._handlersCache.set(request.type, map);
    }
    _isRequestHandler(handler) {
        return (typeof handler.handle === 'function' &&
            typeof handler.setNext === 'function');
    }
    _checkHandlerInstanceOf(handler) {
        if (!this._isRequestHandler(handler)) {
            throw new Error('Handler should implement "BaseRequestHandler"');
        }
    }
    _buildHandlersChain(request) {
        const handlers = this._handlers.filter((h) => {
            if (h.requestType !== request.type) {
                return false;
            }
            if (!h.scopes?.length) {
                return true;
            }
            return h.scopes.some((s) => request.scopes?.includes(s));
        });
        const comparer = new HandlersOrderComparer(request);
        handlers.sort((a, b) => comparer.compare(a, b));
        const handlerInstances = handlers.map((handlerConfig) => {
            const injectionContext = this._getInjectionContext(request?.$context);
            return handlerConfig.createHandler(injectionContext);
        });
        handlerInstances.forEach((handler) => this._checkHandlerInstanceOf(handler));
        this._joinHandlersInChain(handlerInstances);
        const result = handlerInstances[0];
        this._setCacheHandler(request, result);
        return result;
    }
    _joinHandlersInChain(handlers) {
        for (let index = 0; index < handlers.length - 1; index++) {
            try {
                handlers[index].setNext(handlers[index + 1]);
            }
            catch (error) {
                if (error instanceof ɵNextHandlerAlreadySpecifiedException) {
                    throw new Error('Handler factory should return new instance of ' +
                        'BaseRequestHandler class or its subclass ' +
                        '(next handler should not be specified)');
                }
                throw error;
            }
        }
    }
}

const global$2 = window;
/**
 * @public
 * @class HandlerChainService
 * @classdesc Service to design handlers in chain.
 */
class HandlerChainService {
    get _chain() {
        return global$2.handlerChain;
    }
    set _chain(value) {
        global$2.handlerChain = value;
    }
    static get instance() {
        return HandlerChainService._instance || (HandlerChainService._instance = new HandlerChainService());
    }
    constructor() {
        if (!this._chain) {
            this._createGlobalHandlerChain();
        }
    }
    _createGlobalHandlerChain() {
        this._chain = new InternalHandlerChain();
    }
    /**
     * @internal
     */
    clearContextedHandlersCache(contextId) {
        return this._chain.clearContextedHandlersCache(contextId);
    }
    /**
     * @internal
     */
    register(handlerConfig) {
        return this._chain.handlerChain$.register(handlerConfig);
    }
    /**
     * @description Method to process passed request
     * @param request - {@link ɵBaseRequest}
     * @return `Promise<unknown>`
     */
    process(request) {
        return this._chain.handlerChain$.process(request);
    }
    /**
     * @internal
     * Subscribes to requests.
     * @param callback A handler function for each request triggered.
     * @param context (optional) A context in which the requests were triggered.
     * The `callback` will be called only for requests with specified context.
     * If not  specified, will be called for all requests.
     * @returns A function to cancel the subscription.
     */
    subscribe(callback, context) {
        return this._chain.handlerChain$.subscribe(callback, context);
    }
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function ImplementUsingHandlerChain(config) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function (target, method, descriptor) {
        const methodImplementation = function (...args) {
            return HandlerChainService.instance.process({
                type: config?.requestType ? config.requestType : this.requestType,
                method: config?.methodName ? config.methodName : method,
                args,
            });
        };
        if (descriptor) {
            descriptor.value = methodImplementation;
        }
        else {
            target[method] = methodImplementation;
        }
    };
}

/**
 * @internal
 */
function objectDeepKeys(obj) {
    if (obj === null || typeof obj !== 'object') {
        return [];
    }
    return Object.keys(obj)
        .filter((key) => obj[key] instanceof Object)
        .map((key) => objectDeepKeys(obj[key]).map((k) => [key, ...k]))
        .reduce((x, y) => [...x, ...y], Object.keys(obj).map((x) => [x]));
}

/**
 * @internal
 */
function checkTypeNameFormat(type, element) {
    const typeParts = type.split('.');
    if (typeParts.length < 2) {
        throw new Error(`Error when register ${type}. Type property should have format "VendorPrefix.${element}"`);
    }
}
/**
 * @public
 * @description For internal use only.
 */
function ɵcheckTypeNameFormat(type, element) {
    return checkTypeNameFormat(type, element);
}
/**
 * @internal
 */
function checkTypeNamePascalCase(type) {
    const [vendor, typeName] = type.split('.');
    const pascalTypeName = toPascalCase(typeName);
    if (!vendor || pascalTypeName !== typeName) {
        throw new Error(`Error when register ${type}. Type property should have Pascal case, e.g. ${vendor + '.' + pascalTypeName}. ` + 'The first letter of each word in a compound word should be capitalized');
    }
}
/**
 * @internal
 */
function checkCrtTypeNamePascalCase(type) {
    const [vendor, typeName] = type.split('.');
    const pascalTypeName = toPascalCase(typeName);
    if (vendor.toLowerCase() === 'crt' && pascalTypeName !== typeName) {
        throw new Error(`Error when register ${type}. Type property should have Pascal case, e.g. ${vendor + '.' + pascalTypeName}. ` + 'The first letter of each word in a compound word should be capitalized');
    }
}
/**
 * @internal
 */
function toPascalCase(source) {
    return upperFirst(camelCase(source));
}
/**
 * @internal
 */
function checkIfTypeRegistered(type, item) {
    if (!item) {
        throw new Error(`Error when resolve ${type}. Type was not registered.`);
    }
}
/**
 * @internal
 */
function checkOnlyOneRegistration(type, item, map) {
    if (map.has(type) && !isEqual(map.get(type), item)) {
        throw new Error(`Error when register ${type}. Element with this type has already exist`);
    }
}

/**
 * @internal
 * @hostPublicApi available through window.creatio.requestHandlerRegistry
 */
class InternalRequestHandlerRegistryType {
    /**
     * @publicHostApi
     */
    static get requestHandlersMap() {
        return this._requestHandlersMap;
    }
    /**
     * @publicHostApi
     */
    static onAddRequestHandler(handler) {
        this._addItemListeners.push(handler);
        return () => {
            this._addItemListeners.splice(this._addItemListeners.indexOf(handler), 1);
        };
    }
    /**
     * @publicHostApi
     */
    static onRemoveRequestHandler(handler) {
        this._removeItemListeners.push(handler);
        return () => {
            this._removeItemListeners.splice(this._removeItemListeners.indexOf(handler), 1);
        };
    }
    /**
     * @publicHostApi
     */
    static addRequestHandler(handlerType, config) {
        if (!this._requestHandlersMap.has(handlerType)) {
            this._requestHandlersMap.set(handlerType, config);
            for (const listener of this._addItemListeners) {
                listener(handlerType, config);
            }
        }
    }
    /**
     * @publicHostApi
     */
    static removeRequestHandler(handlerType) {
        const config = this._requestHandlersMap.get(handlerType);
        if (config) {
            this._requestHandlersMap.delete(handlerType);
            for (const listener of this._removeItemListeners) {
                listener(handlerType, config);
            }
        }
    }
}
InternalRequestHandlerRegistryType._addItemListeners = [];
InternalRequestHandlerRegistryType._removeItemListeners = [];
InternalRequestHandlerRegistryType._requestHandlersMap = new Map();
const global$1 = window;
global$1.creatio ?? (global$1.creatio = {});
if (!global$1.creatio.requestHandlerRegistry) {
    Object.defineProperty(global$1.creatio, 'requestHandlerRegistry', {
        get: () => InternalRequestHandlerRegistryType,
        configurable: false,
    });
}
/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const InternalRequestHandlerRegistry = InternalRequestHandlerRegistryType;
/**
 * @internal
 */
class RequestHandlerRegistryService {
    /**
     * Register request handler class.
     * @param config Request handler registration config.
     * @param type Request handler type.
     */
    static register(config, type) {
        const requestType = config.requestType;
        const requestHandlerType = config.type;
        if (!requestType) {
            throw new Error(`Error when register ${requestHandlerType}. Request type not specified.`);
        }
        const requestHandlerMapValue = {
            instanceType: type,
            instanceConfig: config,
        };
        RequestHandlerRegistryService._internalRegistry.addRequestHandler(requestHandlerType, requestHandlerMapValue);
    }
}
RequestHandlerRegistryService._internalRegistry = global$1.creatio.requestHandlerRegistry;

/**
 * @internal
 */
class RequestRegistryService {
    static get requestsRegistrationInfos() {
        return this._requestsRegistrationInfos;
    }
    /**
     * Registers a specified request class.
     * @param config Request registration config.
     * @param type Request type.
     */
    static register(config, type) {
        const requestType = config.type;
        // TODO RND-21723
        RequestRegistryService._requestsMap.set(requestType, type);
        RequestRegistryService._requestsRegistrationInfos.set(requestType, config);
    }
    /**
     * Creates request instance by specified registered request type.
     * @param type Request type.
     * @returns The instance of registered request.
     */
    static get(type) {
        const requestInstanceConstructor = RequestRegistryService._requestsMap.get(type);
        checkIfTypeRegistered(type, requestInstanceConstructor);
        return requestInstanceConstructor && new requestInstanceConstructor();
    }
}
RequestRegistryService._requestsMap = new Map();
RequestRegistryService._requestsRegistrationInfos = new Map();

/**
 * @internal
 * @hostPublicApi available through window.creatio.registry.ConverterRegistry
 */
class ConverterRegistry extends ɵBaseRegistry {
    static get(type) {
        if (!this.store.typeInfos.has(type)) {
            throw new Error(`'${type}' converter doesn't exist`);
        }
        return this.store.typeInfos.get(type);
    }
    static register(item) {
        checkTypeNameFormat(item.type, 'ConverterTypeName');
        checkCrtTypeNamePascalCase(item.type);
        // TODO RND-21723
        this.store.typeInfos.set(item.type, item);
    }
    static clear() {
        this.store.typeInfos.clear();
    }
}
ConverterRegistry.registryKey = 'ConverterRegistry';

/**
 * @internal
 */
const viewElementRegistryKey = 'ViewElementRegistry';
/**
 * @internal
 * @hostPublicApi available through window.creatio.registry.ValidatorRegistry
 */
class ViewElementRegistry extends ɵBaseRegistry {
    static validate(config) {
        checkTypeNameFormat(config.type, 'ViewElementTypeName');
        checkOnlyOneRegistration(config.type, config, ViewElementRegistry.viewElements);
    }
    static get viewElements() {
        return this.store.typeInfos;
    }
    static register(config) {
        this.viewElements.set(config.type, config);
    }
    static getFormControlRelatesAttribute(type) {
        const config = this.store.typeInfos.get(type);
        return (config && 'formControlConfig' in config && config.formControlConfig?.relatesTo) || null;
    }
}
ViewElementRegistry.registryKey = viewElementRegistryKey;

/**
 * @internal
 */
const interfaceDesignerItemRegistryKey = 'InterfaceDesignerItemRegistry';
/**
 * @internal
 * @hostPublicApi available through window.creatio.registry.InterfaceDesignerItemRegistry
 */
class InterfaceDesignerItemRegistry extends ɵBaseRegistry {
    static validate(config) {
        checkTypeNameFormat(config.type, 'InterfaceDesignerItemTypeName');
        checkCrtTypeNamePascalCase(config.type);
        checkOnlyOneRegistration(config.type, config, this.interfaceDesignerItemRegistrationInfos);
    }
    static register(config) {
        this.interfaceDesignerItemRegistrationInfos.set(config.type, config);
    }
    static get interfaceDesignerItemRegistrationInfos() {
        return this.store.typeInfos;
    }
    static get(type) {
        return this.interfaceDesignerItemRegistrationInfos.get(type);
    }
}
InterfaceDesignerItemRegistry.registryKey = interfaceDesignerItemRegistryKey;

const global = window;
/**
 * @internal
 */
class BootstrapNotifier {
    static get instance() {
        if (!global.__crtModuleBootstrapNotifier) {
            global.__crtModuleBootstrapNotifier = new BootstrapNotifier();
        }
        return global.__crtModuleBootstrapNotifier;
    }
    constructor() {
        this._subscribers = new Set();
        // private constructor prevent instantiation via 'new' keyword
    }
    notify(moduleType) {
        for (const subscriber of this._subscribers.values()) {
            subscriber(moduleType);
        }
    }
    subscribe(subscriber) {
        this._subscribers.add(subscriber);
        return {
            unsubscribe: () => this._subscribers.delete(subscriber),
        };
    }
}

/**
 * @internal
 */
class HandlerChainServicesRegistry extends ɵBaseRegistry {
    static validate({ requestType }) {
        checkTypeNameFormat(requestType, this.registryKey);
        checkCrtTypeNamePascalCase(requestType);
        this.checkUniqueRequestType(requestType);
    }
    static checkUniqueRequestType(requestType) {
        if (this.services.get(requestType)) {
            throw new Error(`${requestType} already registered`);
        }
    }
    static register(config) {
        this.validate(config);
        this.services.set(config.requestType, config);
    }
    static get services() {
        return this.store.typeInfos;
    }
}
HandlerChainServicesRegistry.registryKey = 'HandlerChainServicesRegistry';

/**
 * @internal
 */
const designTimeViewElementRegistryKey = 'DesignTimeViewElementRegistry';
/**
 * @internal
 * @hostPublicApi available through window.creatio.registry.DesignTimeViewElementRegistry
 */
class DesignTimeViewElementRegistry extends ɵBaseRegistry {
    static validate(config) {
        checkTypeNameFormat(config.type, 'DesignTimeViewElementRegistryItemTypeName');
        checkCrtTypeNamePascalCase(config.type);
        checkOnlyOneRegistration(config.type, config, this.infos);
    }
    static register(config) {
        this.infos.set(config.type, config);
    }
    static getByOverriddenType(type) {
        const item = Array.from(this.infos).find(([_, info]) => info.overrideType === type);
        if (item) {
            return item[1];
        }
        return null;
    }
    static get infos() {
        return this.store.typeInfos;
    }
}
DesignTimeViewElementRegistry.registryKey = designTimeViewElementRegistryKey;

/**
 * @internal
 */
class ValidatorMapValue {
}
/**
 * @internal
 */
const validatorRegistryKey = 'ValidatorRegistry';
/**
 * @internal
 * @hostPublicApi available through window.creatio.registry.ValidatorRegistry
 */
class ValidatorRegistry extends ɵBaseRegistry {
    static _has(configType, type) {
        return ValidatorRegistry.items.has(configType) && ValidatorRegistry.items.get(configType)?.typeRef !== type;
    }
    static validate(config) {
        checkTypeNameFormat(config.type, 'ValidatorTypeName');
        if (ValidatorRegistry._has(config.type, config.typeRef)) {
            throw new Error(`Error when register ${config.type}. Element with this type has already exist`);
        }
    }
    static get items() {
        return this.store.typeInfos;
    }
    static register(config) {
        this.items.set(config.type, config);
    }
}
ValidatorRegistry.registryKey = validatorRegistryKey;

/**
 * @internal
 * @dontChange
 */
class RemoteEntriesRegistry extends ɵBaseRegistry {
    /**
     * @dontChange
     */
    static get items() {
        return this.store.typeInfos;
    }
}
/**
 * @dontChange
 */
RemoteEntriesRegistry.registryKey = 'remotes';

/**
 * @internal
 */
function isComponentPropertyBindable(viewConfigType, componentProperty) {
    const componentConfig = ViewElementRegistry.viewElements.get(viewConfigType);
    if (!componentConfig?.inputs) {
        return false;
    }
    return !!componentConfig?.inputs[componentProperty]?.propertyBindable;
}

const moduleMetadataKey = 'module';
const viewElementMetadataKey = 'viewElement';
const interfaceDesignerItemMetadataKey = 'interfaceDesignerItem';
const requestHandlerMetadataKey = 'requestHandler';
const designTimeViewElementMetadataKey = 'designTimeViewElement';
const validatorMetadataKey = 'validator';
const converterMetadataKey = 'converter';
/**
 * @internal
 */
function setModuleMetadata(metadata, type) {
    Reflect.defineMetadata(moduleMetadataKey, metadata, type);
}
/**
 * @internal
 */
function getModuleMetadata(type) {
    const metadata = Reflect.getMetadata(moduleMetadataKey, type);
    if (!metadata) {
        throw new Error(`Module metadata was not found on '${type.name}' class`);
    }
    return metadata;
}
/**
 * @internal
 */
function setViewElementMetadata(metadata, type) {
    Reflect.defineMetadata(viewElementMetadataKey, metadata, type);
}
/**
 * @internal
 */
function getViewElementMetadata(type) {
    const metadata = Reflect.getMetadata(viewElementMetadataKey, type);
    if (!metadata) {
        throw new Error(`View element metadata was not found on '${type.name}' class`);
    }
    return metadata;
}
/**
 * @internal
 */
function setValidatorMetadata(metadata, type) {
    Reflect.defineMetadata(validatorMetadataKey, metadata, type);
}
/**
 * @internal
 */
function getValidatorMetadata(type) {
    const metadata = Reflect.getOwnMetadata(validatorMetadataKey, type);
    if (!metadata) {
        throw new Error(`Validator metadata was not found on '${type.name}' class`);
    }
    return metadata;
}
/**
 * @internal
 */
function setConverterMetadata(metadata, type) {
    Reflect.defineMetadata(converterMetadataKey, metadata, type);
}
/**
 * @internal
 */
function getConverterMetadata(type) {
    const metadata = Reflect.getOwnMetadata(converterMetadataKey, type);
    if (!metadata) {
        throw new Error(`Converter metadata was not found on '${type.name}' class`);
    }
    return metadata;
}
/**
 * @internal
 */
function setInterfaceDesignerItemMetadata(metadata, type) {
    Reflect.defineMetadata(interfaceDesignerItemMetadataKey, metadata, type);
}
/**
 * @internal
 */
function getInterfaceDesignerItemMetadata(type) {
    const metadata = Reflect.getOwnMetadata(interfaceDesignerItemMetadataKey, type);
    if (!metadata) {
        throw new Error(`Interface designer item metadata was not found on '${type.name}' class`);
    }
    return metadata;
}
/**
 * @internal
 */
function setDesignTimeViewElementMetadata(metadata, type) {
    Reflect.defineMetadata(designTimeViewElementMetadataKey, metadata, type);
}
/**
 * @internal
 */
function getDesignTimeViewElementMetadata(type) {
    const metadata = Reflect.getOwnMetadata(designTimeViewElementMetadataKey, type);
    if (!metadata) {
        throw new Error(`Design time view element metadata was not found on '${type.name}' class`);
    }
    return metadata;
}
/**
 * @internal
 */
function hasInterfaceDesignerItemMetadata(type) {
    return Reflect.hasOwnMetadata(interfaceDesignerItemMetadataKey, type);
}
/**
 * @internal
 */
function setRequestHandlerMetadata(metadata, type) {
    Reflect.defineMetadata(requestHandlerMetadataKey, metadata, type);
}
/**
 * @internal
 */
function getRequestHandlerMetadata(type) {
    const metadata = Reflect.getMetadata(requestHandlerMetadataKey, type);
    if (!metadata) {
        throw new Error(`Request handler metadata was not found on '${type.name}' class`);
    }
    return metadata;
}
/**
 * @internal
 */
function getHandlerChainServiceMetadata(typeRef) {
    const requestType = Reflect.getMetadata('requestType', typeRef);
    if (!requestType) {
        throw new Error(`requestType was not found on '${typeRef.name}' class`);
    }
    return { requestType, typeRef };
}
/**
 * @internal
 */
function getCrtInputsMetadata(type) {
    const keys = Reflect.getMetadataKeys(type);
    const crtInputKeys = keys.filter((x) => x.startsWith(crtInputPrefix));
    return Object.fromEntries(crtInputKeys.map((key) => {
        const data = Reflect.getMetadata(key, type);
        return [key.replace(crtInputPrefix, ''), data];
    }));
}
/**
 * @internal
 */
function getCrtOutputsMetadata(type) {
    const keys = Reflect.getMetadataKeys(type);
    const crtOutputKeys = keys.filter((x) => x.startsWith(crtOutputPrefix));
    return Object.fromEntries(crtOutputKeys.map((key) => {
        const data = Reflect.getMetadata(key, type);
        return [key.replace(crtOutputPrefix, ''), data];
    }));
}
/**
 * @internal
 */
function getCrtValidationInputsMetadata(type) {
    const keys = Reflect.getMetadataKeys(type);
    const crtValidationInputKeys = keys.filter((x) => x.startsWith(crtValidationInputPrefix));
    return Object.fromEntries(crtValidationInputKeys.map((key) => {
        const data = Reflect.getMetadata(key, type);
        return [key.replace(crtValidationInputPrefix, ''), data];
    }));
}
/**
 * @internal
 */
function getCrtInjectMetadata(type) {
    const keys = Reflect.getOwnMetadataKeys(type);
    const crtInjectKeys = keys.filter((x) => x.startsWith(crtInjectPrefix));
    return Object.fromEntries(crtInjectKeys.map((key) => {
        const index = Number(key.replace(crtInjectPrefix, ''));
        const data = Reflect.getMetadata(key, type);
        return [index, data];
    }));
}
/**
 * @internal
 */
function getParentType(type) {
    const parentProto = type.prototype ? Object.getPrototypeOf(type.prototype) : null;
    return parentProto ? parentProto.constructor : null;
}
/**
 * @internal
 */
function getTypeDependencies(type) {
    const paramTypes = Reflect.getOwnMetadata('design:paramtypes', type);
    if (!paramTypes) {
        if (type.length > 0) {
            throw new Error(`Dependency Injection error. Cannot read dependencies of class '${type.name}'. ` +
                `Please make sure class '${type.name}' has decorator and ` +
                "'emitDecoratorMetadata' option is enabled in your 'tsconfig.json' file.");
        }
        const parentType = getParentType(type);
        return parentType && parentType !== Object ? getTypeDependencies(parentType) : [];
    }
    const crtInjectMetadata = getCrtInjectMetadata(type);
    Object.entries(crtInjectMetadata).forEach(([index, token]) => (paramTypes[index] = token));
    return paramTypes;
}

/**
 * @internal
 */
function instantiate(type, resolveDependency) {
    const deps = getTypeDependencies(type);
    if (deps.length > 0) {
        if (!resolveDependency) {
            throw new Error(`Cannot resolve dependencies for ${type.name}. ` +
                "Please provide 'resolveDependency' bootstrap option");
        }
        const depInstances = deps.map(resolveDependency);
        return new type(...depInstances);
    }
    return new type();
}
/**
 * @public
 * @description For internal use only.
 */
function ɵinstantiate(type, resolveDependency) {
    return instantiate(type, resolveDependency);
}

/**
 * @public
 */
class CrtInputRegistrationConfig {
}

/**
 * @public
 * @class DataRequest
 * @description Definition of data source request.
 * @extends {ɵBaseRequest} {@link ɵBaseRequest}
 * @property {string} dataSourceName - name of assigned data source.
 */
class DataRequest extends ɵBaseRequest {
}

/**
 * @public
 * @description Request payload
 * @property {string} request - request name.
 * @property {unknown} params - request parameters.
 */

/**
 * @internal
 */
var ViewElementReuseStrategy;
(function (ViewElementReuseStrategy) {
    /**
     * Reuse early created view element when it state changed
     */
    ViewElementReuseStrategy[ViewElementReuseStrategy["Reuse"] = 0] = "Reuse";
    /**
     * Rerender(recreate) view element when it state changed
     */
    ViewElementReuseStrategy[ViewElementReuseStrategy["Rerender"] = 1] = "Rerender";
})(ViewElementReuseStrategy || (ViewElementReuseStrategy = {}));

/**
 * @public
 * @description Abstract Base Validator class for designing custom validators.
 * @example
 * @CrtValidator({
 *    type: 'crt.Required',
 * })
 * export class RequiredValidator extends BaseValidator {
 *    protected override async = false;
 *    public validate(controlState: CrtControlState, params?: ValidatorParametersValues): CrtValidationErrors | null {
 *      Implementation here...
 *    }
 * }
 */
class BaseValidator {
    /**
     * @description getter for async/sync indicator
     */
    get isAsync() {
        return this.async;
    }
    /**
     * @description Function used for validation
     */
    get validateFn() {
        return this.validate.bind(this);
    }
    /**
     * @internal
     */
    static [Symbol.hasInstance](instance) {
        return instance?.constructor?.['_instanceOfKey'] === BaseValidator._instanceOfKey;
    }
}
/**
 * @internal
 * @dontChange
 */
BaseValidator._instanceOfKey = 'devkit_BaseValidator';

/**
 * @public
 */
class LocalizableValue {
    constructor(key) {
        this.key = key;
    }
    /**
     * @internal
     */
    static [Symbol.hasInstance](instance) {
        return instance?.constructor?.['_instanceOfKey'] === LocalizableValue._instanceOfKey;
    }
}
/**
 * @internal
 * @dontChange
 */
LocalizableValue._instanceOfKey = 'devkit_LocalizableValue';

/**
 * @internal
 */
function applyLocalizeMetadataFn(obj, localizeMetadata) {
    const localizableEntries = objectDeepKeys(obj)
        .map((path) => ({ path, value: get(obj, path) }))
        .filter(({ value }) => value instanceof LocalizableValue);
    if (localizableEntries.length === 0) {
        return obj;
    }
    const localized = cloneDeep(obj);
    if (!localizeMetadata) {
        console.error("Unable to localize metadata. 'localizeMetadata' bootstrap option was not provided.");
    }
    localizableEntries.forEach(({ path, value }) => {
        const localizedValue = localizeMetadata?.(value.key) ?? value.key;
        set(localized, path, localizedValue);
    });
    return localized;
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtDesignTimeViewElement(config) {
    return function (type) {
        const registrationConfig = {
            ...config,
            typeRef: type,
        };
        setDesignTimeViewElementMetadata(registrationConfig, type);
    };
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtRequest(config) {
    return function (type) {
        checkTypeNameFormat(config.type, 'RequestTypeName');
        checkCrtTypeNamePascalCase(config.type);
        RequestRegistryService.register(config, type);
    };
}

/**
 * @internal
 * @hostPublicApi
 */
class InterfaceDesignerItemRegistrationConfig {
}

/**
 * @internal
 * @class MethodInvokeRequest
 * @description Definition of invoke method request.
 * @extends {ɵBaseRequest} {@link ɵBaseRequest}
 * @property {string} method - method name.
 * @property {unknown[]} args - arguments passing to the method.
 */
class MethodInvokeRequest extends ɵBaseRequest {
}

/**
 * @internal
 */
var RemoteEntryType;
(function (RemoteEntryType) {
    RemoteEntryType["Script"] = "script";
    RemoteEntryType["Module"] = "module";
})(RemoteEntryType || (RemoteEntryType = {}));

/**
 * @public
 * @description Creatio platform interacts with input's of user-defined component through CrtInput decorator.
 * @param config {@link CrtInputRegistrationConfig}
 *
 * @example
 * export class AppComponent {
 *    @CrtInput()
 *    public value!: string;
 *  }
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtInput(config) {
    return function (target, propertyKey) {
        if (!config) {
            config = {
                propertyBindable: false,
            };
        }
        Reflect.defineMetadata(crtInputPrefix + propertyKey.toString(), config, target.constructor);
    };
}

/**
 * @public
 * @description User-defined components could notify Creatio platform about changes through CrtOutput decorator.
 * @example
 * export class AppComponent {
 *     @Input()
 *     @CrtOutput()
 *     public valueChange;
 *  }
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtOutput() {
    return function (target, propertyKey) {
        Reflect.defineMetadata(crtOutputPrefix + propertyKey.toString(), {}, target.constructor);
    };
}

/**
 * @public
 * @description User-defined components receive validationInfo changes through CrtValidationInput decorator.
 * Make sure you have defined input for every validationInfo input.
 * To properly declare validationInfo field:
 * 1. Declare input field inside inputs section. For example `value`
 * 2. In validationInputs section declare same field which ends with ValidationInfo.
 * For previous example `valueValidationInfo`
 *
 * @example
 * export class AppComponent {
 *      @CrtInput()
        public value;
 *
 *     	@CrtValidationInput()
 *      public valueValidationInfo;
 *  }
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtValidationInput() {
    return function (target, propertyKey) {
        Reflect.defineMetadata(crtValidationInputPrefix + propertyKey.toString(), {}, target.constructor);
    };
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtViewElement(config) {
    return function (type) {
        checkTypeNamePascalCase(config.type);
        const inputs = getCrtInputsMetadata(type);
        const outputs = getCrtOutputsMetadata(type);
        const validationInputs = getCrtValidationInputsMetadata(type);
        const baseRegistrationConfig = {
            ...config,
            inputs,
            outputs,
            validationInputs,
        };
        const registrationConfig = 'selector' in config
            ? { ...baseRegistrationConfig, selector: config.selector }
            : { ...baseRegistrationConfig, typeRef: type };
        setViewElementMetadata(registrationConfig, type);
    };
}

/**
 * @public
 * @description CrtModule decorator is a 'container' where user actually setup elements.
 * In could contain viewElements, definitions of other CrtModules.
 * @param moduleDefinition - {@link ModuleDefinition}
 *
 * @example
 *  @CrtModule({
 *      viewElements: [AppComponent],
 *      requestHandlers: [SomeRequestHandler],
 *      validators: [SomeValidator],
 *  })
 *  @NgModule({
 *      declarations: [AppComponent],
 *      imports: [BrowserModule],
 *      providers: [],
 *  })
 *  export class AppModule {}
 */
function CrtModule(moduleDefinition) {
    return (type) => setModuleMetadata(moduleDefinition, type);
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtInterfaceDesignerItem(config) {
    function _applyTypeCaption() {
        if (!config.typeCaption && config.toolbarConfig) {
            const toolbarConfig = Array.isArray(config.toolbarConfig)
                ? config.toolbarConfig[0]
                : config.toolbarConfig;
            config.typeCaption = toolbarConfig.caption;
        }
    }
    return function (type) {
        config.typeRef = type;
        config.viewElementGroupType ?? (config.viewElementGroupType = ViewElementGroupType.CustomElements);
        _applyTypeCaption();
        setInterfaceDesignerItemMetadata(config, type);
    };
}

/**
 * @public
 * @description
 * Constructor parameter decorator.
 * Mark parameter as dependency that should be obtained by token.
 * @param token - token by which the dependency instance will be obtained
 * @example
 * class MyHandler {
 * 	constructor(@CrtInject(USER_NAME_TOKEN) userName: string) {}
 * }
 */
function CrtInject(token) {
    return function (target, paramKey, paramIndex) {
        Reflect.defineMetadata(crtInjectPrefix + paramIndex, token, target);
    };
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtValidator(config) {
    if (!config) {
        return (type) => {
            // the decorator won't do anything by itself,
            // but will be used by the compiler to generate class metadata,
            // which is required for DI
        };
    }
    return function (type) {
        checkTypeNameFormat(config.type, 'ValidatorTypeName');
        const registrationConfig = {
            ...config,
            typeRef: type,
        };
        setValidatorMetadata(registrationConfig, type);
    };
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtRequestHandler(config) {
    if (!config) {
        return (type) => {
            // the decorator won't do anything by itself,
            // but will be used by the compiler to generate class metadata,
            // which is required for DI
        };
    }
    return function (type) {
        checkTypeNameFormat(config.type, 'RequestHandlerTypeName');
        checkCrtTypeNamePascalCase(config.type);
        setRequestHandlerMetadata(config, type);
    };
}

/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function CrtConverter(config) {
    if (!config) {
        return (type) => { };
    }
    return function (typeRef) {
        const type = typeof config === 'string' ? config : config.type;
        checkTypeNameFormat(type, 'converterTypeName');
        const registrationConfig = {
            type: type,
            typeRef: typeRef,
        };
        setConverterMetadata(registrationConfig, typeRef);
    };
}

/**
 * @internal
 */
var DataSourceLoadType;
(function (DataSourceLoadType) {
    DataSourceLoadType["LoadNext"] = "loadNext";
    DataSourceLoadType["Load"] = "load";
    DataSourceLoadType["Reload"] = "reload";
})(DataSourceLoadType || (DataSourceLoadType = {}));

/**
 * @public
 * @description Function allows to register user-defined component as view element in Creatio platform.
 * @param config - registration config. {@link ViewElementRegistrationConfig}
 * @example
 * sdk.registerViewElement({
 *      type: 'usr.Timeline',
 *      selector: 'usr-timeline',
 *      inputs: {
 *          primaryColumnValue: {},
 *          cardSchemaName: {},
 *          entitySchemaName: {}
 *      }
 * });
 */
function registerViewElement(config) {
    ViewElementRegistry.validate(config);
    ViewElementRegistry.register(config);
}

/**
 * @internal
 * @description Function allows to register angular component as view element in Creatio platform.
 */
function registerAngularViewElement(config, typeRef) {
    ViewElementRegistry.validate(config);
    ViewElementRegistry.register({
        ...config,
        typeRef,
    });
}

function checkRemoteName(remoteName) {
    if (!RemoteEntriesRegistry.items.has(remoteName)) {
        throw new Error(`Remote entry with name '${remoteName}' does not exist`);
    }
}
/**
 * @internal
 */
function resistantForEach(items, callback) {
    items.forEach((item) => {
        try {
            callback(item);
        }
        catch (error) {
            console.error(error);
        }
    });
}
/**
 * @internal
 */
function registerViewElements(types) {
    resistantForEach(types, (type) => {
        const registrationConfig = getViewElementMetadata(type);
        ViewElementRegistry.validate(registrationConfig);
        ViewElementRegistry.register(registrationConfig);
    });
}
/**
 * @internal
 */
function registerInterfaceDesignerItems(types, localizeFn) {
    resistantForEach(types, (type) => {
        if (!hasInterfaceDesignerItemMetadata(type)) {
            return;
        }
        let config = getInterfaceDesignerItemMetadata(type);
        config = applyLocalizeMetadataFn(config, localizeFn);
        const viewElementMetadata = getViewElementMetadata(type);
        config.type = viewElementMetadata.type;
        InterfaceDesignerItemRegistry.validate(config);
        InterfaceDesignerItemRegistry.register(config);
    });
}
/**
 * @internal
 */
function registerDesignTimeViewElements(types) {
    resistantForEach(types, (type) => {
        const registrationConfig = getDesignTimeViewElementMetadata(type);
        DesignTimeViewElementRegistry.validate(registrationConfig);
        DesignTimeViewElementRegistry.register(registrationConfig);
    });
}
/**
 * @internal
 */
function registerValidators(types, options) {
    resistantForEach(types, (type) => {
        const metadata = getValidatorMetadata(type);
        const registrationConfig = {
            ...metadata,
            instantiate: function (injectionContext) {
                const resolveDependency = options?.resolveDependency
                    ? (token) => options.resolveDependency(token, injectionContext)
                    : null;
                return instantiate(type, resolveDependency);
            },
        };
        ValidatorRegistry.validate(registrationConfig);
        ValidatorRegistry.register(registrationConfig);
    });
}
/**
 * @internal
 */
function registerConverters(types, options) {
    resistantForEach(types, (type) => {
        const metadata = getConverterMetadata(type);
        const registrationConfig = {
            ...metadata,
            instantiate: function (injectionContext) {
                const resolveDependency = options?.resolveDependency
                    ? (token) => options.resolveDependency(token, injectionContext)
                    : null;
                return instantiate(type, resolveDependency);
            },
        };
        ConverterRegistry.register(registrationConfig);
    });
}
/**
 * @internal
 */
function registerRequestHandlers(types, options, remoteName) {
    if (options.moduleType === 'remote' && !remoteName) {
        console.error("To use request handlers, 'remoteName' parameter should be specified.");
        return;
    }
    resistantForEach(types, (type) => {
        const metadata = getRequestHandlerMetadata(type);
        let registrationConfig;
        const createHandler = (injectionContext) => {
            const resolveDependency = options?.resolveDependency
                ? (token) => options.resolveDependency(token, injectionContext)
                : null;
            return instantiate(type, resolveDependency);
        };
        if (options.moduleType === 'host') {
            registrationConfig = {
                ...metadata,
                source: { type: HandlerSourceType.Host },
                createHandler,
            };
        }
        else {
            const remote = RemoteEntriesRegistry.items.get(remoteName);
            registrationConfig = {
                ...metadata,
                source: {
                    type: HandlerSourceType.Remote,
                    packageName: remote.packageName,
                },
                createHandler,
            };
        }
        RequestHandlerRegistryService.register(registrationConfig, type);
    });
}
function bootstrapDefaultCrtModule(name, type, options) {
    try {
        const moduleDefinition = getModuleMetadata(type);
        if (moduleDefinition.viewElements) {
            registerViewElements(moduleDefinition.viewElements);
            registerInterfaceDesignerItems(moduleDefinition.viewElements, options?.localizeMetadata);
        }
        if (moduleDefinition.designTimeViewElements) {
            registerDesignTimeViewElements(moduleDefinition.designTimeViewElements);
        }
        if (moduleDefinition.requestHandlers) {
            registerRequestHandlers(moduleDefinition.requestHandlers, options, name);
        }
        if (moduleDefinition.validators) {
            registerValidators(moduleDefinition.validators, options);
        }
        if (moduleDefinition.converters) {
            registerConverters(moduleDefinition.converters, options);
        }
        moduleDefinition.includes?.forEach((t) => {
            bootstrapDefaultCrtModule(name, t, options);
            bootstrapPredefinedModules(name, t, options);
        });
    }
    catch (error) {
        console.error(error);
    }
}
/**
 * @internal
 */
function bootstrapPredefinedModules(name, type, options) {
    const modulePrefix = 'module:';
    const metadataKeys = Reflect.getOwnMetadataKeys(type);
    for (const key of metadataKeys) {
        if (typeof key === 'string' && key.startsWith(modulePrefix)) {
            const moduleType = key.substring(modulePrefix.length);
            const predefinedBootstrapper = Reflect.getOwnMetadata('moduleBootstrapper:' + moduleType, type);
            try {
                predefinedBootstrapper(name, type, options);
            }
            catch (error) {
                console.error(error);
            }
        }
    }
}
/**
 * @internal
 */
function bootstrapCrtModule(...args) {
    const name = typeof args[0] === 'string' ? args.shift() : undefined;
    const type = args[0];
    const options = args[1] ?? {};
    options.moduleType ?? (options.moduleType = 'remote');
    if (name) {
        if (options.moduleType === 'remote') {
            checkRemoteName(name);
        }
        else {
            throw new Error('Host module cannot have name');
        }
    }
    bootstrapDefaultCrtModule(name, type, options);
    bootstrapPredefinedModules(name, type, options);
    if (options.moduleType === 'remote') {
        BootstrapNotifier.instance.notify(type);
    }
}

/**
 * @public
 * @description Use this function in decorators to indicate that a value should be localized.
 * Note that the "localizeMetadata" bootstrap option should be provided,
 * otherwise the value cannot be localized.
 *
 * @example
 *
 * ### Using 'localize' in decorator
 * ```ts
 * @CrtInterfaceDesignerItem({
 *    toolbarConfig: {
 *      caption: localize('MyElement.Caption')
 * 	  }
 * })
 * class MyElement {}
 * ```
 * ### Passing 'localizeMetadata' bootstrap option
 * ```ts
 * bootstrapCrtModule(MyModule, {
 *    localizeMetadata: (key: string) => thirdPartyTranslateService.translate(key)
 * });
 * ```
 */
function localize(key) {
    return new LocalizableValue(key);
}

/**
 * @internal
 */
function registerHandlerChainServices(types) {
    types?.forEach((type) => {
        const registrationConfig = getHandlerChainServiceMetadata(type);
        HandlerChainServicesRegistry.register(registrationConfig);
    });
}
/**
 * @internal
 */
function _bootstrapCrtModuleHandlerChainServices(type) {
    const moduleDefinition = getModuleMetadata(type);
    if (moduleDefinition.handlerChainServices) {
        registerHandlerChainServices(moduleDefinition.handlerChainServices);
    }
    moduleDefinition.includes?.forEach((t) => _bootstrapCrtModuleHandlerChainServices(t));
}
/**
 * @internal
 */
function bootstrapCrtModuleHandlerChainServices(type) {
    _bootstrapCrtModuleHandlerChainServices(type);
}

/**
 * @public
 * @abstract
 * @classdesc Class for designing request handlers.
 */
class BaseRequestHandler {
    constructor() {
        this.handlerChain = HandlerChainService.instance;
    }
    get next() {
        return this._next;
    }
    /**
     * @internal
     */
    static [Symbol.hasInstance](instance) {
        return instance?.constructor?.['_instanceOfKey'] === BaseRequestHandler._instanceOfKey;
    }
    /**
     * @description Method to set request handler to handler chain.
     * @param next - link for next request handler - {@link ɵRequestHandler}
     */
    setNext(next) {
        if (this._next) {
            throw new ɵNextHandlerAlreadySpecifiedException();
        }
        this._next = next;
    }
}
/**
 * @internal
 * @dontChange
 */
BaseRequestHandler._instanceOfKey = 'devkit_BaseRequestHandler';

class BaseHandlerChainService {
}

/**
 * @public
 * @classdesc Service to working with Creatio platform features using handler chain
 * @extends {BaseHandlerChainService}
 */
class FeatureService extends BaseHandlerChainService {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.requestType = 'crt.FeatureService';
    }
}
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], FeatureService.prototype, "getFeatureState", void 0);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], FeatureService.prototype, "getFeaturesState", void 0);

/**
 * @public
 * @classdesc Service to working rights using handler chain
 * @extends {BaseHandlerChainService}
 */
class RightsService extends BaseHandlerChainService {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.requestType = 'crt.RightsService';
    }
}
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], RightsService.prototype, "getCanExecuteOperation", void 0);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], RightsService.prototype, "getCanExecuteOperations", void 0);

/**
 * @public
 * @class SysSettingsService
 * @classdesc Service to working with system settings using handler chain
 * @extends {BaseHandlerChainService}
 */
// TODO RND-45286 (implement BaseSysSettingsService)
class SysSettingsService extends BaseHandlerChainService {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.requestType = 'crt.SysSettingsService';
    }
}
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], SysSettingsService.prototype, "getByCodes", void 0);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], SysSettingsService.prototype, "getByCode", void 0);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], SysSettingsService.prototype, "update", void 0);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], SysSettingsService.prototype, "updateMany", void 0);

/**
 * @public
 * @class SysSetting
 * @classdesc Class contains info related system setting
 * @property {ɵGuid} id - id of system setting.
 * @property {string} name - name of system setting.
 * @property {string} code - code of system setting.
 * @property {isCacheable} boolean - indicator whether system setting is cacheable
 * @property {any} value - value of system setting
 * @property {string} displayValue - display value of system setting
 * @property {ɵDataValueType} ɵDataValueType - system setting {@link ɵDataValueType}
 */
class SysSetting {
}
/**
 * @public
 * @class SysSettingValue
 * @classdesc Shape to describe system setting value
 * @property {string} code - code of system setting
 * @property {any} value - value of system setting
 */
class SysSettingValue {
}

/**
 * @public
 * @classdesc
 * @class SysValuesService  Service to working with system values using handler chain
 * @extends {BaseHandlerChainService}
 */
class SysValuesService extends BaseHandlerChainService {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.requestType = 'crt.SysValuesService';
    }
}
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], SysValuesService.prototype, "loadSysValues", void 0);

/**
 * @public
 * @classdesc Http service to perform Http requests
 * @extends {BaseHandlerChainService}
 */
class HttpClientService extends BaseHandlerChainService {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.requestType = 'crt.HttpClientService';
    }
    /**
     * @description HTTP GET request.
     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}
     */
    get() {
        // the method will be implemented dynamically by the decorator
    }
    /**
     * @description HTTP POST request.
     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}
     */
    post() {
        // the method will be implemented dynamically by the decorator
    }
    /**
     * @description HTTP DELETE request.
     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}
     */
    delete() {
        // the method will be implemented dynamically by the decorator
    }
    /**
     * @description HTTP PUT request.
     * @return `Promise<HttpResponse> | void``  {(Promise<HttpResponse> | void)}
     */
    put() {
        // the method will be implemented dynamically by the decorator
    }
    /**
     * @description HTTP PATCH request.
     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}
     */
    patch() {
        // the method will be implemented dynamically by the decorator
    }
}
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], HttpClientService.prototype, "get", null);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], HttpClientService.prototype, "post", null);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], HttpClientService.prototype, "delete", null);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], HttpClientService.prototype, "put", null);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], HttpClientService.prototype, "patch", null);

/**
 * @internal
 */
var SchemaViewMaskRequestAction;
(function (SchemaViewMaskRequestAction) {
    SchemaViewMaskRequestAction["AddTask"] = "addTask";
    SchemaViewMaskRequestAction["RemoveTask"] = "removeTask";
})(SchemaViewMaskRequestAction || (SchemaViewMaskRequestAction = {}));
/**
 * @internal
 */
class SchemaViewMaskRequest extends ɵBaseRequest {
    constructor(action, taskName, $context) {
        super();
        this.action = action;
        this.taskName = taskName;
        this.$context = $context;
        this.type = 'crt.SchemaViewMaskRequest';
    }
}

/**
 * @public
 * @classdesc Service to working with mask using handler chain
 * @extends {BaseHandlerChainService}
 */
class MaskService extends BaseHandlerChainService {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.requestType = 'crt.MaskService';
    }
    /**
     * @internal
     * @param taskName
     * @param context
     */
    async showMask(taskName, context) {
        const request = new SchemaViewMaskRequest(SchemaViewMaskRequestAction.AddTask, taskName, context);
        await HandlerChainService.instance.process(request);
    }
    /**
     * @internal
     * @param taskName
     * @param context
     */
    async hideMask(taskName, context) {
        const request = new SchemaViewMaskRequest(SchemaViewMaskRequestAction.RemoveTask, taskName, context);
        await HandlerChainService.instance.process(request);
    }
}
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], MaskService.prototype, "showBodyMask", void 0);
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], MaskService.prototype, "hideBodyMask", void 0);

/**
 * @internal
 */
const _from = Symbol('CreateModelFrom');
/**
 * @public
 */
class Model extends BaseHandlerChainService {
    constructor(crtModel) {
        super();
        /**
         * @internal
         */
        this.requestType = 'crt.ModelGenerator';
        this._crtModel = crtModel;
    }
    static get instance() {
        if (!this._instance) {
            this._instance = new Model();
        }
        return this._instance;
    }
    /**
     * @internal
     * Gets the model name.
     */
    get name() {
        return this._crtModel?.name;
    }
    /**
     * @internal
     */
    static [_from](crtModel) {
        return new Model(crtModel);
    }
    static async create(dataSchema) {
        const crtModel = await this.instance._create({
            type: 'crt.EntityDataSource',
            config: {
                entitySchemaName: dataSchema,
            },
        }, '');
        return new Model(crtModel);
    }
    getSchema() {
        return this._crtModel._getAsyncResult(this._crtModel.getSchema());
    }
    load(config) {
        return this._crtModel._getAsyncResult(this._crtModel.load(config));
    }
    insert(dto) {
        return this._crtModel._getAsyncResult(this._crtModel.insert(dto));
    }
    update(dto, parameters) {
        return this._crtModel._getAsyncResult(this._crtModel.update(dto, parameters));
    }
    copy(primaryColumnValue, data = {}) {
        return this._crtModel._getAsyncResult(this._crtModel.copy(primaryColumnValue, data));
    }
    create(data = {}) {
        return this._crtModel._getAsyncResult(this._crtModel.create(data));
    }
    delete(parameters) {
        return this._crtModel._getAsyncResult(this._crtModel.delete(parameters));
    }
    canSave(params) {
        return this._crtModel._getAsyncResult(this._crtModel.canSave(params));
    }
    canDelete(params) {
        return this._crtModel._getAsyncResult(this._crtModel.canDelete(params));
    }
}
__decorate([
    ImplementUsingHandlerChain({
        methodName: 'generateOne',
    }),
    __metadata("design:type", Function)
], Model.prototype, "_create", void 0);

/**
 * @public
 * @classdesc Service to handling a way of tasks execution in Creatio plaform
 * @extends {BaseHandlerChainService}
 */
class CrtZoneService extends BaseHandlerChainService {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.requestType = 'crt.ZoneService';
    }
}
__decorate([
    ImplementUsingHandlerChain(),
    __metadata("design:type", Function)
], CrtZoneService.prototype, "runOutside", void 0);

/**
 * Generated bundle index. Do not edit.
 */

export { BaseRequestHandler, BaseValidator, BootstrapNotifier, ConverterRegistry, CrtConverter, CrtDesignTimeViewElement, CrtInject, CrtInput, CrtInputRegistrationConfig, CrtInterfaceDesignerItem, CrtModule, CrtOutput, CrtRequest, CrtRequestHandler, CrtValidationInput, CrtValidator, CrtViewElement, CrtZoneService, DataRequest, DataSourceLoadType, DesignTimeViewElementRegistry, DesignerToolGroupType, FeatureService, HandlerChainService, HandlerChainServicesRegistry, HandlerSourceType, HandlersOrderComparer, HttpClientService, ImplementUsingHandlerChain, InterfaceDesignerItemRegistrationConfig, InterfaceDesignerItemRegistry, InternalRequestHandlerRegistry, InternalRequestHandlerRegistryType, LocalizableValue, MaskService, MethodInvokeRequest, Model, ModelInPageAction, PkgTopology, RemoteEntriesRegistry, RemoteEntryType, RequestHandlerRegistryService, RequestRegistryService, RightsService, SchemaViewMaskRequest, SchemaViewMaskRequestAction, SysSetting, SysSettingValue, SysSettingsService, SysValuesService, ValidatorMapValue, ValidatorRegistry, ViewElementDataGroupType, ViewElementGroupType, ViewElementRegistry, ViewElementReuseStrategy, _from, applyLocalizeMetadataFn, bootstrapCrtModule, bootstrapCrtModuleHandlerChainServices, checkCrtTypeNamePascalCase, checkIfTypeRegistered, checkOnlyOneRegistration, checkTypeNameFormat, checkTypeNamePascalCase, crtInjectPrefix, crtInputPrefix, crtOutputPrefix, crtValidationInputPrefix, designTimeViewElementRegistryKey, getConverterMetadata, getCrtInputsMetadata, getCrtOutputsMetadata, getCrtValidationInputsMetadata, getDesignTimeViewElementMetadata, getHandlerChainServiceMetadata, getInterfaceDesignerItemMetadata, getModuleMetadata, getRequestHandlerMetadata, getTypeDependencies, getValidatorMetadata, getViewElementMetadata, hasInterfaceDesignerItemMetadata, instantiate, interfaceDesignerItemRegistryKey, isComponentPropertyBindable, localize, objectDeepKeys, registerAngularViewElement, registerViewElement, setConverterMetadata, setDesignTimeViewElementMetadata, setInterfaceDesignerItemMetadata, setModuleMetadata, setRequestHandlerMetadata, setValidatorMetadata, setViewElementMetadata, toAggregationEval, toAggregationEvalType, toAggregationFunction, toAggregationType, toDatePart, toDatePartType, toNumericFunctionType, toOrderDirection, toPascalCase, toSortDirection, toStringFunctionType, validatorRegistryKey, viewElementRegistryKey, ɵBaseRegistry, ɵcheckTypeNameFormat, ɵinstantiate };
//# sourceMappingURL=creatio-devkit-common.mjs.map
