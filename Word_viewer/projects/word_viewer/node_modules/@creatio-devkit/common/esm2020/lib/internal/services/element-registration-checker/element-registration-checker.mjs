import { camelCase, isEqual, upperFirst } from 'lodash';
/**
 * @internal
 */
export function checkTypeNameFormat(type, element) {
    const typeParts = type.split('.');
    if (typeParts.length < 2) {
        throw new Error(`Error when register ${type}. Type property should have format "VendorPrefix.${element}"`);
    }
}
/**
 * @public
 * @description For internal use only.
 */
export function ÉµcheckTypeNameFormat(type, element) {
    return checkTypeNameFormat(type, element);
}
/**
 * @internal
 */
export function checkTypeNamePascalCase(type) {
    const [vendor, typeName] = type.split('.');
    const pascalTypeName = toPascalCase(typeName);
    if (!vendor || pascalTypeName !== typeName) {
        throw new Error(`Error when register ${type}. Type property should have Pascal case, e.g. ${vendor + '.' + pascalTypeName}. ` + 'The first letter of each word in a compound word should be capitalized');
    }
}
/**
 * @internal
 */
export function checkCrtTypeNamePascalCase(type) {
    const [vendor, typeName] = type.split('.');
    const pascalTypeName = toPascalCase(typeName);
    if (vendor.toLowerCase() === 'crt' && pascalTypeName !== typeName) {
        throw new Error(`Error when register ${type}. Type property should have Pascal case, e.g. ${vendor + '.' + pascalTypeName}. ` + 'The first letter of each word in a compound word should be capitalized');
    }
}
/**
 * @internal
 */
export function toPascalCase(source) {
    return upperFirst(camelCase(source));
}
/**
 * @internal
 */
export function checkIfTypeRegistered(type, item) {
    if (!item) {
        throw new Error(`Error when resolve ${type}. Type was not registered.`);
    }
}
/**
 * @internal
 */
export function checkOnlyOneRegistration(type, item, map) {
    if (map.has(type) && !isEqual(map.get(type), item)) {
        throw new Error(`Error when register ${type}. Element with this type has already exist`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxlbWVudC1yZWdpc3RyYXRpb24tY2hlY2tlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvZGV2a2l0L2NvbW1vbi9zcmMvbGliL2ludGVybmFsL3NlcnZpY2VzL2VsZW1lbnQtcmVnaXN0cmF0aW9uLWNoZWNrZXIvZWxlbWVudC1yZWdpc3RyYXRpb24tY2hlY2tlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFeEQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsSUFBWSxFQUFFLE9BQWU7SUFDaEUsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLElBQUksb0RBQW9ELE9BQU8sR0FBRyxDQUFDLENBQUM7S0FDM0c7QUFDRixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUFDLElBQVksRUFBRSxPQUFlO0lBQ2pFLE9BQU8sbUJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxJQUFZO0lBQ25ELE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzQyxNQUFNLGNBQWMsR0FBRyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDOUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxjQUFjLEtBQUssUUFBUSxFQUFFO1FBQzNDLE1BQU0sSUFBSSxLQUFLLENBQ2QsdUJBQXVCLElBQUksaURBQzFCLE1BQU0sR0FBRyxHQUFHLEdBQUcsY0FDaEIsSUFBSSxHQUFHLHdFQUF3RSxDQUMvRSxDQUFDO0tBQ0Y7QUFDRixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsMEJBQTBCLENBQUMsSUFBWTtJQUN0RCxNQUFNLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDM0MsTUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzlDLElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRSxLQUFLLEtBQUssSUFBSSxjQUFjLEtBQUssUUFBUSxFQUFFO1FBQ2xFLE1BQU0sSUFBSSxLQUFLLENBQ2QsdUJBQXVCLElBQUksaURBQzFCLE1BQU0sR0FBRyxHQUFHLEdBQUcsY0FDaEIsSUFBSSxHQUFHLHdFQUF3RSxDQUMvRSxDQUFDO0tBQ0Y7QUFDRixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUFDLE1BQWM7SUFDMUMsT0FBTyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDdEMsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUNwQyxJQUFZLEVBQ1osSUFBc0M7SUFFdEMsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLElBQUksNEJBQTRCLENBQUMsQ0FBQztLQUN4RTtBQUNGLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FBSSxJQUFZLEVBQUUsSUFBTyxFQUFFLEdBQW1CO0lBQ3JGLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ25ELE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLElBQUksNENBQTRDLENBQUMsQ0FBQztLQUN6RjtBQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYW1lbENhc2UsIGlzRXF1YWwsIHVwcGVyRmlyc3QgfSBmcm9tICdsb2Rhc2gnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tUeXBlTmFtZUZvcm1hdCh0eXBlOiBzdHJpbmcsIGVsZW1lbnQ6IHN0cmluZyk6IHZvaWQge1xuXHRjb25zdCB0eXBlUGFydHMgPSB0eXBlLnNwbGl0KCcuJyk7XG5cdGlmICh0eXBlUGFydHMubGVuZ3RoIDwgMikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hlbiByZWdpc3RlciAke3R5cGV9LiBUeXBlIHByb3BlcnR5IHNob3VsZCBoYXZlIGZvcm1hdCBcIlZlbmRvclByZWZpeC4ke2VsZW1lbnR9XCJgKTtcblx0fVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqIEBkZXNjcmlwdGlvbiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtWNoZWNrVHlwZU5hbWVGb3JtYXQodHlwZTogc3RyaW5nLCBlbGVtZW50OiBzdHJpbmcpOiB2b2lkIHtcblx0cmV0dXJuIGNoZWNrVHlwZU5hbWVGb3JtYXQodHlwZSwgZWxlbWVudCk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1R5cGVOYW1lUGFzY2FsQ2FzZSh0eXBlOiBzdHJpbmcpOiB2b2lkIHtcblx0Y29uc3QgW3ZlbmRvciwgdHlwZU5hbWVdID0gdHlwZS5zcGxpdCgnLicpO1xuXHRjb25zdCBwYXNjYWxUeXBlTmFtZSA9IHRvUGFzY2FsQ2FzZSh0eXBlTmFtZSk7XG5cdGlmICghdmVuZG9yIHx8IHBhc2NhbFR5cGVOYW1lICE9PSB0eXBlTmFtZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGBFcnJvciB3aGVuIHJlZ2lzdGVyICR7dHlwZX0uIFR5cGUgcHJvcGVydHkgc2hvdWxkIGhhdmUgUGFzY2FsIGNhc2UsIGUuZy4gJHtcblx0XHRcdFx0dmVuZG9yICsgJy4nICsgcGFzY2FsVHlwZU5hbWVcblx0XHRcdH0uIGAgKyAnVGhlIGZpcnN0IGxldHRlciBvZiBlYWNoIHdvcmQgaW4gYSBjb21wb3VuZCB3b3JkIHNob3VsZCBiZSBjYXBpdGFsaXplZCcsXG5cdFx0KTtcblx0fVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tDcnRUeXBlTmFtZVBhc2NhbENhc2UodHlwZTogc3RyaW5nKTogdm9pZCB7XG5cdGNvbnN0IFt2ZW5kb3IsIHR5cGVOYW1lXSA9IHR5cGUuc3BsaXQoJy4nKTtcblx0Y29uc3QgcGFzY2FsVHlwZU5hbWUgPSB0b1Bhc2NhbENhc2UodHlwZU5hbWUpO1xuXHRpZiAodmVuZG9yLnRvTG93ZXJDYXNlKCkgPT09ICdjcnQnICYmIHBhc2NhbFR5cGVOYW1lICE9PSB0eXBlTmFtZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGBFcnJvciB3aGVuIHJlZ2lzdGVyICR7dHlwZX0uIFR5cGUgcHJvcGVydHkgc2hvdWxkIGhhdmUgUGFzY2FsIGNhc2UsIGUuZy4gJHtcblx0XHRcdFx0dmVuZG9yICsgJy4nICsgcGFzY2FsVHlwZU5hbWVcblx0XHRcdH0uIGAgKyAnVGhlIGZpcnN0IGxldHRlciBvZiBlYWNoIHdvcmQgaW4gYSBjb21wb3VuZCB3b3JkIHNob3VsZCBiZSBjYXBpdGFsaXplZCcsXG5cdFx0KTtcblx0fVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QYXNjYWxDYXNlKHNvdXJjZTogc3RyaW5nKTogc3RyaW5nIHtcblx0cmV0dXJuIHVwcGVyRmlyc3QoY2FtZWxDYXNlKHNvdXJjZSkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJZlR5cGVSZWdpc3RlcmVkPFQ+KFxuXHR0eXBlOiBzdHJpbmcsXG5cdGl0ZW06IChuZXcgKCkgPT4gVCkgfCB1bmRlZmluZWQgfCBudWxsLFxuKTogYXNzZXJ0cyBpdGVtIGlzIG5ldyAoKSA9PiBUIHtcblx0aWYgKCFpdGVtKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGVuIHJlc29sdmUgJHt0eXBlfS4gVHlwZSB3YXMgbm90IHJlZ2lzdGVyZWQuYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT25seU9uZVJlZ2lzdHJhdGlvbjxUPih0eXBlOiBzdHJpbmcsIGl0ZW06IFQsIG1hcDogTWFwPHN0cmluZywgVD4pOiB2b2lkIHtcblx0aWYgKG1hcC5oYXModHlwZSkgJiYgIWlzRXF1YWwobWFwLmdldCh0eXBlKSwgaXRlbSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoZW4gcmVnaXN0ZXIgJHt0eXBlfS4gRWxlbWVudCB3aXRoIHRoaXMgdHlwZSBoYXMgYWxyZWFkeSBleGlzdGApO1xuXHR9XG59XG4iXX0=