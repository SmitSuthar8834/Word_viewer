{"ast":null,"code":"var _ = require(\"underscore\");\nvar promises = require(\"./promises\");\nvar documents = require(\"./documents\");\nvar htmlPaths = require(\"./styles/html-paths\");\nvar results = require(\"./results\");\nvar images = require(\"./images\");\nvar Html = require(\"./html\");\nvar writers = require(\"./writers\");\nexports.DocumentConverter = DocumentConverter;\nfunction DocumentConverter(options) {\n  return {\n    convertToHtml: function (element) {\n      var comments = _.indexBy(element.type === documents.types.document ? element.comments : [], \"commentId\");\n      var conversion = new DocumentConversion(options, comments);\n      return conversion.convertToHtml(element);\n    }\n  };\n}\nfunction DocumentConversion(options, comments) {\n  var noteNumber = 1;\n  var noteReferences = [];\n  var referencedComments = [];\n  options = _.extend({\n    ignoreEmptyParagraphs: true\n  }, options);\n  var idPrefix = options.idPrefix === undefined ? \"\" : options.idPrefix;\n  var ignoreEmptyParagraphs = options.ignoreEmptyParagraphs;\n  var defaultParagraphStyle = htmlPaths.topLevelElement(\"p\");\n  var styleMap = options.styleMap || [];\n  function convertToHtml(document) {\n    var messages = [];\n    var html = elementToHtml(document, messages, {});\n    var deferredNodes = [];\n    walkHtml(html, function (node) {\n      if (node.type === \"deferred\") {\n        deferredNodes.push(node);\n      }\n    });\n    var deferredValues = {};\n    return promises.mapSeries(deferredNodes, function (deferred) {\n      return deferred.value().then(function (value) {\n        deferredValues[deferred.id] = value;\n      });\n    }).then(function () {\n      function replaceDeferred(nodes) {\n        return flatMap(nodes, function (node) {\n          if (node.type === \"deferred\") {\n            return deferredValues[node.id];\n          } else if (node.children) {\n            return [_.extend({}, node, {\n              children: replaceDeferred(node.children)\n            })];\n          } else {\n            return [node];\n          }\n        });\n      }\n      var writer = writers.writer({\n        prettyPrint: options.prettyPrint,\n        outputFormat: options.outputFormat\n      });\n      Html.write(writer, Html.simplify(replaceDeferred(html)));\n      return new results.Result(writer.asString(), messages);\n    });\n  }\n  function convertElements(elements, messages, options) {\n    return flatMap(elements, function (element) {\n      return elementToHtml(element, messages, options);\n    });\n  }\n  function elementToHtml(element, messages, options) {\n    if (!options) {\n      throw new Error(\"options not set\");\n    }\n    var handler = elementConverters[element.type];\n    if (handler) {\n      return handler(element, messages, options);\n    } else {\n      return [];\n    }\n  }\n  function convertParagraph(element, messages, options) {\n    return htmlPathForParagraph(element, messages).wrap(function () {\n      var content = convertElements(element.children, messages, options);\n      if (ignoreEmptyParagraphs) {\n        return content;\n      } else {\n        return [Html.forceWrite].concat(content);\n      }\n    });\n  }\n  function htmlPathForParagraph(element, messages) {\n    var style = findStyle(element);\n    if (style) {\n      return style.to;\n    } else {\n      if (element.styleId) {\n        messages.push(unrecognisedStyleWarning(\"paragraph\", element));\n      }\n      return defaultParagraphStyle;\n    }\n  }\n  function convertRun(run, messages, options) {\n    var nodes = function () {\n      return convertElements(run.children, messages, options);\n    };\n    var paths = [];\n    if (run.highlight !== null) {\n      var path = findHtmlPath({\n        type: \"highlight\",\n        color: run.highlight\n      });\n      if (path) {\n        paths.push(path);\n      }\n    }\n    if (run.isSmallCaps) {\n      paths.push(findHtmlPathForRunProperty(\"smallCaps\"));\n    }\n    if (run.isAllCaps) {\n      paths.push(findHtmlPathForRunProperty(\"allCaps\"));\n    }\n    if (run.isStrikethrough) {\n      paths.push(findHtmlPathForRunProperty(\"strikethrough\", \"s\"));\n    }\n    if (run.isUnderline) {\n      paths.push(findHtmlPathForRunProperty(\"underline\"));\n    }\n    if (run.verticalAlignment === documents.verticalAlignment.subscript) {\n      paths.push(htmlPaths.element(\"sub\", {}, {\n        fresh: false\n      }));\n    }\n    if (run.verticalAlignment === documents.verticalAlignment.superscript) {\n      paths.push(htmlPaths.element(\"sup\", {}, {\n        fresh: false\n      }));\n    }\n    if (run.isItalic) {\n      paths.push(findHtmlPathForRunProperty(\"italic\", \"em\"));\n    }\n    if (run.isBold) {\n      paths.push(findHtmlPathForRunProperty(\"bold\", \"strong\"));\n    }\n    var stylePath = htmlPaths.empty;\n    var style = findStyle(run);\n    if (style) {\n      stylePath = style.to;\n    } else if (run.styleId) {\n      messages.push(unrecognisedStyleWarning(\"run\", run));\n    }\n    paths.push(stylePath);\n    paths.forEach(function (path) {\n      nodes = path.wrap.bind(path, nodes);\n    });\n    return nodes();\n  }\n  function findHtmlPathForRunProperty(elementType, defaultTagName) {\n    var path = findHtmlPath({\n      type: elementType\n    });\n    if (path) {\n      return path;\n    } else if (defaultTagName) {\n      return htmlPaths.element(defaultTagName, {}, {\n        fresh: false\n      });\n    } else {\n      return htmlPaths.empty;\n    }\n  }\n  function findHtmlPath(element, defaultPath) {\n    var style = findStyle(element);\n    return style ? style.to : defaultPath;\n  }\n  function findStyle(element) {\n    for (var i = 0; i < styleMap.length; i++) {\n      if (styleMap[i].from.matches(element)) {\n        return styleMap[i];\n      }\n    }\n  }\n  function recoveringConvertImage(convertImage) {\n    return function (image, messages) {\n      return promises.attempt(function () {\n        return convertImage(image, messages);\n      }).caught(function (error) {\n        messages.push(results.error(error));\n        return [];\n      });\n    };\n  }\n  function noteHtmlId(note) {\n    return referentHtmlId(note.noteType, note.noteId);\n  }\n  function noteRefHtmlId(note) {\n    return referenceHtmlId(note.noteType, note.noteId);\n  }\n  function referentHtmlId(referenceType, referenceId) {\n    return htmlId(referenceType + \"-\" + referenceId);\n  }\n  function referenceHtmlId(referenceType, referenceId) {\n    return htmlId(referenceType + \"-ref-\" + referenceId);\n  }\n  function htmlId(suffix) {\n    return idPrefix + suffix;\n  }\n  var defaultTablePath = htmlPaths.elements([htmlPaths.element(\"table\", {}, {\n    fresh: true\n  })]);\n  function convertTable(element, messages, options) {\n    return findHtmlPath(element, defaultTablePath).wrap(function () {\n      return convertTableChildren(element, messages, options);\n    });\n  }\n  function convertTableChildren(element, messages, options) {\n    var bodyIndex = _.findIndex(element.children, function (child) {\n      return !child.type === documents.types.tableRow || !child.isHeader;\n    });\n    if (bodyIndex === -1) {\n      bodyIndex = element.children.length;\n    }\n    var children;\n    if (bodyIndex === 0) {\n      children = convertElements(element.children, messages, _.extend({}, options, {\n        isTableHeader: false\n      }));\n    } else {\n      var headRows = convertElements(element.children.slice(0, bodyIndex), messages, _.extend({}, options, {\n        isTableHeader: true\n      }));\n      var bodyRows = convertElements(element.children.slice(bodyIndex), messages, _.extend({}, options, {\n        isTableHeader: false\n      }));\n      children = [Html.freshElement(\"thead\", {}, headRows), Html.freshElement(\"tbody\", {}, bodyRows)];\n    }\n    return [Html.forceWrite].concat(children);\n  }\n  function convertTableRow(element, messages, options) {\n    var children = convertElements(element.children, messages, options);\n    return [Html.freshElement(\"tr\", {}, [Html.forceWrite].concat(children))];\n  }\n  function convertTableCell(element, messages, options) {\n    var tagName = options.isTableHeader ? \"th\" : \"td\";\n    var children = convertElements(element.children, messages, options);\n    var attributes = {};\n    if (element.colSpan !== 1) {\n      attributes.colspan = element.colSpan.toString();\n    }\n    if (element.rowSpan !== 1) {\n      attributes.rowspan = element.rowSpan.toString();\n    }\n    return [Html.freshElement(tagName, attributes, [Html.forceWrite].concat(children))];\n  }\n  function convertCommentReference(reference, messages, options) {\n    return findHtmlPath(reference, htmlPaths.ignore).wrap(function () {\n      var comment = comments[reference.commentId];\n      var count = referencedComments.length + 1;\n      var label = \"[\" + commentAuthorLabel(comment) + count + \"]\";\n      referencedComments.push({\n        label: label,\n        comment: comment\n      });\n      // TODO: remove duplication with note references\n      return [Html.freshElement(\"a\", {\n        href: \"#\" + referentHtmlId(\"comment\", reference.commentId),\n        id: referenceHtmlId(\"comment\", reference.commentId)\n      }, [Html.text(label)])];\n    });\n  }\n  function convertComment(referencedComment, messages, options) {\n    // TODO: remove duplication with note references\n\n    var label = referencedComment.label;\n    var comment = referencedComment.comment;\n    var body = convertElements(comment.body, messages, options).concat([Html.nonFreshElement(\"p\", {}, [Html.text(\" \"), Html.freshElement(\"a\", {\n      \"href\": \"#\" + referenceHtmlId(\"comment\", comment.commentId)\n    }, [Html.text(\"↑\")])])]);\n    return [Html.freshElement(\"dt\", {\n      \"id\": referentHtmlId(\"comment\", comment.commentId)\n    }, [Html.text(\"Comment \" + label)]), Html.freshElement(\"dd\", {}, body)];\n  }\n  function convertBreak(element, messages, options) {\n    return htmlPathForBreak(element).wrap(function () {\n      return [];\n    });\n  }\n  function htmlPathForBreak(element) {\n    var style = findStyle(element);\n    if (style) {\n      return style.to;\n    } else if (element.breakType === \"line\") {\n      return htmlPaths.topLevelElement(\"br\");\n    } else {\n      return htmlPaths.empty;\n    }\n  }\n  var elementConverters = {\n    \"document\": function (document, messages, options) {\n      var children = convertElements(document.children, messages, options);\n      var notes = noteReferences.map(function (noteReference) {\n        return document.notes.resolve(noteReference);\n      });\n      var notesNodes = convertElements(notes, messages, options);\n      return children.concat([Html.freshElement(\"ol\", {}, notesNodes), Html.freshElement(\"dl\", {}, flatMap(referencedComments, function (referencedComment) {\n        return convertComment(referencedComment, messages, options);\n      }))]);\n    },\n    \"paragraph\": convertParagraph,\n    \"run\": convertRun,\n    \"text\": function (element, messages, options) {\n      return [Html.text(element.value)];\n    },\n    \"tab\": function (element, messages, options) {\n      return [Html.text(\"\\t\")];\n    },\n    \"hyperlink\": function (element, messages, options) {\n      var href = element.anchor ? \"#\" + htmlId(element.anchor) : element.href;\n      var attributes = {\n        href: href\n      };\n      if (element.targetFrame != null) {\n        attributes.target = element.targetFrame;\n      }\n      var children = convertElements(element.children, messages, options);\n      return [Html.nonFreshElement(\"a\", attributes, children)];\n    },\n    \"checkbox\": function (element) {\n      var attributes = {\n        type: \"checkbox\"\n      };\n      if (element.checked) {\n        attributes[\"checked\"] = \"checked\";\n      }\n      return [Html.freshElement(\"input\", attributes)];\n    },\n    \"bookmarkStart\": function (element, messages, options) {\n      var anchor = Html.freshElement(\"a\", {\n        id: htmlId(element.name)\n      }, [Html.forceWrite]);\n      return [anchor];\n    },\n    \"noteReference\": function (element, messages, options) {\n      noteReferences.push(element);\n      var anchor = Html.freshElement(\"a\", {\n        href: \"#\" + noteHtmlId(element),\n        id: noteRefHtmlId(element)\n      }, [Html.text(\"[\" + noteNumber++ + \"]\")]);\n      return [Html.freshElement(\"sup\", {}, [anchor])];\n    },\n    \"note\": function (element, messages, options) {\n      var children = convertElements(element.body, messages, options);\n      var backLink = Html.elementWithTag(htmlPaths.element(\"p\", {}, {\n        fresh: false\n      }), [Html.text(\" \"), Html.freshElement(\"a\", {\n        href: \"#\" + noteRefHtmlId(element)\n      }, [Html.text(\"↑\")])]);\n      var body = children.concat([backLink]);\n      return Html.freshElement(\"li\", {\n        id: noteHtmlId(element)\n      }, body);\n    },\n    \"commentReference\": convertCommentReference,\n    \"comment\": convertComment,\n    \"image\": deferredConversion(recoveringConvertImage(options.convertImage || images.dataUri)),\n    \"table\": convertTable,\n    \"tableRow\": convertTableRow,\n    \"tableCell\": convertTableCell,\n    \"break\": convertBreak\n  };\n  return {\n    convertToHtml: convertToHtml\n  };\n}\nvar deferredId = 1;\nfunction deferredConversion(func) {\n  return function (element, messages, options) {\n    return [{\n      type: \"deferred\",\n      id: deferredId++,\n      value: function () {\n        return func(element, messages, options);\n      }\n    }];\n  };\n}\nfunction unrecognisedStyleWarning(type, element) {\n  return results.warning(\"Unrecognised \" + type + \" style: '\" + element.styleName + \"'\" + \" (Style ID: \" + element.styleId + \")\");\n}\nfunction flatMap(values, func) {\n  return _.flatten(values.map(func), true);\n}\nfunction walkHtml(nodes, callback) {\n  nodes.forEach(function (node) {\n    callback(node);\n    if (node.children) {\n      walkHtml(node.children, callback);\n    }\n  });\n}\nvar commentAuthorLabel = exports.commentAuthorLabel = function commentAuthorLabel(comment) {\n  return comment.authorInitials || \"\";\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}