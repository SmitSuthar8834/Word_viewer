{"ast":null,"code":"\"use strict\";\n\nvar firstLineError;\ntry {\n  throw new Error();\n} catch (e) {\n  firstLineError = e;\n}\nvar schedule = require(\"./schedule\");\nvar Queue = require(\"./queue\");\nvar util = require(\"./util\");\nfunction Async() {\n  this._customScheduler = false;\n  this._isTickUsed = false;\n  this._lateQueue = new Queue(16);\n  this._normalQueue = new Queue(16);\n  this._haveDrainedQueues = false;\n  this._trampolineEnabled = true;\n  var self = this;\n  this.drainQueues = function () {\n    self._drainQueues();\n  };\n  this._schedule = schedule;\n}\nAsync.prototype.setScheduler = function (fn) {\n  var prev = this._schedule;\n  this._schedule = fn;\n  this._customScheduler = true;\n  return prev;\n};\nAsync.prototype.hasCustomScheduler = function () {\n  return this._customScheduler;\n};\nAsync.prototype.enableTrampoline = function () {\n  this._trampolineEnabled = true;\n};\nAsync.prototype.disableTrampolineIfNecessary = function () {\n  if (util.hasDevTools) {\n    this._trampolineEnabled = false;\n  }\n};\nAsync.prototype.haveItemsQueued = function () {\n  return this._isTickUsed || this._haveDrainedQueues;\n};\nAsync.prototype.fatalError = function (e, isNode) {\n  if (isNode) {\n    process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) + \"\\n\");\n    process.exit(2);\n  } else {\n    this.throwLater(e);\n  }\n};\nAsync.prototype.throwLater = function (fn, arg) {\n  if (arguments.length === 1) {\n    arg = fn;\n    fn = function () {\n      throw arg;\n    };\n  }\n  if (typeof setTimeout !== \"undefined\") {\n    setTimeout(function () {\n      fn(arg);\n    }, 0);\n  } else try {\n    this._schedule(function () {\n      fn(arg);\n    });\n  } catch (e) {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n  }\n};\nfunction AsyncInvokeLater(fn, receiver, arg) {\n  this._lateQueue.push(fn, receiver, arg);\n  this._queueTick();\n}\nfunction AsyncInvoke(fn, receiver, arg) {\n  this._normalQueue.push(fn, receiver, arg);\n  this._queueTick();\n}\nfunction AsyncSettlePromises(promise) {\n  this._normalQueue._pushOne(promise);\n  this._queueTick();\n}\nif (!util.hasDevTools) {\n  Async.prototype.invokeLater = AsyncInvokeLater;\n  Async.prototype.invoke = AsyncInvoke;\n  Async.prototype.settlePromises = AsyncSettlePromises;\n} else {\n  Async.prototype.invokeLater = function (fn, receiver, arg) {\n    if (this._trampolineEnabled) {\n      AsyncInvokeLater.call(this, fn, receiver, arg);\n    } else {\n      this._schedule(function () {\n        setTimeout(function () {\n          fn.call(receiver, arg);\n        }, 100);\n      });\n    }\n  };\n  Async.prototype.invoke = function (fn, receiver, arg) {\n    if (this._trampolineEnabled) {\n      AsyncInvoke.call(this, fn, receiver, arg);\n    } else {\n      this._schedule(function () {\n        fn.call(receiver, arg);\n      });\n    }\n  };\n  Async.prototype.settlePromises = function (promise) {\n    if (this._trampolineEnabled) {\n      AsyncSettlePromises.call(this, promise);\n    } else {\n      this._schedule(function () {\n        promise._settlePromises();\n      });\n    }\n  };\n}\nAsync.prototype._drainQueue = function (queue) {\n  while (queue.length() > 0) {\n    var fn = queue.shift();\n    if (typeof fn !== \"function\") {\n      fn._settlePromises();\n      continue;\n    }\n    var receiver = queue.shift();\n    var arg = queue.shift();\n    fn.call(receiver, arg);\n  }\n};\nAsync.prototype._drainQueues = function () {\n  this._drainQueue(this._normalQueue);\n  this._reset();\n  this._haveDrainedQueues = true;\n  this._drainQueue(this._lateQueue);\n};\nAsync.prototype._queueTick = function () {\n  if (!this._isTickUsed) {\n    this._isTickUsed = true;\n    this._schedule(this.drainQueues);\n  }\n};\nAsync.prototype._reset = function () {\n  this._isTickUsed = false;\n};\nmodule.exports = Async;\nmodule.exports.firstLineError = firstLineError;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}