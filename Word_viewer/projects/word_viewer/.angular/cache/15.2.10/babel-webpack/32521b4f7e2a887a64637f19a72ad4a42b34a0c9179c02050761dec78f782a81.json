{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {\n  var errors = require(\"./errors\");\n  var TypeError = errors.TypeError;\n  var util = require(\"./util\");\n  var errorObj = util.errorObj;\n  var tryCatch = util.tryCatch;\n  var yieldHandlers = [];\n  function promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n      traceParent._pushContext();\n      var result = tryCatch(yieldHandlers[i])(value);\n      traceParent._popContext();\n      if (result === errorObj) {\n        traceParent._pushContext();\n        var ret = Promise.reject(errorObj.e);\n        traceParent._popContext();\n        return ret;\n      }\n      var maybePromise = tryConvertToPromise(result, traceParent);\n      if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n  }\n  function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    if (debug.cancellation()) {\n      var internal = new Promise(INTERNAL);\n      var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n      this._promise = internal.lastly(function () {\n        return _finallyPromise;\n      });\n      internal._captureStackTrace();\n      internal._setOnCancel(this);\n    } else {\n      var promise = this._promise = new Promise(INTERNAL);\n      promise._captureStackTrace();\n    }\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;\n    this._yieldedPromise = null;\n    this._cancellationPhase = false;\n  }\n  util.inherits(PromiseSpawn, Proxyable);\n  PromiseSpawn.prototype._isResolved = function () {\n    return this._promise === null;\n  };\n  PromiseSpawn.prototype._cleanup = function () {\n    this._promise = this._generator = null;\n    if (debug.cancellation() && this._finallyPromise !== null) {\n      this._finallyPromise._fulfill();\n      this._finallyPromise = null;\n    }\n  };\n  PromiseSpawn.prototype._promiseCancelled = function () {\n    if (this._isResolved()) return;\n    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n    var result;\n    if (!implementsReturn) {\n      var reason = new Promise.CancellationError(\"generator .return() sentinel\");\n      Promise.coroutine.returnSentinel = reason;\n      this._promise._attachExtraTrace(reason);\n      this._promise._pushContext();\n      result = tryCatch(this._generator[\"throw\"]).call(this._generator, reason);\n      this._promise._popContext();\n    } else {\n      this._promise._pushContext();\n      result = tryCatch(this._generator[\"return\"]).call(this._generator, undefined);\n      this._promise._popContext();\n    }\n    this._cancellationPhase = true;\n    this._yieldedPromise = null;\n    this._continue(result);\n  };\n  PromiseSpawn.prototype._promiseFulfilled = function (value) {\n    this._yieldedPromise = null;\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n  };\n  PromiseSpawn.prototype._promiseRejected = function (reason) {\n    this._yieldedPromise = null;\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"]).call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n  };\n  PromiseSpawn.prototype._resultCancelled = function () {\n    if (this._yieldedPromise instanceof Promise) {\n      var promise = this._yieldedPromise;\n      this._yieldedPromise = null;\n      promise.cancel();\n    }\n  };\n  PromiseSpawn.prototype.promise = function () {\n    return this._promise;\n  };\n  PromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver = this._generatorFunction = undefined;\n    this._promiseFulfilled(undefined);\n  };\n  PromiseSpawn.prototype._continue = function (result) {\n    var promise = this._promise;\n    if (result === errorObj) {\n      this._cleanup();\n      if (this._cancellationPhase) {\n        return promise.cancel();\n      } else {\n        return promise._rejectCallback(result.e, false);\n      }\n    }\n    var value = result.value;\n    if (result.done === true) {\n      this._cleanup();\n      if (this._cancellationPhase) {\n        return promise.cancel();\n      } else {\n        return promise._resolveCallback(value);\n      }\n    } else {\n      var maybePromise = tryConvertToPromise(value, this._promise);\n      if (!(maybePromise instanceof Promise)) {\n        maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);\n        if (maybePromise === null) {\n          this._promiseRejected(new TypeError(\"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\\u000a\".replace(\"%s\", value) + \"From coroutine:\\u000a\" + this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")));\n          return;\n        }\n      }\n      maybePromise = maybePromise._target();\n      var bitField = maybePromise._bitField;\n      ;\n      if ((bitField & 50397184) === 0) {\n        this._yieldedPromise = maybePromise;\n        maybePromise._proxy(this, null);\n      } else if ((bitField & 33554432) !== 0) {\n        Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());\n      } else if ((bitField & 16777216) !== 0) {\n        Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());\n      } else {\n        this._promiseCancelled();\n      }\n    }\n  };\n  Promise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n      throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n      var generator = generatorFunction.apply(this, arguments);\n      var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);\n      var ret = spawn.promise();\n      spawn._generator = generator;\n      spawn._promiseFulfilled(undefined);\n      return ret;\n    };\n  };\n  Promise.coroutine.addYieldHandler = function (fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    yieldHandlers.push(fn);\n  };\n  Promise.spawn = function (generatorFunction) {\n    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n    if (typeof generatorFunction !== \"function\") {\n      return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}