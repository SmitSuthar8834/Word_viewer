{"ast":null,"code":"\"use strict\";\n\nvar es5 = require(\"./es5\");\nvar Objectfreeze = es5.freeze;\nvar util = require(\"./util\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\nfunction subError(nameProperty, defaultMessage) {\n  function SubError(message) {\n    if (!(this instanceof SubError)) return new SubError(message);\n    notEnumerableProp(this, \"message\", typeof message === \"string\" ? message : defaultMessage);\n    notEnumerableProp(this, \"name\", nameProperty);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      Error.call(this);\n    }\n  }\n  inherits(SubError, Error);\n  return SubError;\n}\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n  _TypeError = TypeError;\n  _RangeError = RangeError;\n} catch (e) {\n  _TypeError = subError(\"TypeError\", \"type error\");\n  _RangeError = subError(\"RangeError\", \"range error\");\n}\nvar methods = (\"join pop push shift unshift slice filter forEach some \" + \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\nfor (var i = 0; i < methods.length; ++i) {\n  if (typeof Array.prototype[methods[i]] === \"function\") {\n    AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n  }\n}\nes5.defineProperty(AggregateError.prototype, \"length\", {\n  value: 0,\n  configurable: false,\n  writable: true,\n  enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function () {\n  var indent = Array(level * 4 + 1).join(\" \");\n  var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n  level++;\n  indent = Array(level * 4 + 1).join(\" \");\n  for (var i = 0; i < this.length; ++i) {\n    var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n    var lines = str.split(\"\\n\");\n    for (var j = 0; j < lines.length; ++j) {\n      lines[j] = indent + lines[j];\n    }\n    str = lines.join(\"\\n\");\n    ret += str + \"\\n\";\n  }\n  level--;\n  return ret;\n};\nfunction OperationalError(message) {\n  if (!(this instanceof OperationalError)) return new OperationalError(message);\n  notEnumerableProp(this, \"name\", \"OperationalError\");\n  notEnumerableProp(this, \"message\", message);\n  this.cause = message;\n  this[\"isOperational\"] = true;\n  if (message instanceof Error) {\n    notEnumerableProp(this, \"message\", message.message);\n    notEnumerableProp(this, \"stack\", message.stack);\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\ninherits(OperationalError, Error);\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n  errorTypes = Objectfreeze({\n    CancellationError: CancellationError,\n    TimeoutError: TimeoutError,\n    OperationalError: OperationalError,\n    RejectionError: OperationalError,\n    AggregateError: AggregateError\n  });\n  es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n    value: errorTypes,\n    writable: false,\n    enumerable: false,\n    configurable: false\n  });\n}\nmodule.exports = {\n  Error: Error,\n  TypeError: _TypeError,\n  RangeError: _RangeError,\n  CancellationError: errorTypes.CancellationError,\n  OperationalError: errorTypes.OperationalError,\n  TimeoutError: errorTypes.TimeoutError,\n  AggregateError: errorTypes.AggregateError,\n  Warning: Warning\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}