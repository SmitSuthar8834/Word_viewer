{"ast":null,"code":"exports.createBodyReader = createBodyReader;\nexports._readNumberingProperties = readNumberingProperties;\nvar dingbatToUnicode = require(\"dingbat-to-unicode\");\nvar _ = require(\"underscore\");\nvar documents = require(\"../documents\");\nvar Result = require(\"../results\").Result;\nvar warning = require(\"../results\").warning;\nvar xml = require(\"../xml\");\nvar uris = require(\"./uris\");\nfunction createBodyReader(options) {\n  return {\n    readXmlElement: function (element) {\n      return new BodyReader(options).readXmlElement(element);\n    },\n    readXmlElements: function (elements) {\n      return new BodyReader(options).readXmlElements(elements);\n    }\n  };\n}\nfunction BodyReader(options) {\n  var complexFieldStack = [];\n  var currentInstrText = [];\n\n  // When a paragraph is marked as deleted, its contents should be combined\n  // with the following paragraph. See 17.13.5.15 del (Deleted Paragraph) of\n  // ECMA-376 4th edition Part 1.\n  var deletedParagraphContents = [];\n  var relationships = options.relationships;\n  var contentTypes = options.contentTypes;\n  var docxFile = options.docxFile;\n  var files = options.files;\n  var numbering = options.numbering;\n  var styles = options.styles;\n  function readXmlElements(elements) {\n    var results = elements.map(readXmlElement);\n    return combineResults(results);\n  }\n  function readXmlElement(element) {\n    if (element.type === \"element\") {\n      var handler = xmlElementReaders[element.name];\n      if (handler) {\n        return handler(element);\n      } else if (!Object.prototype.hasOwnProperty.call(ignoreElements, element.name)) {\n        var message = warning(\"An unrecognised element was ignored: \" + element.name);\n        return emptyResultWithMessages([message]);\n      }\n    }\n    return emptyResult();\n  }\n  function readParagraphProperties(element) {\n    return readParagraphStyle(element).map(function (style) {\n      return {\n        type: \"paragraphProperties\",\n        styleId: style.styleId,\n        styleName: style.name,\n        alignment: element.firstOrEmpty(\"w:jc\").attributes[\"w:val\"],\n        numbering: readNumberingProperties(style.styleId, element.firstOrEmpty(\"w:numPr\"), numbering),\n        indent: readParagraphIndent(element.firstOrEmpty(\"w:ind\"))\n      };\n    });\n  }\n  function readParagraphIndent(element) {\n    return {\n      start: element.attributes[\"w:start\"] || element.attributes[\"w:left\"],\n      end: element.attributes[\"w:end\"] || element.attributes[\"w:right\"],\n      firstLine: element.attributes[\"w:firstLine\"],\n      hanging: element.attributes[\"w:hanging\"]\n    };\n  }\n  function readRunProperties(element) {\n    return readRunStyle(element).map(function (style) {\n      var fontSizeString = element.firstOrEmpty(\"w:sz\").attributes[\"w:val\"];\n      // w:sz gives the font size in half points, so halve the value to get the size in points\n      var fontSize = /^[0-9]+$/.test(fontSizeString) ? parseInt(fontSizeString, 10) / 2 : null;\n      return {\n        type: \"runProperties\",\n        styleId: style.styleId,\n        styleName: style.name,\n        verticalAlignment: element.firstOrEmpty(\"w:vertAlign\").attributes[\"w:val\"],\n        font: element.firstOrEmpty(\"w:rFonts\").attributes[\"w:ascii\"],\n        fontSize: fontSize,\n        isBold: readBooleanElement(element.first(\"w:b\")),\n        isUnderline: readUnderline(element.first(\"w:u\")),\n        isItalic: readBooleanElement(element.first(\"w:i\")),\n        isStrikethrough: readBooleanElement(element.first(\"w:strike\")),\n        isAllCaps: readBooleanElement(element.first(\"w:caps\")),\n        isSmallCaps: readBooleanElement(element.first(\"w:smallCaps\")),\n        highlight: readHighlightValue(element.firstOrEmpty(\"w:highlight\").attributes[\"w:val\"])\n      };\n    });\n  }\n  function readUnderline(element) {\n    if (element) {\n      var value = element.attributes[\"w:val\"];\n      return value !== undefined && value !== \"false\" && value !== \"0\" && value !== \"none\";\n    } else {\n      return false;\n    }\n  }\n  function readBooleanElement(element) {\n    if (element) {\n      var value = element.attributes[\"w:val\"];\n      return value !== \"false\" && value !== \"0\";\n    } else {\n      return false;\n    }\n  }\n  function readBooleanAttributeValue(value) {\n    return value !== \"false\" && value !== \"0\";\n  }\n  function readHighlightValue(value) {\n    if (!value || value === \"none\") {\n      return null;\n    } else {\n      return value;\n    }\n  }\n  function readParagraphStyle(element) {\n    return readStyle(element, \"w:pStyle\", \"Paragraph\", styles.findParagraphStyleById);\n  }\n  function readRunStyle(element) {\n    return readStyle(element, \"w:rStyle\", \"Run\", styles.findCharacterStyleById);\n  }\n  function readTableStyle(element) {\n    return readStyle(element, \"w:tblStyle\", \"Table\", styles.findTableStyleById);\n  }\n  function readStyle(element, styleTagName, styleType, findStyleById) {\n    var messages = [];\n    var styleElement = element.first(styleTagName);\n    var styleId = null;\n    var name = null;\n    if (styleElement) {\n      styleId = styleElement.attributes[\"w:val\"];\n      if (styleId) {\n        var style = findStyleById(styleId);\n        if (style) {\n          name = style.name;\n        } else {\n          messages.push(undefinedStyleWarning(styleType, styleId));\n        }\n      }\n    }\n    return elementResultWithMessages({\n      styleId: styleId,\n      name: name\n    }, messages);\n  }\n  function readFldChar(element) {\n    var type = element.attributes[\"w:fldCharType\"];\n    if (type === \"begin\") {\n      complexFieldStack.push({\n        type: \"begin\",\n        fldChar: element\n      });\n      currentInstrText = [];\n    } else if (type === \"end\") {\n      var complexFieldEnd = complexFieldStack.pop();\n      if (complexFieldEnd.type === \"begin\") {\n        complexFieldEnd = parseCurrentInstrText(complexFieldEnd);\n      }\n      if (complexFieldEnd.type === \"checkbox\") {\n        return elementResult(documents.checkbox({\n          checked: complexFieldEnd.checked\n        }));\n      }\n    } else if (type === \"separate\") {\n      var complexFieldSeparate = complexFieldStack.pop();\n      var complexField = parseCurrentInstrText(complexFieldSeparate);\n      complexFieldStack.push(complexField);\n    }\n    return emptyResult();\n  }\n  function currentHyperlinkOptions() {\n    var topHyperlink = _.last(complexFieldStack.filter(function (complexField) {\n      return complexField.type === \"hyperlink\";\n    }));\n    return topHyperlink ? topHyperlink.options : null;\n  }\n  function parseCurrentInstrText(complexField) {\n    return parseInstrText(currentInstrText.join(''), complexField.type === \"begin\" ? complexField.fldChar : xml.emptyElement);\n  }\n  function parseInstrText(instrText, fldChar) {\n    var externalLinkResult = /\\s*HYPERLINK \"(.*)\"/.exec(instrText);\n    if (externalLinkResult) {\n      return {\n        type: \"hyperlink\",\n        options: {\n          href: externalLinkResult[1]\n        }\n      };\n    }\n    var internalLinkResult = /\\s*HYPERLINK\\s+\\\\l\\s+\"(.*)\"/.exec(instrText);\n    if (internalLinkResult) {\n      return {\n        type: \"hyperlink\",\n        options: {\n          anchor: internalLinkResult[1]\n        }\n      };\n    }\n    var checkboxResult = /\\s*FORMCHECKBOX\\s*/.exec(instrText);\n    if (checkboxResult) {\n      var checkboxElement = fldChar.firstOrEmpty(\"w:ffData\").firstOrEmpty(\"w:checkBox\");\n      var checkedElement = checkboxElement.first(\"w:checked\");\n      var checked = checkedElement == null ? readBooleanElement(checkboxElement.first(\"w:default\")) : readBooleanElement(checkedElement);\n      return {\n        type: \"checkbox\",\n        checked: checked\n      };\n    }\n    return {\n      type: \"unknown\"\n    };\n  }\n  function readInstrText(element) {\n    currentInstrText.push(element.text());\n    return emptyResult();\n  }\n  function readSymbol(element) {\n    // See 17.3.3.30 sym (Symbol Character) of ECMA-376 4th edition Part 1\n    var font = element.attributes[\"w:font\"];\n    var char = element.attributes[\"w:char\"];\n    var unicodeCharacter = dingbatToUnicode.hex(font, char);\n    if (unicodeCharacter == null && /^F0..$/.test(char)) {\n      unicodeCharacter = dingbatToUnicode.hex(font, char.substring(2));\n    }\n    if (unicodeCharacter == null) {\n      return emptyResultWithMessages([warning(\"A w:sym element with an unsupported character was ignored: char \" + char + \" in font \" + font)]);\n    } else {\n      return elementResult(new documents.Text(unicodeCharacter.string));\n    }\n  }\n  function noteReferenceReader(noteType) {\n    return function (element) {\n      var noteId = element.attributes[\"w:id\"];\n      return elementResult(new documents.NoteReference({\n        noteType: noteType,\n        noteId: noteId\n      }));\n    };\n  }\n  function readCommentReference(element) {\n    return elementResult(documents.commentReference({\n      commentId: element.attributes[\"w:id\"]\n    }));\n  }\n  function readChildElements(element) {\n    return readXmlElements(element.children);\n  }\n  var xmlElementReaders = {\n    \"w:p\": function (element) {\n      var paragraphPropertiesElement = element.firstOrEmpty(\"w:pPr\");\n      var isDeleted = !!paragraphPropertiesElement.firstOrEmpty(\"w:rPr\").first(\"w:del\");\n      if (isDeleted) {\n        element.children.forEach(function (child) {\n          deletedParagraphContents.push(child);\n        });\n        return emptyResult();\n      } else {\n        var childrenXml = element.children;\n        if (deletedParagraphContents.length > 0) {\n          childrenXml = deletedParagraphContents.concat(childrenXml);\n          deletedParagraphContents = [];\n        }\n        return ReadResult.map(readParagraphProperties(paragraphPropertiesElement), readXmlElements(childrenXml), function (properties, children) {\n          return new documents.Paragraph(children, properties);\n        }).insertExtra();\n      }\n    },\n    \"w:r\": function (element) {\n      return ReadResult.map(readRunProperties(element.firstOrEmpty(\"w:rPr\")), readXmlElements(element.children), function (properties, children) {\n        var hyperlinkOptions = currentHyperlinkOptions();\n        if (hyperlinkOptions !== null) {\n          children = [new documents.Hyperlink(children, hyperlinkOptions)];\n        }\n        return new documents.Run(children, properties);\n      });\n    },\n    \"w:fldChar\": readFldChar,\n    \"w:instrText\": readInstrText,\n    \"w:t\": function (element) {\n      return elementResult(new documents.Text(element.text()));\n    },\n    \"w:tab\": function (element) {\n      return elementResult(new documents.Tab());\n    },\n    \"w:noBreakHyphen\": function () {\n      return elementResult(new documents.Text(\"\\u2011\"));\n    },\n    \"w:softHyphen\": function (element) {\n      return elementResult(new documents.Text(\"\\u00AD\"));\n    },\n    \"w:sym\": readSymbol,\n    \"w:hyperlink\": function (element) {\n      var relationshipId = element.attributes[\"r:id\"];\n      var anchor = element.attributes[\"w:anchor\"];\n      return readXmlElements(element.children).map(function (children) {\n        function create(options) {\n          var targetFrame = element.attributes[\"w:tgtFrame\"] || null;\n          return new documents.Hyperlink(children, _.extend({\n            targetFrame: targetFrame\n          }, options));\n        }\n        if (relationshipId) {\n          var href = relationships.findTargetByRelationshipId(relationshipId);\n          if (anchor) {\n            href = uris.replaceFragment(href, anchor);\n          }\n          return create({\n            href: href\n          });\n        } else if (anchor) {\n          return create({\n            anchor: anchor\n          });\n        } else {\n          return children;\n        }\n      });\n    },\n    \"w:tbl\": readTable,\n    \"w:tr\": readTableRow,\n    \"w:tc\": readTableCell,\n    \"w:footnoteReference\": noteReferenceReader(\"footnote\"),\n    \"w:endnoteReference\": noteReferenceReader(\"endnote\"),\n    \"w:commentReference\": readCommentReference,\n    \"w:br\": function (element) {\n      var breakType = element.attributes[\"w:type\"];\n      if (breakType == null || breakType === \"textWrapping\") {\n        return elementResult(documents.lineBreak);\n      } else if (breakType === \"page\") {\n        return elementResult(documents.pageBreak);\n      } else if (breakType === \"column\") {\n        return elementResult(documents.columnBreak);\n      } else {\n        return emptyResultWithMessages([warning(\"Unsupported break type: \" + breakType)]);\n      }\n    },\n    \"w:bookmarkStart\": function (element) {\n      var name = element.attributes[\"w:name\"];\n      if (name === \"_GoBack\") {\n        return emptyResult();\n      } else {\n        return elementResult(new documents.BookmarkStart({\n          name: name\n        }));\n      }\n    },\n    \"mc:AlternateContent\": function (element) {\n      return readChildElements(element.first(\"mc:Fallback\"));\n    },\n    \"w:sdt\": function (element) {\n      var checkbox = element.firstOrEmpty(\"w:sdtPr\").first(\"wordml:checkbox\");\n      if (checkbox) {\n        var checkedElement = checkbox.first(\"wordml:checked\");\n        var isChecked = !!checkedElement && readBooleanAttributeValue(checkedElement.attributes[\"wordml:val\"]);\n        return elementResult(documents.checkbox({\n          checked: isChecked\n        }));\n      } else {\n        return readXmlElements(element.firstOrEmpty(\"w:sdtContent\").children);\n      }\n    },\n    \"w:ins\": readChildElements,\n    \"w:object\": readChildElements,\n    \"w:smartTag\": readChildElements,\n    \"w:drawing\": readChildElements,\n    \"w:pict\": function (element) {\n      return readChildElements(element).toExtra();\n    },\n    \"v:roundrect\": readChildElements,\n    \"v:shape\": readChildElements,\n    \"v:textbox\": readChildElements,\n    \"w:txbxContent\": readChildElements,\n    \"wp:inline\": readDrawingElement,\n    \"wp:anchor\": readDrawingElement,\n    \"v:imagedata\": readImageData,\n    \"v:group\": readChildElements,\n    \"v:rect\": readChildElements\n  };\n  return {\n    readXmlElement: readXmlElement,\n    readXmlElements: readXmlElements\n  };\n  function readTable(element) {\n    var propertiesResult = readTableProperties(element.firstOrEmpty(\"w:tblPr\"));\n    return readXmlElements(element.children).flatMap(calculateRowSpans).flatMap(function (children) {\n      return propertiesResult.map(function (properties) {\n        return documents.Table(children, properties);\n      });\n    });\n  }\n  function readTableProperties(element) {\n    return readTableStyle(element).map(function (style) {\n      return {\n        styleId: style.styleId,\n        styleName: style.name\n      };\n    });\n  }\n  function readTableRow(element) {\n    var properties = element.firstOrEmpty(\"w:trPr\");\n    var isHeader = !!properties.first(\"w:tblHeader\");\n    return readXmlElements(element.children).map(function (children) {\n      return documents.TableRow(children, {\n        isHeader: isHeader\n      });\n    });\n  }\n  function readTableCell(element) {\n    return readXmlElements(element.children).map(function (children) {\n      var properties = element.firstOrEmpty(\"w:tcPr\");\n      var gridSpan = properties.firstOrEmpty(\"w:gridSpan\").attributes[\"w:val\"];\n      var colSpan = gridSpan ? parseInt(gridSpan, 10) : 1;\n      var cell = documents.TableCell(children, {\n        colSpan: colSpan\n      });\n      cell._vMerge = readVMerge(properties);\n      return cell;\n    });\n  }\n  function readVMerge(properties) {\n    var element = properties.first(\"w:vMerge\");\n    if (element) {\n      var val = element.attributes[\"w:val\"];\n      return val === \"continue\" || !val;\n    } else {\n      return null;\n    }\n  }\n  function calculateRowSpans(rows) {\n    var unexpectedNonRows = _.any(rows, function (row) {\n      return row.type !== documents.types.tableRow;\n    });\n    if (unexpectedNonRows) {\n      return elementResultWithMessages(rows, [warning(\"unexpected non-row element in table, cell merging may be incorrect\")]);\n    }\n    var unexpectedNonCells = _.any(rows, function (row) {\n      return _.any(row.children, function (cell) {\n        return cell.type !== documents.types.tableCell;\n      });\n    });\n    if (unexpectedNonCells) {\n      return elementResultWithMessages(rows, [warning(\"unexpected non-cell element in table row, cell merging may be incorrect\")]);\n    }\n    var columns = {};\n    rows.forEach(function (row) {\n      var cellIndex = 0;\n      row.children.forEach(function (cell) {\n        if (cell._vMerge && columns[cellIndex]) {\n          columns[cellIndex].rowSpan++;\n        } else {\n          columns[cellIndex] = cell;\n          cell._vMerge = false;\n        }\n        cellIndex += cell.colSpan;\n      });\n    });\n    rows.forEach(function (row) {\n      row.children = row.children.filter(function (cell) {\n        return !cell._vMerge;\n      });\n      row.children.forEach(function (cell) {\n        delete cell._vMerge;\n      });\n    });\n    return elementResult(rows);\n  }\n  function readDrawingElement(element) {\n    var blips = element.getElementsByTagName(\"a:graphic\").getElementsByTagName(\"a:graphicData\").getElementsByTagName(\"pic:pic\").getElementsByTagName(\"pic:blipFill\").getElementsByTagName(\"a:blip\");\n    return combineResults(blips.map(readBlip.bind(null, element)));\n  }\n  function readBlip(element, blip) {\n    var properties = element.first(\"wp:docPr\").attributes;\n    var altText = isBlank(properties.descr) ? properties.title : properties.descr;\n    var blipImageFile = findBlipImageFile(blip);\n    if (blipImageFile === null) {\n      return emptyResultWithMessages([warning(\"Could not find image file for a:blip element\")]);\n    } else {\n      return readImage(blipImageFile, altText);\n    }\n  }\n  function isBlank(value) {\n    return value == null || /^\\s*$/.test(value);\n  }\n  function findBlipImageFile(blip) {\n    var embedRelationshipId = blip.attributes[\"r:embed\"];\n    var linkRelationshipId = blip.attributes[\"r:link\"];\n    if (embedRelationshipId) {\n      return findEmbeddedImageFile(embedRelationshipId);\n    } else if (linkRelationshipId) {\n      var imagePath = relationships.findTargetByRelationshipId(linkRelationshipId);\n      return {\n        path: imagePath,\n        read: files.read.bind(files, imagePath)\n      };\n    } else {\n      return null;\n    }\n  }\n  function readImageData(element) {\n    var relationshipId = element.attributes['r:id'];\n    if (relationshipId) {\n      return readImage(findEmbeddedImageFile(relationshipId), element.attributes[\"o:title\"]);\n    } else {\n      return emptyResultWithMessages([warning(\"A v:imagedata element without a relationship ID was ignored\")]);\n    }\n  }\n  function findEmbeddedImageFile(relationshipId) {\n    var path = uris.uriToZipEntryName(\"word\", relationships.findTargetByRelationshipId(relationshipId));\n    return {\n      path: path,\n      read: docxFile.read.bind(docxFile, path)\n    };\n  }\n  function readImage(imageFile, altText) {\n    var contentType = contentTypes.findContentType(imageFile.path);\n    var image = documents.Image({\n      readImage: imageFile.read,\n      altText: altText,\n      contentType: contentType\n    });\n    var warnings = supportedImageTypes[contentType] ? [] : warning(\"Image of type \" + contentType + \" is unlikely to display in web browsers\");\n    return elementResultWithMessages(image, warnings);\n  }\n  function undefinedStyleWarning(type, styleId) {\n    return warning(type + \" style with ID \" + styleId + \" was referenced but not defined in the document\");\n  }\n}\nfunction readNumberingProperties(styleId, element, numbering) {\n  var level = element.firstOrEmpty(\"w:ilvl\").attributes[\"w:val\"];\n  var numId = element.firstOrEmpty(\"w:numId\").attributes[\"w:val\"];\n  if (level !== undefined && numId !== undefined) {\n    return numbering.findLevel(numId, level);\n  }\n  if (styleId != null) {\n    var levelByStyleId = numbering.findLevelByParagraphStyleId(styleId);\n    if (levelByStyleId != null) {\n      return levelByStyleId;\n    }\n  }\n  return null;\n}\nvar supportedImageTypes = {\n  \"image/png\": true,\n  \"image/gif\": true,\n  \"image/jpeg\": true,\n  \"image/svg+xml\": true,\n  \"image/tiff\": true\n};\nvar ignoreElements = {\n  \"office-word:wrap\": true,\n  \"v:shadow\": true,\n  \"v:shapetype\": true,\n  \"w:annotationRef\": true,\n  \"w:bookmarkEnd\": true,\n  \"w:sectPr\": true,\n  \"w:proofErr\": true,\n  \"w:lastRenderedPageBreak\": true,\n  \"w:commentRangeStart\": true,\n  \"w:commentRangeEnd\": true,\n  \"w:del\": true,\n  \"w:footnoteRef\": true,\n  \"w:endnoteRef\": true,\n  \"w:pPr\": true,\n  \"w:rPr\": true,\n  \"w:tblPr\": true,\n  \"w:tblGrid\": true,\n  \"w:trPr\": true,\n  \"w:tcPr\": true\n};\nfunction emptyResultWithMessages(messages) {\n  return new ReadResult(null, null, messages);\n}\nfunction emptyResult() {\n  return new ReadResult(null);\n}\nfunction elementResult(element) {\n  return new ReadResult(element);\n}\nfunction elementResultWithMessages(element, messages) {\n  return new ReadResult(element, null, messages);\n}\nfunction ReadResult(element, extra, messages) {\n  this.value = element || [];\n  this.extra = extra || [];\n  this._result = new Result({\n    element: this.value,\n    extra: extra\n  }, messages);\n  this.messages = this._result.messages;\n}\nReadResult.prototype.toExtra = function () {\n  return new ReadResult(null, joinElements(this.extra, this.value), this.messages);\n};\nReadResult.prototype.insertExtra = function () {\n  var extra = this.extra;\n  if (extra && extra.length) {\n    return new ReadResult(joinElements(this.value, extra), null, this.messages);\n  } else {\n    return this;\n  }\n};\nReadResult.prototype.map = function (func) {\n  var result = this._result.map(function (value) {\n    return func(value.element);\n  });\n  return new ReadResult(result.value, this.extra, result.messages);\n};\nReadResult.prototype.flatMap = function (func) {\n  var result = this._result.flatMap(function (value) {\n    return func(value.element)._result;\n  });\n  return new ReadResult(result.value.element, joinElements(this.extra, result.value.extra), result.messages);\n};\nReadResult.map = function (first, second, func) {\n  return new ReadResult(func(first.value, second.value), joinElements(first.extra, second.extra), first.messages.concat(second.messages));\n};\nfunction combineResults(results) {\n  var result = Result.combine(_.pluck(results, \"_result\"));\n  return new ReadResult(_.flatten(_.pluck(result.value, \"element\")), _.filter(_.flatten(_.pluck(result.value, \"extra\")), identity), result.messages);\n}\nfunction joinElements(first, second) {\n  return _.flatten([first, second]);\n}\nfunction identity(value) {\n  return value;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}