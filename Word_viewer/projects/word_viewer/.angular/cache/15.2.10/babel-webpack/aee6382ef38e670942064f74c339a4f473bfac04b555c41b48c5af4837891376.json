{"ast":null,"code":"var rules = require(\"./rules\");\nvar results = require(\"./parsing-results\");\nexports.parser = function (name, prefixRules, infixRuleBuilders) {\n  var self = {\n    rule: rule,\n    leftAssociative: leftAssociative,\n    rightAssociative: rightAssociative\n  };\n  var infixRules = new InfixRules(infixRuleBuilders.map(createInfixRule));\n  var prefixRule = rules.firstOf(name, prefixRules);\n  function createInfixRule(infixRuleBuilder) {\n    return {\n      name: infixRuleBuilder.name,\n      rule: lazyRule(infixRuleBuilder.ruleBuilder.bind(null, self))\n    };\n  }\n  function rule() {\n    return createRule(infixRules);\n  }\n  function leftAssociative(name) {\n    return createRule(infixRules.untilExclusive(name));\n  }\n  function rightAssociative(name) {\n    return createRule(infixRules.untilInclusive(name));\n  }\n  function createRule(infixRules) {\n    return apply.bind(null, infixRules);\n  }\n  function apply(infixRules, tokens) {\n    var leftResult = prefixRule(tokens);\n    if (leftResult.isSuccess()) {\n      return infixRules.apply(leftResult);\n    } else {\n      return leftResult;\n    }\n  }\n  return self;\n};\nfunction InfixRules(infixRules) {\n  function untilExclusive(name) {\n    return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name)));\n  }\n  function untilInclusive(name) {\n    return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name) + 1));\n  }\n  function ruleNames() {\n    return infixRules.map(function (rule) {\n      return rule.name;\n    });\n  }\n  function apply(leftResult) {\n    var currentResult;\n    var source;\n    while (true) {\n      currentResult = applyToTokens(leftResult.remaining());\n      if (currentResult.isSuccess()) {\n        source = leftResult.source().to(currentResult.source());\n        leftResult = results.success(currentResult.value()(leftResult.value(), source), currentResult.remaining(), source);\n      } else if (currentResult.isFailure()) {\n        return leftResult;\n      } else {\n        return currentResult;\n      }\n    }\n  }\n  function applyToTokens(tokens) {\n    return rules.firstOf(\"infix\", infixRules.map(function (infix) {\n      return infix.rule;\n    }))(tokens);\n  }\n  return {\n    apply: apply,\n    untilExclusive: untilExclusive,\n    untilInclusive: untilInclusive\n  };\n}\nexports.infix = function (name, ruleBuilder) {\n  function map(func) {\n    return exports.infix(name, function (parser) {\n      var rule = ruleBuilder(parser);\n      return function (tokens) {\n        var result = rule(tokens);\n        return result.map(function (right) {\n          return function (left, source) {\n            return func(left, right, source);\n          };\n        });\n      };\n    });\n  }\n  return {\n    name: name,\n    ruleBuilder: ruleBuilder,\n    map: map\n  };\n};\n\n// TODO: move into a sensible place and remove duplication\nvar lazyRule = function (ruleBuilder) {\n  var rule;\n  return function (input) {\n    if (!rule) {\n      rule = ruleBuilder();\n    }\n    return rule(input);\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}