{"ast":null,"code":"import { classToPlain, Exclude, Expose } from 'class-transformer';\nimport { __decorate, __metadata } from 'tslib';\n\n/**\n * @public\n * Returns a string represent of date in ISO 8601 without time zone specification(doesn't convert it\n * using local timezone).\n *\n * Example:\n *\n *      const date = new Date(2018, 01, 20, 15, 10, 30);\n *      const result = toLocalISOString(date);\n *      //result: '2018-02-20T15:10:30'\n *\n * @param date Date value.\n */\nfunction ɵtoLocalISOString(date) {\n  if (!(date instanceof Date)) {\n    throw new TypeError();\n  }\n  const timeZoneOffset = date.getTimezoneOffset() * 60000;\n  return new Date(date.getTime() - timeZoneOffset).toISOString().slice(0, -1);\n}\n/**\n * @public\n * Returns encoded date in string value.\n * @param date Date value.\n */\nfunction ɵencodeDate(date) {\n  return `\"${ɵtoLocalISOString(date)}\"`;\n}\n\n/**\n * @public\n */\nvar ɵDataSourceScope = /*#__PURE__*/(() => {\n  (function (ɵDataSourceScope) {\n    ɵDataSourceScope[\"ViewElement\"] = \"viewElement\";\n    ɵDataSourceScope[\"Page\"] = \"page\";\n  })(ɵDataSourceScope || (ɵDataSourceScope = {}));\n  return ɵDataSourceScope;\n})();\n/**\n * @public\n */\nvar ɵDataSchemaAttributeType = /*#__PURE__*/(() => {\n  (function (ɵDataSchemaAttributeType) {\n    ɵDataSchemaAttributeType[\"OwnAttribute\"] = \"Own\";\n    ɵDataSchemaAttributeType[\"ForwardReferenceAttribute\"] = \"ForwardReference\";\n    ɵDataSchemaAttributeType[\"BackReferenceAttribute\"] = \"BackReference\";\n    ɵDataSchemaAttributeType[\"AggregationAttribute\"] = \"Aggregation\";\n    ɵDataSchemaAttributeType[\"FunctionAttribute\"] = \"Function\";\n  })(ɵDataSchemaAttributeType || (ɵDataSchemaAttributeType = {}));\n  return ɵDataSchemaAttributeType;\n})();\n/**\n * @public\n */\nvar ɵDataSchemaAttributeUsageType = /*#__PURE__*/(() => {\n  (function (ɵDataSchemaAttributeUsageType) {\n    ɵDataSchemaAttributeUsageType[ɵDataSchemaAttributeUsageType[\"General\"] = 0] = \"General\";\n    ɵDataSchemaAttributeUsageType[ɵDataSchemaAttributeUsageType[\"Advanced\"] = 1] = \"Advanced\";\n    ɵDataSchemaAttributeUsageType[ɵDataSchemaAttributeUsageType[\"None\"] = 2] = \"None\";\n  })(ɵDataSchemaAttributeUsageType || (ɵDataSchemaAttributeUsageType = {}));\n  return ɵDataSchemaAttributeUsageType;\n})();\n/**\n * @public\n */\nvar ɵDefaultValueSource = /*#__PURE__*/(() => {\n  (function (ɵDefaultValueSource) {\n    ɵDefaultValueSource[ɵDefaultValueSource[\"None\"] = 0] = \"None\";\n    ɵDefaultValueSource[ɵDefaultValueSource[\"Const\"] = 1] = \"Const\";\n    ɵDefaultValueSource[ɵDefaultValueSource[\"Settings\"] = 2] = \"Settings\";\n    ɵDefaultValueSource[ɵDefaultValueSource[\"SystemValue\"] = 3] = \"SystemValue\";\n    ɵDefaultValueSource[ɵDefaultValueSource[\"Sequence\"] = 4] = \"Sequence\";\n  })(ɵDefaultValueSource || (ɵDefaultValueSource = {}));\n  return ɵDefaultValueSource;\n})();\n/**\n * Lookup mode\n * @internal\n */\nvar LookupMode = /*#__PURE__*/(() => {\n  (function (LookupMode) {\n    LookupMode[\"List\"] = \"List\";\n    LookupMode[\"SelectionWindow\"] = \"SelectionWindow\";\n  })(LookupMode || (LookupMode = {}));\n  return LookupMode;\n})();\nvar ɵDataValueType = /*#__PURE__*/(() => {\n  (function (ɵDataValueType) {\n    ɵDataValueType[ɵDataValueType[\"Guid\"] = 0] = \"Guid\";\n    ɵDataValueType[ɵDataValueType[\"Text\"] = 1] = \"Text\";\n    ɵDataValueType[ɵDataValueType[\"Integer\"] = 4] = \"Integer\";\n    ɵDataValueType[ɵDataValueType[\"Float\"] = 5] = \"Float\";\n    ɵDataValueType[ɵDataValueType[\"Money\"] = 6] = \"Money\";\n    ɵDataValueType[ɵDataValueType[\"DateTime\"] = 7] = \"DateTime\";\n    ɵDataValueType[ɵDataValueType[\"Date\"] = 8] = \"Date\";\n    ɵDataValueType[ɵDataValueType[\"Time\"] = 9] = \"Time\";\n    ɵDataValueType[ɵDataValueType[\"Lookup\"] = 10] = \"Lookup\";\n    ɵDataValueType[ɵDataValueType[\"Enum\"] = 11] = \"Enum\";\n    ɵDataValueType[ɵDataValueType[\"Boolean\"] = 12] = \"Boolean\";\n    ɵDataValueType[ɵDataValueType[\"Blob\"] = 13] = \"Blob\";\n    ɵDataValueType[ɵDataValueType[\"Image\"] = 14] = \"Image\";\n    ɵDataValueType[ɵDataValueType[\"CUSTOM_OBJECT\"] = 15] = \"CUSTOM_OBJECT\";\n    ɵDataValueType[ɵDataValueType[\"IMAGELOOKUP\"] = 16] = \"IMAGELOOKUP\";\n    ɵDataValueType[ɵDataValueType[\"COLLECTION\"] = 17] = \"COLLECTION\";\n    ɵDataValueType[ɵDataValueType[\"Color\"] = 18] = \"Color\";\n    ɵDataValueType[ɵDataValueType[\"LOCALIZABLE_STRING\"] = 19] = \"LOCALIZABLE_STRING\";\n    ɵDataValueType[ɵDataValueType[\"ENTITY\"] = 20] = \"ENTITY\";\n    ɵDataValueType[ɵDataValueType[\"ENTITY_COLLECTION\"] = 21] = \"ENTITY_COLLECTION\";\n    ɵDataValueType[ɵDataValueType[\"ENTITY_COLUMN_MAPPING_COLLECTION\"] = 22] = \"ENTITY_COLUMN_MAPPING_COLLECTION\";\n    ɵDataValueType[ɵDataValueType[\"HASH_TEXT\"] = 23] = \"HASH_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"SECURE_TEXT\"] = 24] = \"SECURE_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"FILE\"] = 25] = \"FILE\";\n    ɵDataValueType[ɵDataValueType[\"MAPPING\"] = 26] = \"MAPPING\";\n    ɵDataValueType[ɵDataValueType[\"SHORT_TEXT\"] = 27] = \"SHORT_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"MEDIUM_TEXT\"] = 28] = \"MEDIUM_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"MAXSIZE_TEXT\"] = 29] = \"MAXSIZE_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"LONG_TEXT\"] = 30] = \"LONG_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"FLOAT1\"] = 31] = \"FLOAT1\";\n    ɵDataValueType[ɵDataValueType[\"FLOAT2\"] = 32] = \"FLOAT2\";\n    ɵDataValueType[ɵDataValueType[\"FLOAT3\"] = 33] = \"FLOAT3\";\n    ɵDataValueType[ɵDataValueType[\"FLOAT4\"] = 34] = \"FLOAT4\";\n    ɵDataValueType[ɵDataValueType[\"LOCALIZABLE_PARAMETER_VALUES_LIST\"] = 35] = \"LOCALIZABLE_PARAMETER_VALUES_LIST\";\n    ɵDataValueType[ɵDataValueType[\"METADATA_TEXT\"] = 36] = \"METADATA_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"STAGE_INDICATOR\"] = 37] = \"STAGE_INDICATOR\";\n    ɵDataValueType[ɵDataValueType[\"OBJECT_LIST\"] = 38] = \"OBJECT_LIST\";\n    ɵDataValueType[ɵDataValueType[\"COMPOSITE_OBJECT_LIST\"] = 39] = \"COMPOSITE_OBJECT_LIST\";\n    ɵDataValueType[ɵDataValueType[\"FLOAT8\"] = 40] = \"FLOAT8\";\n    ɵDataValueType[ɵDataValueType[\"FILE_LOCATOR\"] = 41] = \"FILE_LOCATOR\";\n    ɵDataValueType[ɵDataValueType[\"PHONE_TEXT\"] = 42] = \"PHONE_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"RICH_TEXT\"] = 43] = \"RICH_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"WEB_TEXT\"] = 44] = \"WEB_TEXT\";\n    ɵDataValueType[ɵDataValueType[\"EMAIL_TEXT\"] = 45] = \"EMAIL_TEXT\";\n  })(ɵDataValueType || (ɵDataValueType = {}));\n  return ɵDataValueType;\n})();\nvar ɵAggregationType = /*#__PURE__*/(() => {\n  (function (ɵAggregationType) {\n    /** Aggregation function type not defined. */\n    ɵAggregationType[ɵAggregationType[\"None\"] = 0] = \"None\";\n    /** Aggregation function type not defined. */\n    ɵAggregationType[ɵAggregationType[\"Count\"] = 1] = \"Count\";\n    /** Sum of values of all elements. */\n    ɵAggregationType[ɵAggregationType[\"Sum\"] = 2] = \"Sum\";\n    /** Average value for all elements. */\n    ɵAggregationType[ɵAggregationType[\"Avg\"] = 3] = \"Avg\";\n    /** The minimum value among all elements. */\n    ɵAggregationType[ɵAggregationType[\"Min\"] = 4] = \"Min\";\n    /** The maximum value among all elements. */\n    ɵAggregationType[ɵAggregationType[\"Max\"] = 5] = \"Max\";\n    /** Top one record from collection. */\n    ɵAggregationType[ɵAggregationType[\"TopOne\"] = 6] = \"TopOne\";\n  })(ɵAggregationType || (ɵAggregationType = {}));\n  return ɵAggregationType;\n})();\nvar ɵAggregationFunction = /*#__PURE__*/(() => {\n  (function (ɵAggregationFunction) {\n    /** Aggregation function type not defined. */\n    ɵAggregationFunction[\"None\"] = \"\";\n    /** Aggregation function type not defined. */\n    ɵAggregationFunction[\"Count\"] = \"Count\";\n    /** Sum of values of all elements. */\n    ɵAggregationFunction[\"Sum\"] = \"Sum\";\n    /** Average value for all elements. */\n    ɵAggregationFunction[\"Avg\"] = \"Avg\";\n    /** The minimum value among all elements. */\n    ɵAggregationFunction[\"Min\"] = \"Min\";\n    /** The maximum value among all elements. */\n    ɵAggregationFunction[\"Max\"] = \"Max\";\n    /** Top one record from collection. */\n    ɵAggregationFunction[\"TopOne\"] = \"TopOne\";\n  })(ɵAggregationFunction || (ɵAggregationFunction = {}));\n  return ɵAggregationFunction;\n})();\n/**\n * Type of DataSchema. In combination with the name is used for unique identification of {@link DataSchema}.\n */\nvar ɵDataSchemaType = /*#__PURE__*/(() => {\n  (function (ɵDataSchemaType) {\n    ɵDataSchemaType[\"Entity\"] = \"Entity\";\n    ɵDataSchemaType[\"ClientUnit\"] = \"ClientUnit\";\n  })(ɵDataSchemaType || (ɵDataSchemaType = {}));\n  return ɵDataSchemaType;\n})();\nvar ɵLogicalOperatorType = /*#__PURE__*/(() => {\n  (function (ɵLogicalOperatorType) {\n    ɵLogicalOperatorType[ɵLogicalOperatorType[\"And\"] = 0] = \"And\";\n    ɵLogicalOperatorType[ɵLogicalOperatorType[\"Or\"] = 1] = \"Or\";\n  })(ɵLogicalOperatorType || (ɵLogicalOperatorType = {}));\n  return ɵLogicalOperatorType;\n})();\nvar ɵAggregationEvalType = /*#__PURE__*/(() => {\n  (function (ɵAggregationEvalType) {\n    /** The scope of the aggregating function is not defined. */\n    ɵAggregationEvalType[ɵAggregationEvalType[\"None\"] = 0] = \"None\";\n    /** Applies to all elements. */\n    ɵAggregationEvalType[ɵAggregationEvalType[\"All\"] = 1] = \"All\";\n    /** Applies to unique values. */\n    ɵAggregationEvalType[ɵAggregationEvalType[\"Distinct\"] = 2] = \"Distinct\";\n  })(ɵAggregationEvalType || (ɵAggregationEvalType = {}));\n  return ɵAggregationEvalType;\n})();\nvar ɵArithmeticOperation = /*#__PURE__*/(() => {\n  (function (ɵArithmeticOperation) {\n    /** Addition. */\n    ɵArithmeticOperation[ɵArithmeticOperation[\"Addition\"] = 0] = \"Addition\";\n    /** Subtraction. */\n    ɵArithmeticOperation[ɵArithmeticOperation[\"Subtraction\"] = 1] = \"Subtraction\";\n    /** Multiplication. */\n    ɵArithmeticOperation[ɵArithmeticOperation[\"Multiplication\"] = 2] = \"Multiplication\";\n    /** Division. */\n    ɵArithmeticOperation[ɵArithmeticOperation[\"Division\"] = 3] = \"Division\";\n  })(ɵArithmeticOperation || (ɵArithmeticOperation = {}));\n  return ɵArithmeticOperation;\n})();\n/* eslint-disable @typescript-eslint/naming-convention */\nvar ɵComparisonType = /*#__PURE__*/(() => {\n  (function (ɵComparisonType) {\n    ɵComparisonType[ɵComparisonType[\"Between\"] = 0] = \"Between\";\n    ɵComparisonType[ɵComparisonType[\"Contain\"] = 11] = \"Contain\";\n    ɵComparisonType[ɵComparisonType[\"End_with\"] = 13] = \"End_with\";\n    ɵComparisonType[ɵComparisonType[\"Equal\"] = 3] = \"Equal\";\n    ɵComparisonType[ɵComparisonType[\"Exists\"] = 15] = \"Exists\";\n    ɵComparisonType[ɵComparisonType[\"Greater\"] = 7] = \"Greater\";\n    ɵComparisonType[ɵComparisonType[\"Greater_or_equal\"] = 8] = \"Greater_or_equal\";\n    ɵComparisonType[ɵComparisonType[\"Is_not_null\"] = 2] = \"Is_not_null\";\n    ɵComparisonType[ɵComparisonType[\"Is_null\"] = 1] = \"Is_null\";\n    ɵComparisonType[ɵComparisonType[\"Less\"] = 5] = \"Less\";\n    ɵComparisonType[ɵComparisonType[\"Less_or_equal\"] = 6] = \"Less_or_equal\";\n    ɵComparisonType[ɵComparisonType[\"Not_contain\"] = 12] = \"Not_contain\";\n    ɵComparisonType[ɵComparisonType[\"Not_end_with\"] = 14] = \"Not_end_with\";\n    ɵComparisonType[ɵComparisonType[\"Not_equal\"] = 4] = \"Not_equal\";\n    ɵComparisonType[ɵComparisonType[\"Not_exists\"] = 16] = \"Not_exists\";\n    ɵComparisonType[ɵComparisonType[\"Not_start_with\"] = 10] = \"Not_start_with\";\n    ɵComparisonType[ɵComparisonType[\"Start_with\"] = 9] = \"Start_with\";\n  })(ɵComparisonType || (ɵComparisonType = {}));\n  return ɵComparisonType;\n})();\nvar ɵDatePartType = /*#__PURE__*/(() => {\n  (function (ɵDatePartType) {\n    /** Empty value. */\n    ɵDatePartType[ɵDatePartType[\"None\"] = 0] = \"None\";\n    /** Day. */\n    ɵDatePartType[ɵDatePartType[\"Day\"] = 1] = \"Day\";\n    /** Week. */\n    ɵDatePartType[ɵDatePartType[\"Week\"] = 2] = \"Week\";\n    /** Month. */\n    ɵDatePartType[ɵDatePartType[\"Month\"] = 3] = \"Month\";\n    /** Year. */\n    ɵDatePartType[ɵDatePartType[\"Year\"] = 4] = \"Year\";\n    /** Day of the week. */\n    ɵDatePartType[ɵDatePartType[\"WeekDay\"] = 5] = \"WeekDay\";\n    /** Hour. */\n    ɵDatePartType[ɵDatePartType[\"Hour\"] = 6] = \"Hour\";\n    /** Minute. */\n    ɵDatePartType[ɵDatePartType[\"HourMinute\"] = 7] = \"HourMinute\";\n  })(ɵDatePartType || (ɵDatePartType = {}));\n  return ɵDatePartType;\n})();\nvar ɵExpressionType = /*#__PURE__*/(() => {\n  (function (ɵExpressionType) {\n    ɵExpressionType[ɵExpressionType[\"SchemaColumn\"] = 0] = \"SchemaColumn\";\n    ɵExpressionType[ɵExpressionType[\"Function\"] = 1] = \"Function\";\n    ɵExpressionType[ɵExpressionType[\"Parameter\"] = 2] = \"Parameter\";\n    ɵExpressionType[ɵExpressionType[\"SubQuery\"] = 3] = \"SubQuery\";\n    ɵExpressionType[ɵExpressionType[\"ArithmeticOperation\"] = 4] = \"ArithmeticOperation\";\n  })(ɵExpressionType || (ɵExpressionType = {}));\n  return ɵExpressionType;\n})();\nvar ɵFilterType = /*#__PURE__*/(() => {\n  (function (ɵFilterType) {\n    ɵFilterType[ɵFilterType[\"None\"] = 0] = \"None\";\n    ɵFilterType[ɵFilterType[\"Compare\"] = 1] = \"Compare\";\n    ɵFilterType[ɵFilterType[\"IsNull\"] = 2] = \"IsNull\";\n    ɵFilterType[ɵFilterType[\"Between\"] = 3] = \"Between\";\n    ɵFilterType[ɵFilterType[\"In\"] = 4] = \"In\";\n    ɵFilterType[ɵFilterType[\"Exists\"] = 5] = \"Exists\";\n    ɵFilterType[ɵFilterType[\"FilterGroup\"] = 6] = \"FilterGroup\";\n  })(ɵFilterType || (ɵFilterType = {}));\n  return ɵFilterType;\n})();\nvar ɵFunctionType = /*#__PURE__*/(() => {\n  (function (ɵFunctionType) {\n    ɵFunctionType[ɵFunctionType[\"None\"] = 0] = \"None\";\n    /** Substitution by macro. */\n    ɵFunctionType[ɵFunctionType[\"Macros\"] = 1] = \"Macros\";\n    /** Aggregating function. */\n    ɵFunctionType[ɵFunctionType[\"Aggregation\"] = 2] = \"Aggregation\";\n    /** Date fragment. */\n    ɵFunctionType[ɵFunctionType[\"DatePart\"] = 3] = \"DatePart\";\n    /** The size of the value in bytes, used for binary data. */\n    ɵFunctionType[ɵFunctionType[\"Length\"] = 4] = \"Length\";\n    /** Window query function */\n    ɵFunctionType[ɵFunctionType[\"Window\"] = 5] = \"Window\";\n    /** Date add. */\n    ɵFunctionType[ɵFunctionType[\"DateAdd\"] = 6] = \"DateAdd\";\n    /** Date diff. */\n    ɵFunctionType[ɵFunctionType[\"DateDiff\"] = 7] = \"DateDiff\";\n  })(ɵFunctionType || (ɵFunctionType = {}));\n  return ɵFunctionType;\n})();\nvar ɵOrderDirection = /*#__PURE__*/(() => {\n  (function (ɵOrderDirection) {\n    ɵOrderDirection[ɵOrderDirection[\"None\"] = 0] = \"None\";\n    ɵOrderDirection[ɵOrderDirection[\"Asc\"] = 1] = \"Asc\";\n    ɵOrderDirection[ɵOrderDirection[\"Desc\"] = 2] = \"Desc\";\n  })(ɵOrderDirection || (ɵOrderDirection = {}));\n  return ɵOrderDirection;\n})();\nvar ɵQueryMacrosType = /*#__PURE__*/(() => {\n  (function (ɵQueryMacrosType) {\n    /** Macro type not defined. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"None\"] = 0] = \"None\";\n    /** Current user. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentUser\"] = 1] = \"CurrentUser\";\n    /** Current user contact. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentUserContact\"] = 2] = \"CurrentUserContact\";\n    /** Yesterday. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"Yesterday\"] = 3] = \"Yesterday\";\n    /** Today. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"Today\"] = 4] = \"Today\";\n    /** Tomorrow. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"Tomorrow\"] = 5] = \"Tomorrow\";\n    /** Previous week. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousWeek\"] = 6] = \"PreviousWeek\";\n    /** This week. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentWeek\"] = 7] = \"CurrentWeek\";\n    /** Next week. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextWeek\"] = 8] = \"NextWeek\";\n    /** Previous month. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousMonth\"] = 9] = \"PreviousMonth\";\n    /** Current month. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentMonth\"] = 10] = \"CurrentMonth\";\n    /** Next month. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextMonth\"] = 11] = \"NextMonth\";\n    /** Previous quarter. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousQuarter\"] = 12] = \"PreviousQuarter\";\n    /** Current quarter. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentQuarter\"] = 13] = \"CurrentQuarter\";\n    /** Next quarter. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextQuarter\"] = 14] = \"NextQuarter\";\n    /** Previous half of the year. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousHalfYear\"] = 15] = \"PreviousHalfYear\";\n    /** Current half-year. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentHalfYear\"] = 16] = \"CurrentHalfYear\";\n    /** Next half-year. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextHalfYear\"] = 17] = \"NextHalfYear\";\n    /** Last year. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousYear\"] = 18] = \"PreviousYear\";\n    /** This year. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentYear\"] = 19] = \"CurrentYear\";\n    /** Previous hour. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousHour\"] = 20] = \"PreviousHour\";\n    /** Current hour. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"CurrentHour\"] = 21] = \"CurrentHour\";\n    /** Next hour. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextHour\"] = 22] = \"NextHour\";\n    /** Next year. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextYear\"] = 23] = \"NextYear\";\n    /** Next N Days. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextNDays\"] = 24] = \"NextNDays\";\n    /** Previous N days. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousNDays\"] = 25] = \"PreviousNDays\";\n    /** Next N hours. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextNHours\"] = 26] = \"NextNHours\";\n    /** Previous N hours. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousNHours\"] = 27] = \"PreviousNHours\";\n    /** Primary column. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PrimaryColumn\"] = 34] = \"PrimaryColumn\";\n    /** Primary displayed column. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PrimaryDisplayColumn\"] = 35] = \"PrimaryDisplayColumn\";\n    /** Primary image display column. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PrimaryImageColumn\"] = 36] = \"PrimaryImageColumn\";\n    /** Anniversary today. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"DayOfYearToday\"] = 37] = \"DayOfYearToday\";\n    /** Anniversary on the date computed as today plus days offset. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"DayOfYearTodayPlusDaysOffset\"] = 38] = \"DayOfYearTodayPlusDaysOffset\";\n    /** Anniversary on the next several days. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"NextNDaysOfYear\"] = 39] = \"NextNDaysOfYear\";\n    /** Anniversary on the previous several days. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PreviousNDaysOfYear\"] = 40] = \"PreviousNDaysOfYear\";\n    /** Primary color display column. */\n    ɵQueryMacrosType[ɵQueryMacrosType[\"PrimaryColorColumn\"] = 41] = \"PrimaryColorColumn\";\n  })(ɵQueryMacrosType || (ɵQueryMacrosType = {}));\n  return ɵQueryMacrosType;\n})();\nlet ɵBaseExpression = /*#__PURE__*/(() => {\n  class ɵBaseExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [this._instanceOfKey];\n    }\n    static [Symbol.hasInstance](instance) {\n      const instanceOfKeys = instance?.constructor?.['_instanceOfKeys'] ?? [];\n      return instanceOfKeys.includes(this._instanceOfKey);\n    }\n    constructor(config) {\n      this.isBlock = false;\n      this.isBlock = config?.isBlock;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      throw new Error(`fromJson not supported on expression type ${this.constructor.name}`);\n    }\n    serializeItem(item) {\n      return typeof item.toJson === 'function' ? item.toJson() : classToPlain(item, {\n        exposeUnsetFields: false,\n        excludePrefixes: ['_']\n      });\n    }\n    /**\n     * Converts instance to json object.\n     * @public\n     */\n    toJson() {\n      return classToPlain(this, {\n        exposeUnsetFields: false,\n        excludePrefixes: ['_']\n      });\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵBaseExpression._instanceOfKey = 'devkit_BaseExpression';\n  return ɵBaseExpression;\n})();\nlet ɵArithmeticExpression = /*#__PURE__*/(() => {\n  class ɵArithmeticExpression extends ɵBaseExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.expressionType = ɵExpressionType.ArithmeticOperation;\n      this.arithmeticOperation = config?.arithmeticOperation;\n      this.leftArithmeticOperand = config?.leftArithmeticOperand.clone();\n      this.rightArithmeticOperand = config?.rightArithmeticOperand.clone();\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const leftArithmeticOperand = expressionParser?.fromJson(dto['leftArithmeticOperand'], filterParser);\n      const rightArithmeticOperand = expressionParser?.fromJson(dto['rightArithmeticOperand'], filterParser);\n      const config = {\n        leftArithmeticOperand,\n        rightArithmeticOperand,\n        arithmeticOperation: dto['arithmeticOperation'],\n        isBlock: dto['isBlock']\n      };\n      return new ɵArithmeticExpression(config);\n    }\n    clone() {\n      return new ɵArithmeticExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵArithmeticExpression._instanceOfKey = 'devkit_ArithmeticExpression';\n  return ɵArithmeticExpression;\n})();\nlet ɵColumnExpression = /*#__PURE__*/(() => {\n  class ɵColumnExpression extends ɵBaseExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.expressionType = ɵExpressionType.SchemaColumn;\n      this.columnPath = config?.columnPath;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto) {\n      const expression = new ɵColumnExpression({\n        columnPath: dto['columnPath']\n      });\n      return expression;\n    }\n    clone() {\n      return new ɵColumnExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵColumnExpression._instanceOfKey = 'devkit_ColumnExpression';\n\n  /**\n   * Expression parser interface\n   * @public\n   */\n  return ɵColumnExpression;\n})();\nclass ɵBaseExpressionParser {\n  static fromJson(dto, filterParser) {\n    throw new Error('not implemented');\n  }\n}\nlet ɵFunctionExpression = /*#__PURE__*/(() => {\n  class ɵFunctionExpression extends ɵBaseExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.expressionType = ɵExpressionType.Function;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵFunctionExpression._instanceOfKey = 'devkit_FunctionExpression';\n  return ɵFunctionExpression;\n})();\nlet ɵArgumentFunctionExpression = /*#__PURE__*/(() => {\n  class ɵArgumentFunctionExpression extends ɵFunctionExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵFunctionExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.functionArgument = config?.functionArgument.clone();\n    }\n    toJson() {\n      const result = super.toJson();\n      if (this.functionArgument) {\n        result['functionArgument'] = this.serializeItem(this.functionArgument);\n      }\n      return result;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵArgumentFunctionExpression._instanceOfKey = 'devkit_ArgumentFunctionExpression';\n  return ɵArgumentFunctionExpression;\n})();\nlet ɵAggregationFunctionExpression = /*#__PURE__*/(() => {\n  class ɵAggregationFunctionExpression extends ɵArgumentFunctionExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.functionType = ɵFunctionType.Aggregation;\n      this.aggregationType = config?.aggregationType;\n      this.aggregationEvalType = config?.aggregationEvalType;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);\n      const aggregationType = dto['aggregationType'];\n      const aggregationEvalType = dto['aggregationEvalType'];\n      return new ɵAggregationFunctionExpression({\n        functionArgument,\n        aggregationType,\n        aggregationEvalType,\n        isBlock: dto['isBlock']\n      });\n    }\n    clone() {\n      return new ɵAggregationFunctionExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵAggregationFunctionExpression._instanceOfKey = 'devkit_AggregationFunctionExpression';\n  return ɵAggregationFunctionExpression;\n})();\nlet ɵDatePartFunctionExpression = /*#__PURE__*/(() => {\n  class ɵDatePartFunctionExpression extends ɵArgumentFunctionExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.functionType = ɵFunctionType.DatePart;\n      this.datePartType = config?.datePartType;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);\n      const datePartType = dto['datePartType'];\n      return new ɵDatePartFunctionExpression({\n        functionArgument,\n        datePartType,\n        isBlock: dto['isBlock']\n      });\n    }\n    clone() {\n      return new ɵDatePartFunctionExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵDatePartFunctionExpression._instanceOfKey = 'devkit_DatePartFunctionExpression';\n  return ɵDatePartFunctionExpression;\n})();\nlet ɵLengthFunctionExpression = /*#__PURE__*/(() => {\n  class ɵLengthFunctionExpression extends ɵArgumentFunctionExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.functionType = ɵFunctionType.Length;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);\n      return new ɵLengthFunctionExpression({\n        functionArgument,\n        isBlock: dto['isBlock']\n      });\n    }\n    clone() {\n      return new ɵLengthFunctionExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵLengthFunctionExpression._instanceOfKey = 'devkit_LengthFunctionExpression';\n  return ɵLengthFunctionExpression;\n})();\nlet ɵMacrosFunctionExpression = /*#__PURE__*/(() => {\n  class ɵMacrosFunctionExpression extends ɵFunctionExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵFunctionExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.functionType = ɵFunctionType.Macros;\n      this.macrosType = config?.macrosType;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto) {\n      const expression = new ɵMacrosFunctionExpression({\n        macrosType: dto['macrosType']\n      });\n      return expression;\n    }\n    clone() {\n      return new ɵMacrosFunctionExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵMacrosFunctionExpression._instanceOfKey = 'devkit_MacrosFunctionExpression';\n  return ɵMacrosFunctionExpression;\n})();\nlet ɵWindowFunctionExpression = /*#__PURE__*/(() => {\n  class ɵWindowFunctionExpression extends ɵArgumentFunctionExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵArgumentFunctionExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.functionType = ɵFunctionType.Window;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const functionArgument = expressionParser?.fromJson(dto['functionArgument'], filterParser);\n      return new ɵWindowFunctionExpression({\n        functionArgument,\n        isBlock: dto['isBlock']\n      });\n    }\n    clone() {\n      return new ɵWindowFunctionExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵWindowFunctionExpression._instanceOfKey = 'devkit_WindowFunctionExpression';\n  return ɵWindowFunctionExpression;\n})();\nlet ɵParameterExpression = /*#__PURE__*/(() => {\n  class ɵParameterExpression extends ɵBaseExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.expressionType = ɵExpressionType.Parameter;\n      const value = config?.value;\n      if (value instanceof Date) {\n        const cloneDate = new Date();\n        cloneDate.setTime(value.getTime());\n        this.value = cloneDate;\n      } else if (!value) {\n        this.value = value;\n      } else {\n        this.value = typeof value === 'object' ? {\n          ...value\n        } : value;\n      }\n      this.dataValueType = config?.dataValueType ?? ɵDataValueType.Text;\n      this.parameter = {\n        dataValueType: this.dataValueType,\n        ...this._getParameterValueMetadata()\n      };\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto) {\n      const expression = new ɵParameterExpression(dto['parameter']);\n      return expression;\n    }\n    _convertStringToBlobArray(str) {\n      const out = [];\n      let position = 0;\n      for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n        if (code < 128) {\n          out[position++] = String.fromCharCode(code);\n        } else if (code < 2048) {\n          /* eslint-disable no-bitwise */\n          out[position++] = String.fromCharCode(code >> 6 | 192);\n          out[position++] = String.fromCharCode(code & 63 | 128);\n        } else {\n          out[position++] = String.fromCharCode(code >> 12 | 224);\n          out[position++] = String.fromCharCode(code >> 6 & 63 | 128);\n          out[position++] = String.fromCharCode(code & 63 | 128);\n          /* eslint-enable no-bitwise */\n        }\n      }\n\n      return out;\n    }\n    _getParameterValueMetadata() {\n      if (this.dataValueType === ɵDataValueType.Blob) {\n        return {\n          arrayValue: !this.value ? [] : this._convertStringToBlobArray(this.value)\n        };\n      } else if (this.value instanceof Date) {\n        return {\n          value: ɵencodeDate(this.value)\n        };\n      } else {\n        return {\n          value: this.value\n        };\n      }\n    }\n    clone() {\n      return new ɵParameterExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵParameterExpression._instanceOfKey = 'devkit_ParameterExpression';\n  __decorate([Exclude(), __metadata(\"design:type\", Object)], ɵParameterExpression.prototype, \"value\", void 0);\n  __decorate([Exclude(), __metadata(\"design:type\", Number)], ɵParameterExpression.prototype, \"dataValueType\", void 0);\n  return ɵParameterExpression;\n})();\nlet ɵSubQueryExpression = /*#__PURE__*/(() => {\n  class ɵSubQueryExpression extends ɵBaseExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.expressionType = ɵExpressionType.SubQuery;\n      this.columnPath = config?.columnPath;\n      const subFilter = config?.subFilters;\n      this.subFilters = typeof subFilter?.clone === 'function' ? subFilter.clone() : subFilter;\n      this.subOrderDirection = config.subOrderDirection;\n      this.subOrderColumn = config.subOrderColumn;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser) {\n      const expression = new ɵSubQueryExpression({\n        columnPath: dto['columnPath'],\n        subFilters: filterParser.fromJson(dto['subFilters']),\n        subOrderDirection: dto['subOrderDirection'],\n        subOrderColumn: dto['subOrderColumn']\n      });\n      return expression;\n    }\n    clone() {\n      return new ɵSubQueryExpression(this);\n    }\n    toJson() {\n      const result = super.toJson();\n      if (this.subFilters) {\n        result['subFilters'] = this.serializeItem(this.subFilters);\n      }\n      return result;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵSubQueryExpression._instanceOfKey = 'devkit_SubQueryExpression';\n  return ɵSubQueryExpression;\n})();\nlet ɵAggregationSubQueryExpression = /*#__PURE__*/(() => {\n  class ɵAggregationSubQueryExpression extends ɵSubQueryExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵSubQueryExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config);\n      this.aggregationType = config?.aggregationType;\n      this.functionType = config?.functionType;\n    }\n    /**\n     * Parses expression from json.\n     * @public\n     */\n    static fromJson(dto, filterParser) {\n      const subQueryExpression = super.fromJson(dto, filterParser);\n      const expression = new ɵAggregationSubQueryExpression({\n        aggregationType: dto['aggregationType'],\n        functionType: dto['functionType'],\n        ...subQueryExpression\n      });\n      return expression;\n    }\n    clone() {\n      return new ɵAggregationSubQueryExpression(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵAggregationSubQueryExpression._instanceOfKey = 'devkit_AggregationSubQueryExpression';\n\n  /**\n   * Function expression resolver.\n   * @public\n   */\n  return ɵAggregationSubQueryExpression;\n})();\nclass FunctionExpressionResolver {\n  static resolve(dto) {\n    const expressionClass = {\n      [ɵFunctionType.Macros]: ɵMacrosFunctionExpression,\n      [ɵFunctionType.Length]: ɵLengthFunctionExpression,\n      [ɵFunctionType.Window]: ɵWindowFunctionExpression,\n      [ɵFunctionType.DatePart]: ɵDatePartFunctionExpression,\n      [ɵFunctionType.DateAdd]: ɵDatePartFunctionExpression,\n      [ɵFunctionType.DateDiff]: ɵDatePartFunctionExpression\n    };\n    return expressionClass[dto['functionType']];\n  }\n}\n/**\n * Expression resolver.\n * @public\n */\nclass ɵExpressionResolver {\n  static resolve(expressionType, dto) {\n    const expressionClass = {\n      [ɵExpressionType.SchemaColumn]: ɵColumnExpression,\n      [ɵExpressionType.Parameter]: ɵParameterExpression,\n      [ɵExpressionType.SubQuery]: ɵAggregationSubQueryExpression,\n      [ɵExpressionType.ArithmeticOperation]: ɵArithmeticExpression,\n      [ɵExpressionType.Function]: FunctionExpressionResolver.resolve(dto)\n    };\n    return expressionClass[expressionType];\n  }\n}\n\n/**\n * Expression parser.\n * @public\n */\nclass ɵExpressionParser extends ɵBaseExpressionParser {\n  /**\n   * Parses expression from json.\n   * @public\n   */\n  static fromJson(dto, filterParser) {\n    const expressionType = dto['expressionType'];\n    return ɵExpressionResolver.resolve(expressionType, dto).fromJson(dto, filterParser, ɵExpressionParser);\n  }\n}\nconst ɵEXPRESSION_TYPE_MOCK = -1;\nlet ɵExpressionMock = /*#__PURE__*/(() => {\n  class ɵExpressionMock extends ɵBaseExpression {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseExpression._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(config) {\n      super(config || {});\n      this.expressionType = ɵEXPRESSION_TYPE_MOCK;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    get plainObject() {\n      return classToPlain(this, {\n        exposeUnsetFields: false,\n        excludePrefixes: ['_']\n      });\n    }\n    clone() {\n      return new ɵExpressionMock(this);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵExpressionMock._instanceOfKey = 'devkit_ExpressionMock';\n  return ɵExpressionMock;\n})();\nlet ɵBaseFilter = /*#__PURE__*/(() => {\n  class ɵBaseFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [this._instanceOfKey];\n    }\n    static [Symbol.hasInstance](instance) {\n      const instanceOfKeys = instance?.constructor?.['_instanceOfKeys'] ?? [];\n      return instanceOfKeys.includes(this._instanceOfKey);\n    }\n    constructor(filterType) {\n      this.isEnabled = true;\n      this.trimDateTimeParameterToDate = false;\n      this.filterType = filterType;\n    }\n    /**\n     * Parses filter from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      throw new Error(`fromJson not supported on filter type ${this.constructor.name}`);\n    }\n    serializeItem(item) {\n      return typeof item.toJson === 'function' ? item.toJson() : classToPlain(item, {\n        exposeUnsetFields: false,\n        excludePrefixes: ['_']\n      });\n    }\n    /**\n     * Converts instance to json object.\n     * @public\n     */\n    toJson() {\n      return classToPlain(this, {\n        exposeUnsetFields: false,\n        excludePrefixes: ['_']\n      });\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵBaseFilter._instanceOfKey = 'devkit_BaseFilter';\n  return ɵBaseFilter;\n})();\nlet ɵFilterMock = /*#__PURE__*/(() => {\n  class ɵFilterMock extends ɵBaseFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(filterType = ɵFilterType.None) {\n      super(filterType);\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    get plainObject() {\n      return classToPlain(this, {\n        exposeUnsetFields: false,\n        excludePrefixes: ['_']\n      });\n    }\n    clone() {\n      return new ɵFilterMock(this.filterType);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵFilterMock._instanceOfKey = 'devkit_FilterMock';\n  return ɵFilterMock;\n})();\nconst ɵparserMock = {\n  fromJson: data => ({\n    ...data,\n    clone: () => data\n  }),\n  clone: () => this\n};\nlet ɵSingleFilter = /*#__PURE__*/(() => {\n  class ɵSingleFilter extends ɵBaseFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(filterType, comparisonType, leftExpression) {\n      super(filterType);\n      this.comparisonType = comparisonType;\n      this.leftExpression = leftExpression.clone();\n    }\n    toJson() {\n      return {\n        ...super.toJson(),\n        leftExpression: this.serializeItem(this.leftExpression)\n      };\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵSingleFilter._instanceOfKey = 'devkit_SingleFilter';\n  return ɵSingleFilter;\n})();\nlet ɵCompareFilter = /*#__PURE__*/(() => {\n  class ɵCompareFilter extends ɵSingleFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(comparisonType, leftExpression, rightExpression) {\n      super(ɵFilterType.Compare, comparisonType, leftExpression);\n      this.rightExpression = rightExpression.clone();\n    }\n    /**\n     * Parses filter from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const filter = new ɵCompareFilter(dto['comparisonType'], expressionParser.fromJson(dto['leftExpression'], filterParser), expressionParser.fromJson(dto['rightExpression'], filterParser));\n      return filter;\n    }\n    clone() {\n      return new ɵCompareFilter(this.comparisonType, this.leftExpression, this.rightExpression);\n    }\n    toJson() {\n      return {\n        ...super.toJson(),\n        rightExpression: this.serializeItem(this.rightExpression)\n      };\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵCompareFilter._instanceOfKey = 'devkit_CompareFilter';\n  return ɵCompareFilter;\n})();\nlet ɵBetweenFilter = /*#__PURE__*/(() => {\n  class ɵBetweenFilter extends ɵSingleFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(leftExpression, rightLessExpression, rightGreaterExpression) {\n      super(ɵFilterType.Between, ɵComparisonType.Between, leftExpression);\n      this.rightLessExpression = rightLessExpression.clone();\n      this.rightGreaterExpression = rightGreaterExpression.clone();\n    }\n    /**\n     * Parses filter from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const filter = new ɵBetweenFilter(expressionParser.fromJson(dto['leftExpression'], filterParser), expressionParser.fromJson(dto['rightLessExpression'], filterParser), expressionParser.fromJson(dto['rightGreaterExpression'], filterParser));\n      return filter;\n    }\n    clone() {\n      return new ɵBetweenFilter(this.leftExpression, this.rightLessExpression, this.rightGreaterExpression);\n    }\n    toJson() {\n      return {\n        ...super.toJson(),\n        rightLessExpression: this.serializeItem(this.rightLessExpression),\n        rightGreaterExpression: this.serializeItem(this.rightGreaterExpression)\n      };\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵBetweenFilter._instanceOfKey = 'devkit_BetweenFilter';\n  return ɵBetweenFilter;\n})();\nlet ɵExistsFilter = /*#__PURE__*/(() => {\n  class ɵExistsFilter extends ɵSingleFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(leftExpression, subFilters, comparisonType = ɵComparisonType.Exists, isAggregative = true) {\n      super(ɵFilterType.Exists, comparisonType, leftExpression);\n      this.subFilters = subFilters?.clone();\n      this.isAggregative = isAggregative;\n    }\n    /**\n     * Parses filter from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const leftExpression = expressionParser.fromJson(dto['leftExpression'], filterParser);\n      const subFilters = filterParser.fromJson(dto['subFilters']);\n      return new ɵExistsFilter(leftExpression, subFilters, dto['comparisonType'], dto['isAggregative']);\n    }\n    clone() {\n      return new ɵExistsFilter(this.leftExpression, this.subFilters, this.comparisonType, this.isAggregative);\n    }\n    toJson() {\n      const result = super.toJson();\n      if (this.subFilters) {\n        result['subFilters'] = this.serializeItem(this.subFilters);\n      }\n      return result;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵExistsFilter._instanceOfKey = 'devkit_ExistsFilter';\n  return ɵExistsFilter;\n})();\nlet ɵInFilter = /*#__PURE__*/(() => {\n  class ɵInFilter extends ɵSingleFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(comparisonType, leftExpression, rightExpressions) {\n      super(ɵFilterType.In, comparisonType, leftExpression);\n      this.rightExpressions = rightExpressions.map(expression => expression.clone());\n    }\n    /**\n     * Parses in filter from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      const dtoRightExpressions = dto['rightExpressions'] ?? [];\n      return new ɵInFilter(dto['comparisonType'], expressionParser.fromJson(dto['leftExpression'], filterParser), dtoRightExpressions.map(expression => expressionParser.fromJson(expression, filterParser)));\n    }\n    clone() {\n      return new ɵInFilter(this.comparisonType, this.leftExpression, this.rightExpressions);\n    }\n    toJson() {\n      return {\n        ...super.toJson(),\n        rightExpressions: this.rightExpressions.map(expression => this.serializeItem(expression))\n      };\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵInFilter._instanceOfKey = 'devkit_InFilter';\n  return ɵInFilter;\n})();\nlet ɵIsNullFilter = /*#__PURE__*/(() => {\n  class ɵIsNullFilter extends ɵSingleFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵSingleFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    constructor(comparisonType, leftExpression) {\n      super(ɵFilterType.IsNull, comparisonType, leftExpression);\n    }\n    get isNull() {\n      return this.comparisonType === ɵComparisonType.Is_null;\n    }\n    /**\n     * Parses isNull filter from json.\n     * @public\n     */\n    static fromJson(dto, filterParser, expressionParser) {\n      return new ɵIsNullFilter(dto['comparisonType'], expressionParser.fromJson(dto['leftExpression'], filterParser));\n    }\n    clone() {\n      return new ɵIsNullFilter(this.comparisonType, this.leftExpression);\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵIsNullFilter._instanceOfKey = 'devkit_IsNullFilter';\n  __decorate([Expose(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], ɵIsNullFilter.prototype, \"isNull\", null);\n\n  /**\n   * Empty Guid constant.\n   * @public\n   */\n  return ɵIsNullFilter;\n})();\nconst ɵEMPTY_GUID = '00000000-0000-0000-0000-000000000000';\n/**\n * Regular expression for Guid validation.\n * @public\n */\nconst validator = new RegExp('^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$', 'i');\n/**\n * Generates guid part.\n * @param length Part length.\n * @public\n */\nfunction generateGuidPart(length) {\n  let out = '';\n  for (let i = 0; i < length; i++) {\n    // eslint-disable-next-line no-bitwise\n    out += ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n  }\n  return out;\n}\n/**\n * Generates new Guid.\n * @public\n */\nfunction ɵgenerateGuid() {\n  return [generateGuidPart(2), generateGuidPart(1), generateGuidPart(1), generateGuidPart(1), generateGuidPart(3)].join('-');\n}\n/**\n * Checks if value is Guid.\n * @param value Value for check.\n * @public\n */\nfunction ɵisGuid(value) {\n  return Boolean(value) && validator.test(value);\n}\n/**\n * Checks if Guid is empty value or equal to EMPTY_GUID.\n * @param guid Guid for check.\n * @public\n */\nfunction ɵisEmptyGuid(guid) {\n  return !guid || guid === ɵEMPTY_GUID;\n}\n\n/**\n * @public\n */\nclass ɵNextHandlerAlreadySpecifiedException extends Error {\n  constructor() {\n    super('Next handler already specified');\n  }\n}\nclass ɵArgumentEmptyException extends Error {\n  // region Constructors: Public\n  constructor(argumentName) {\n    super(`Argument with name '${argumentName}' is empty.`);\n  }\n}\nclass ɵArgumentOutOfRangeException extends Error {\n  // region Constructors: Public\n  constructor(argumentName) {\n    super(`Argument with name '${argumentName}' is out of range.`);\n  }\n}\nclass ɵItemNotFoundException extends Error {\n  // region Constructors: Public\n  constructor(key) {\n    super(`Item with key '${key}' does not exist.`);\n  }\n}\nclass ɵValidationUtilities {\n  // region Methods: Public\n  static checkArgumentEmpty(argumentName, argumentValue) {\n    if (argumentValue === undefined || argumentValue === null) {\n      throw new ɵArgumentEmptyException(argumentName);\n    }\n  }\n  static checkArrayEmpty(argumentName, argumentValue) {\n    ɵValidationUtilities.checkArgumentEmpty(argumentName, argumentValue);\n    if (argumentValue.length === 0) {\n      throw new ɵArgumentEmptyException(argumentName);\n    }\n  }\n  static checkStringIsNotEmpty(argumentName, argumentValue) {\n    this.checkArgumentEmpty(argumentName, argumentValue);\n    if (argumentValue === '') {\n      throw new ɵArgumentEmptyException(argumentName);\n    }\n    return argumentValue;\n  }\n  static checkArgumentOutOfRange(argumentName, argumentValue, range) {\n    if (range.begin && argumentValue < range.begin) {\n      throw new ɵArgumentOutOfRangeException(argumentName);\n    }\n    if (range.end && argumentValue > range.end) {\n      throw new ɵArgumentOutOfRangeException(argumentName);\n    }\n  }\n}\nlet ɵFilterGroup = /*#__PURE__*/(() => {\n  class ɵFilterGroup extends ɵBaseFilter {\n    /**\n     * @internal\n     * @dontChange\n     */\n    static get _instanceOfKeys() {\n      return [...ɵBaseFilter._instanceOfKeys, this._instanceOfKey];\n    }\n    get items() {\n      const result = {};\n      this.filters.forEach((filter, key) => {\n        result[key] = this.serializeItem(filter);\n      });\n      return result;\n    }\n    constructor(logicalOperation = ɵLogicalOperatorType.And) {\n      super(ɵFilterType.FilterGroup);\n      this.filters = new Map();\n      this.logicalOperation = logicalOperation;\n    }\n    /**\n     * Parses filter group from json.\n     * @public\n     */\n    static fromJson(dto, filterParser) {\n      const logicalOperation = dto['logicalOperation'];\n      const group = new ɵFilterGroup(logicalOperation || ɵLogicalOperatorType.And);\n      Object.entries(dto['items']).forEach(([key, filterDTO]) => {\n        group.add(filterParser.fromJson(filterDTO), key);\n      });\n      return group;\n    }\n    /**\n     * Returns filter item by index.\n     * @param index Item index.\n     * @returns Filter.\n     */\n    getItemByIndex(index) {\n      return this.items[Object.keys(this.items)[index]];\n    }\n    /**\n     * Creates and adds compare filter by value.\n     * @param comparisonType Comparison type.\n     * @param columnPath Column path.\n     * @param parameterValue Parameter value.\n     * @param filterKey Filter key.\n     */\n    addSchemaColumnFilterWithParameter(comparisonType, columnPath, parameterValue, filterKey) {\n      const leftExpression = new ɵColumnExpression({\n        columnPath\n      });\n      const rightExpression = new ɵParameterExpression({\n        value: parameterValue\n      });\n      const filter = new ɵCompareFilter(comparisonType, leftExpression, rightExpression);\n      this.add(filter, filterKey);\n    }\n    /**\n     * Creates and adds in filter by values.\n     * @param comparisonType Comparison type.\n     * @param columnPath Column path.\n     * @param parameterValues Parameter values.\n     * @param filterKey Filter key.\n     */\n    addSchemaColumnInFilterWithParameters(comparisonType, columnPath, parameterValues, filterKey) {\n      const leftExpression = new ɵColumnExpression({\n        columnPath\n      });\n      const expressions = parameterValues.map(singleParameterValue => new ɵParameterExpression({\n        value: singleParameterValue\n      }));\n      const filter = new ɵInFilter(comparisonType, leftExpression, expressions);\n      this.add(filter, filterKey);\n    }\n    addSchemaColumnIsNullFilter(columnPath, filterKey) {\n      const leftExpression = new ɵColumnExpression({\n        columnPath\n      });\n      const filter = new ɵIsNullFilter(ɵComparisonType.Is_null, leftExpression);\n      this.add(filter, filterKey);\n    }\n    /**\n     * Creates and adds not null filter.\n     * @param columnPath Column path.\n     * @param filterKey Filter key.\n     */\n    addSchemaColumnIsNotNullFilter(columnPath, filterKey) {\n      const leftExpression = new ɵColumnExpression({\n        columnPath\n      });\n      const filter = new ɵIsNullFilter(ɵComparisonType.Is_not_null, leftExpression);\n      this.add(filter, filterKey);\n    }\n    /**\n     * Creates and adds filter between less value and greater value.\n     * @param columnPath Column path.\n     * @param lessParamValue Less parameter value.\n     * @param greaterParamValue Greater parameter value.\n     * @param filterKey Filter key.\n     */\n    addSchemaColumnBetweenFilterWithParameters(columnPath, lessParamValue, greaterParamValue, filterKey) {\n      const leftExpression = new ɵColumnExpression({\n        columnPath\n      });\n      const rightLessExpression = new ɵParameterExpression({\n        value: lessParamValue\n      });\n      const rightGreaterExpression = new ɵParameterExpression({\n        value: greaterParamValue\n      });\n      const filter = new ɵBetweenFilter(leftExpression, rightLessExpression, rightGreaterExpression);\n      this.add(filter, filterKey);\n    }\n    addExistsFilter(columnPath, subFilters, filterKey) {\n      const leftExpression = new ɵColumnExpression({\n        columnPath\n      });\n      const filter = new ɵExistsFilter(leftExpression, subFilters);\n      this.add(filter, filterKey);\n    }\n    addNotExistsFilter(columnPath, subFilters, filterKey) {\n      const leftExpression = new ɵColumnExpression({\n        columnPath\n      });\n      const filter = new ɵExistsFilter(leftExpression, subFilters, ɵComparisonType.Not_exists);\n      this.add(filter, filterKey);\n    }\n    add(filter, filterKey) {\n      ɵValidationUtilities.checkArgumentEmpty('filter', filter);\n      const key = filterKey || ɵgenerateGuid();\n      this.filters.set(key, filter);\n    }\n    clone() {\n      const filterGroup = new ɵFilterGroup(this.logicalOperation);\n      this.filters.forEach((filter, filterKey) => {\n        filterGroup.filters.set(filterKey, filter.clone());\n      });\n      return filterGroup;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  ɵFilterGroup._instanceOfKey = 'devkit_FilterGroup';\n  __decorate([Exclude(), __metadata(\"design:type\", Object)], ɵFilterGroup.prototype, \"filters\", void 0);\n  __decorate([Expose(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], ɵFilterGroup.prototype, \"items\", null);\n\n  /**\n   * Filter parser interface\n   * @public\n   */\n  return ɵFilterGroup;\n})();\nclass ɵBaseFilterParser {\n  static fromJson(dto) {\n    throw new Error('not implemented');\n  }\n}\n\n/**\n * Filter resolver.\n * @public\n */\nclass ɵFilterResolver {\n  static resolve(filterType) {\n    const filterClass = {\n      [ɵFilterType.Compare]: ɵCompareFilter,\n      [ɵFilterType.FilterGroup]: ɵFilterGroup,\n      [ɵFilterType.In]: ɵInFilter,\n      [ɵFilterType.IsNull]: ɵIsNullFilter,\n      [ɵFilterType.Exists]: ɵExistsFilter,\n      [ɵFilterType.Between]: ɵBetweenFilter\n    };\n    return filterClass[filterType];\n  }\n}\n\n/**\n * Filter parser.\n * @public\n */\nclass ɵFilterParser extends ɵBaseFilterParser {\n  static fromJson(dto) {\n    const filterType = dto['filterType'];\n    return ɵFilterResolver.resolve(filterType).fromJson(dto, ɵFilterParser, ɵExpressionParser);\n  }\n}\nconst ɵDEFAULT_FILTER_PLAIN_OBJ = {\n  isEnabled: true,\n  trimDateTimeParameterToDate: false\n};\nfunction ɵgetFilterPlainObj(filterPlainObj) {\n  return {\n    ...ɵDEFAULT_FILTER_PLAIN_OBJ,\n    ...filterPlainObj\n  };\n}\nclass ɵBaseQueryColumn {\n  constructor(expression) {\n    this.orderDirection = ɵOrderDirection.None;\n    this.orderPosition = -1;\n    this.isVisible = true;\n    this.expression = expression;\n  }\n  /**\n   * Adds ordering options.\n   * @param orderDirection Direction.\n   * @param orderPosition Position.\n   * @returns Self.\n   */\n  withOrdering(orderDirection, orderPosition) {\n    ɵValidationUtilities.checkArgumentEmpty('orderDirection', orderDirection);\n    ɵValidationUtilities.checkArgumentEmpty('orderPosition', orderPosition);\n    ɵValidationUtilities.checkArgumentOutOfRange('orderPosition', orderPosition, {\n      begin: -1\n    });\n    this.orderDirection = orderDirection;\n    this.orderPosition = orderPosition;\n    return this;\n  }\n  /**\n   * Adds options.\n   * @param options Options.\n   * @returns Self.\n   */\n  withOptions(options) {\n    ɵValidationUtilities.checkArgumentEmpty('options', options);\n    this.isVisible = options.isVisible ?? true;\n    return this;\n  }\n  /**\n   * Adds caption.\n   * @param caption Caption.\n   * @returns Self.\n   */\n  withCaption(caption) {\n    ɵValidationUtilities.checkArgumentEmpty('caption', caption);\n    this.caption = caption;\n    return this;\n  }\n}\nclass ɵArithmeticQueryColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(arithmeticOperation, leftArithmeticOperand, rightArithmeticOperand) {\n    super(new ɵArithmeticExpression({\n      arithmeticOperation,\n      leftArithmeticOperand,\n      rightArithmeticOperand\n    }));\n  }\n}\nclass ɵEntityQueryColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(columnPath) {\n    super(new ɵColumnExpression({\n      columnPath\n    }));\n  }\n}\nclass ɵParameterQueryColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(value, dataValueType) {\n    super(new ɵParameterExpression({\n      value,\n      dataValueType\n    }));\n  }\n}\nclass ɵAggregationSubQueryColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(columnPath, aggregationType, subFilters, subOrderDirection, subOrderColumn) {\n    super(new ɵAggregationSubQueryExpression({\n      aggregationType,\n      columnPath,\n      subFilters,\n      subOrderDirection,\n      subOrderColumn\n    }));\n  }\n}\nclass ɵSubQueryColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(columnPath, subFilters) {\n    super(new ɵSubQueryExpression({\n      columnPath,\n      subFilters\n    }));\n  }\n}\nclass ɵAggregationFunctionColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(aggregationType, aggregationEvalType, functionArgument) {\n    super(new ɵAggregationFunctionExpression({\n      aggregationType,\n      aggregationEvalType,\n      functionArgument\n    }));\n  }\n}\nclass ɵDatePartFunctionColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(datePartType, functionArgument) {\n    super(new ɵDatePartFunctionExpression({\n      datePartType,\n      functionArgument\n    }));\n  }\n  // endregion\n  // region Properties: Public\n  get datePartType() {\n    return this.expression?.datePartType;\n  }\n}\nclass ɵLengthFunctionColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(functionArgument) {\n    super(new ɵLengthFunctionExpression({\n      functionArgument\n    }));\n  }\n}\nclass ɵMacrosFunctionColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(macrosType) {\n    super(new ɵMacrosFunctionExpression({\n      macrosType\n    }));\n  }\n}\nclass ɵWindowFunctionColumn extends ɵBaseQueryColumn {\n  // region Constructors: Public\n  constructor(functionArgument) {\n    super(new ɵWindowFunctionExpression({\n      functionArgument\n    }));\n  }\n}\nconst ɵDEFAULT_COLUMN_PLAIN_OBJ = {\n  isVisible: true,\n  orderPosition: -1,\n  orderDirection: ɵOrderDirection.None\n};\nfunction ɵgetColumnPlainObj(expressionPlainObj) {\n  return {\n    ...ɵDEFAULT_COLUMN_PLAIN_OBJ,\n    expression: expressionPlainObj\n  };\n}\n\n/**\n * @public\n */\nclass ɵBaseQuery {\n  // region Constructors: Protected\n  constructor(operationType, rootSchemaName) {\n    this.operationType = operationType;\n    this.rootSchemaName = rootSchemaName;\n    ɵValidationUtilities.checkArgumentEmpty('_operationType', operationType);\n    ɵValidationUtilities.checkArgumentEmpty('_rootSchemaName', rootSchemaName);\n  }\n  // endregion\n  // region Methods: Public\n  getMetadata() {\n    return classToPlain(this, {\n      exposeUnsetFields: false,\n      excludePrefixes: ['_']\n    });\n  }\n}\n\n/**\n * @public\n */\nclass ɵBaseFilterableQuery extends ɵBaseQuery {\n  constructor(operationType, rootSchemaName) {\n    super(operationType, rootSchemaName);\n    this.filters = new ɵFilterGroup();\n  }\n  clearFilters() {\n    this.filters.filters.clear();\n  }\n  getMetadata() {\n    return {\n      ...super.getMetadata(),\n      filters: this.filters.toJson()\n    };\n  }\n}\n\n/**\n * @public\n */\nvar ɵQueryOperationType = /*#__PURE__*/(() => {\n  (function (ɵQueryOperationType) {\n    ɵQueryOperationType[ɵQueryOperationType[\"Select\"] = 0] = \"Select\";\n    ɵQueryOperationType[ɵQueryOperationType[\"Insert\"] = 1] = \"Insert\";\n    ɵQueryOperationType[ɵQueryOperationType[\"Update\"] = 2] = \"Update\";\n    ɵQueryOperationType[ɵQueryOperationType[\"Delete\"] = 3] = \"Delete\";\n    // Batch,\n    // ListSelect,\n    // FilteredSelect,\n    // LookupSelect\n  })(ɵQueryOperationType || (ɵQueryOperationType = {}));\n  return ɵQueryOperationType;\n})();\n/**\n * @public\n */\nclass ɵDeleteQuery extends ɵBaseFilterableQuery {\n  // region Constructors: Public\n  constructor(rootSchemaName) {\n    super(ɵQueryOperationType.Delete, rootSchemaName);\n  }\n}\n\n/**\n * @public\n */\nclass ɵEntitySchemaQuery extends ɵBaseFilterableQuery {\n  constructor(rootSchemaName) {\n    super(ɵQueryOperationType.Select, rootSchemaName);\n    this._columns = new Map();\n    this.isDistinct = false;\n    /**\n     * Number of rows to select.\n     */\n    this.rowCount = -1;\n    /**\n     * Rows count to skip.\n     */\n    this.rowsOffset = -1;\n    this.useLocalization = true;\n    this.useRecordDeactivation = false;\n    this._getIsPageable = () => this.rowCount > 0 && this.rowsOffset > -1;\n  }\n  _internalAddColumn(key, column) {\n    if (!this._columns.has(key)) {\n      this._columns.set(key, column);\n    }\n  }\n  // endregion\n  // region Methods: Public\n  /**\n   * Returns column instance by column alias.\n   * @param columnAlias Column alias.\n   * @returns [BaseQueryColumn] Column instance.\n   */\n  getColumn(columnAlias) {\n    if (!this._columns.has(columnAlias)) {\n      throw new ɵItemNotFoundException(columnAlias);\n    }\n    return this.findColumn(columnAlias);\n  }\n  /**\n   * Returns column instance by column alias if not found returns null.\n   */\n  findColumn(columnAlias) {\n    return this._columns.get(columnAlias);\n  }\n  /**\n   * @inheritDoc\n   */\n  getMetadata() {\n    return {\n      ...super.getMetadata(),\n      columns: {\n        items: classToPlain(this._columns, {\n          exposeUnsetFields: false,\n          excludePrefixes: ['_']\n        })\n      },\n      allColumns: false,\n      isDistinct: this.isDistinct,\n      ignoreDisplayValues: false,\n      rowCount: this.rowCount,\n      rowsOffset: this.rowsOffset,\n      isPageable: this._getIsPageable(),\n      conditionalValues: this.conditionalValues ? this.conditionalValues : null,\n      isHierarchical: false,\n      hierarchicalMaxDepth: 0,\n      hierarchicalColumnName: null,\n      hierarchicalColumnValue: null,\n      useLocalization: this.useLocalization,\n      useRecordDeactivation: this.useRecordDeactivation\n    };\n  }\n  /**\n   * Add column.\n   * @param column Column path.\n   * @param columnAlias Column alias.\n   * @returns [BaseQueryColumn] Column instance.\n   */\n  addColumn(column, columnAlias) {\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n  /**\n   * Add column by column path.\n   * @param columnPath Column path.\n   * @param columnAlias Column alias.\n   * @returns [EntityQueryColumn] Column instance.\n   */\n  addSchemaColumn(columnPath, columnAlias) {\n    ɵValidationUtilities.checkArgumentEmpty('columnPath', columnPath);\n    const column = new ɵEntityQueryColumn(columnPath);\n    this._internalAddColumn(columnAlias || columnPath, column);\n    return column;\n  }\n  /**\n   * Add aggregation sub query column.\n   * @param columnPath Column path.\n   * @param aggregationType Aggregation type.\n   * @param subFilters Sub query filters.\n   * @param columnAlias Column alias.\n   * @returns [AggregationSubQueryColumn] Column instance.\n   */\n  addAggregationSubQueryColumn(columnPath, aggregationType, aggregationConfig, columnAlias) {\n    const column = new ɵAggregationSubQueryColumn(columnPath, aggregationType, aggregationConfig.filter, aggregationConfig.sortByDirection, aggregationConfig.sortByColumn);\n    this._internalAddColumn(columnAlias || columnPath, column);\n    return column;\n  }\n  /**\n   * Add parameter column.\n   * @param value Parameter value.\n   * @param dataValueType Parameter data value type.\n   * @param columnAlias Column alias.\n   * @returns [ParameterQueryColumn] Column instance.\n   */\n  addParameterColumn(value, dataValueType, columnAlias) {\n    const column = new ɵParameterQueryColumn(value, dataValueType);\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n  /**\n   * Add arithmetic column.\n   * @param arithmeticOperation Arithmetic operation.\n   * @param leftArithmeticOperand Left arithmetic operand expression.\n   * @param rightArithmeticOperand Right arithmetic operand expression.\n   * @param columnAlias Column alias.\n   * @returns [ArithmeticQueryColumn] Column instance.\n   */\n  addArithmeticColumn(arithmeticOperation, leftArithmeticOperand, rightArithmeticOperand, columnAlias) {\n    const column = new ɵArithmeticQueryColumn(arithmeticOperation, leftArithmeticOperand, rightArithmeticOperand);\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n  /**\n   * Add macros function column.\n   * @param queryMacrosType Macros type.\n   * @param columnAlias Column alias.\n   * @returns [MacrosFunctionColumn] Column instance.\n   */\n  addMacrosFunctionColumn(queryMacrosType, columnAlias) {\n    const column = new ɵMacrosFunctionColumn(queryMacrosType);\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n  /**\n   * Add date part function column.\n   * @param columnPath Column path.\n   * @param datePartType Date part type.\n   * @param columnAlias Column alias.\n   * @returns [DatePartFunctionColumn] Column instance.\n   */\n  addDatePartFunctionColumn(columnPath, datePartType, columnAlias) {\n    const functionArgument = new ɵColumnExpression({\n      columnPath\n    });\n    const column = new ɵDatePartFunctionColumn(datePartType, functionArgument);\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n  /**\n   * Add aggregation function column.\n   * @param columnPath Column path.\n   * @param aggregationType Aggregation type.\n   * @param columnAlias Column alias.\n   * @param aggregationEvalType Aggregation eval type.\n   * @returns [AggregationFunctionColumn] Column instance.\n   */\n  addAggregationFunctionColumn(columnPath, aggregationType, columnAlias, aggregationEvalType = ɵAggregationEvalType.None) {\n    const functionArgument = new ɵColumnExpression({\n      columnPath\n    });\n    const column = new ɵAggregationFunctionColumn(aggregationType, aggregationEvalType, functionArgument);\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n  /**\n   * Add length function column.\n   * @param columnPath Column path.\n   * @param columnAlias Column alias.\n   * @returns [LengthFunctionColumn] Column instance.\n   */\n  addLengthFunctionColumn(columnPath, columnAlias) {\n    const functionArgument = new ɵColumnExpression({\n      columnPath\n    });\n    const column = new ɵLengthFunctionColumn(functionArgument);\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n  /**\n   * Add window function column.\n   * @param columnPath Column path.\n   * @param aggregationType Aggregation type.\n   * @param columnAlias Column alias.\n   * @param aggregationEvalType Aggregation eval type.\n   * @returns [WindowFunctionColumn] Column instance.\n   */\n  addWindowFunctionColumn(columnPath, aggregationType, columnAlias, aggregationEvalType = ɵAggregationEvalType.None) {\n    const functionArgument = new ɵAggregationFunctionExpression({\n      aggregationType,\n      aggregationEvalType,\n      functionArgument: new ɵColumnExpression({\n        columnPath\n      })\n    });\n    const column = new ɵWindowFunctionColumn(functionArgument);\n    this._internalAddColumn(columnAlias, column);\n    return column;\n  }\n}\n\n/**\n * @public\n */\nlet ɵInsertQuery = /*#__PURE__*/(() => {\n  class ɵInsertQuery extends ɵBaseQuery {\n    // endregion\n    // region Constructors: Public\n    constructor(rootSchemaName) {\n      super(ɵQueryOperationType.Insert, rootSchemaName);\n      // region Fields: Private\n      this._columnValues = new Map();\n    }\n    // endregion\n    // region Properties: Public\n    get columnValues() {\n      return {\n        items: classToPlain(this._columnValues)\n      };\n    }\n    // endregion\n    // region Methods: Public\n    addColumn(columnName, columnValue, dataValueType) {\n      ɵValidationUtilities.checkArgumentEmpty('columnName', columnName);\n      this._columnValues.set(columnName, new ɵParameterExpression({\n        value: columnValue,\n        dataValueType\n      }));\n    }\n  }\n  __decorate([Expose(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], ɵInsertQuery.prototype, \"columnValues\", null);\n\n  /**\n   * @public\n   */\n  return ɵInsertQuery;\n})();\nlet ɵUpdateQuery = /*#__PURE__*/(() => {\n  class ɵUpdateQuery extends ɵBaseFilterableQuery {\n    // endregion\n    // region Constructors: Public\n    constructor(rootSchemaName) {\n      super(ɵQueryOperationType.Update, rootSchemaName);\n      // region Fields: Private\n      this._columnValues = new Map();\n      // endregion\n      // region Fields: Public\n      /**\n       * Flag that indicates whether to force save data.\n       */\n      this.isForceUpdate = false;\n    }\n    // endregion\n    // region Properties: Public\n    get columnValues() {\n      return {\n        items: classToPlain(this._columnValues)\n      };\n    }\n    // endregion\n    // region Methods: Public\n    addColumn(columnName, columnValue, dataValueType) {\n      ɵValidationUtilities.checkArgumentEmpty('columnName', columnName);\n      this._columnValues.set(columnName, new ɵParameterExpression({\n        value: columnValue,\n        dataValueType\n      }));\n    }\n  }\n  __decorate([Expose(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], ɵUpdateQuery.prototype, \"columnValues\", null);\n\n  /**\n   * @public\n   */\n  return ɵUpdateQuery;\n})();\nclass ɵSelectLocalizationQuery extends ɵEntitySchemaQuery {}\n\n/**\n * @public\n * @class ɵBaseRequest\n * @describe Base definition of request.\n * @template TEvent\n */\nclass ɵBaseRequest {}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * @public\n */\nvar ɵModelParameterType = /*#__PURE__*/(() => {\n  (function (ɵModelParameterType) {\n    ɵModelParameterType[\"PrimaryColumnValue\"] = \"primaryColumnValue\";\n    ɵModelParameterType[\"Filter\"] = \"filter\";\n    ɵModelParameterType[\"PrimaryDisplayValueFilter\"] = \"primaryDisplayValueFilter\";\n    ɵModelParameterType[\"Empty\"] = \"empty\";\n    ɵModelParameterType[\"Never\"] = \"never\";\n  })(ɵModelParameterType || (ɵModelParameterType = {}));\n  return ɵModelParameterType;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LookupMode, ɵAggregationEvalType, ɵAggregationFunction, ɵAggregationFunctionColumn, ɵAggregationFunctionExpression, ɵAggregationSubQueryColumn, ɵAggregationSubQueryExpression, ɵAggregationType, ɵArgumentEmptyException, ɵArgumentFunctionExpression, ɵArgumentOutOfRangeException, ɵArithmeticExpression, ɵArithmeticOperation, ɵArithmeticQueryColumn, ɵBaseExpression, ɵBaseExpressionParser, ɵBaseFilter, ɵBaseFilterParser, ɵBaseFilterableQuery, ɵBaseQuery, ɵBaseQueryColumn, ɵBaseRequest, ɵBetweenFilter, ɵColumnExpression, ɵCompareFilter, ɵComparisonType, ɵDEFAULT_COLUMN_PLAIN_OBJ, ɵDEFAULT_FILTER_PLAIN_OBJ, ɵDataSchemaAttributeType, ɵDataSchemaAttributeUsageType, ɵDataSchemaType, ɵDataSourceScope, ɵDataValueType, ɵDatePartFunctionColumn, ɵDatePartFunctionExpression, ɵDatePartType, ɵDefaultValueSource, ɵDeleteQuery, ɵEMPTY_GUID, ɵEXPRESSION_TYPE_MOCK, ɵEntityQueryColumn, ɵEntitySchemaQuery, ɵExistsFilter, ɵExpressionMock, ɵExpressionParser, ɵExpressionResolver, ɵExpressionType, ɵFilterGroup, ɵFilterMock, ɵFilterParser, ɵFilterResolver, ɵFilterType, ɵFunctionExpression, ɵFunctionType, ɵInFilter, ɵInsertQuery, ɵIsNullFilter, ɵItemNotFoundException, ɵLengthFunctionColumn, ɵLengthFunctionExpression, ɵLogicalOperatorType, ɵMacrosFunctionColumn, ɵMacrosFunctionExpression, ɵModelParameterType, ɵNextHandlerAlreadySpecifiedException, ɵOrderDirection, ɵParameterExpression, ɵParameterQueryColumn, ɵQueryMacrosType, ɵQueryOperationType, ɵSelectLocalizationQuery, ɵSingleFilter, ɵSubQueryColumn, ɵSubQueryExpression, ɵUpdateQuery, ɵValidationUtilities, ɵWindowFunctionColumn, ɵWindowFunctionExpression, ɵencodeDate, ɵgenerateGuid, ɵgetColumnPlainObj, ɵgetFilterPlainObj, ɵisEmptyGuid, ɵisGuid, ɵparserMock, ɵtoLocalISOString };\n//# sourceMappingURL=creatio-base.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}