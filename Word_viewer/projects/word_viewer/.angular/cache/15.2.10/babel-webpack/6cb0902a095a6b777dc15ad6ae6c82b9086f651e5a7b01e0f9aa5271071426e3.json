{"ast":null,"code":"var _ = require(\"underscore\");\nvar lop = require(\"lop\");\nvar documentMatchers = require(\"./styles/document-matchers\");\nvar htmlPaths = require(\"./styles/html-paths\");\nvar tokenise = require(\"./styles/parser/tokeniser\").tokenise;\nvar results = require(\"./results\");\nexports.readHtmlPath = readHtmlPath;\nexports.readDocumentMatcher = readDocumentMatcher;\nexports.readStyle = readStyle;\nfunction readStyle(string) {\n  return parseString(styleRule, string);\n}\nfunction createStyleRule() {\n  return lop.rules.sequence(lop.rules.sequence.capture(documentMatcherRule()), lop.rules.tokenOfType(\"whitespace\"), lop.rules.tokenOfType(\"arrow\"), lop.rules.sequence.capture(lop.rules.optional(lop.rules.sequence(lop.rules.tokenOfType(\"whitespace\"), lop.rules.sequence.capture(htmlPathRule())).head())), lop.rules.tokenOfType(\"end\")).map(function (documentMatcher, htmlPath) {\n    return {\n      from: documentMatcher,\n      to: htmlPath.valueOrElse(htmlPaths.empty)\n    };\n  });\n}\nfunction readDocumentMatcher(string) {\n  return parseString(documentMatcherRule(), string);\n}\nfunction documentMatcherRule() {\n  var sequence = lop.rules.sequence;\n  var identifierToConstant = function (identifier, constant) {\n    return lop.rules.then(lop.rules.token(\"identifier\", identifier), function () {\n      return constant;\n    });\n  };\n  var paragraphRule = identifierToConstant(\"p\", documentMatchers.paragraph);\n  var runRule = identifierToConstant(\"r\", documentMatchers.run);\n  var elementTypeRule = lop.rules.firstOf(\"p or r or table\", paragraphRule, runRule);\n  var styleIdRule = lop.rules.sequence(lop.rules.tokenOfType(\"dot\"), lop.rules.sequence.cut(), lop.rules.sequence.capture(identifierRule)).map(function (styleId) {\n    return {\n      styleId: styleId\n    };\n  });\n  var styleNameMatcherRule = lop.rules.firstOf(\"style name matcher\", lop.rules.then(lop.rules.sequence(lop.rules.tokenOfType(\"equals\"), lop.rules.sequence.cut(), lop.rules.sequence.capture(stringRule)).head(), function (styleName) {\n    return {\n      styleName: documentMatchers.equalTo(styleName)\n    };\n  }), lop.rules.then(lop.rules.sequence(lop.rules.tokenOfType(\"startsWith\"), lop.rules.sequence.cut(), lop.rules.sequence.capture(stringRule)).head(), function (styleName) {\n    return {\n      styleName: documentMatchers.startsWith(styleName)\n    };\n  }));\n  var styleNameRule = lop.rules.sequence(lop.rules.tokenOfType(\"open-square-bracket\"), lop.rules.sequence.cut(), lop.rules.token(\"identifier\", \"style-name\"), lop.rules.sequence.capture(styleNameMatcherRule), lop.rules.tokenOfType(\"close-square-bracket\")).head();\n  var listTypeRule = lop.rules.firstOf(\"list type\", identifierToConstant(\"ordered-list\", {\n    isOrdered: true\n  }), identifierToConstant(\"unordered-list\", {\n    isOrdered: false\n  }));\n  var listRule = sequence(lop.rules.tokenOfType(\"colon\"), sequence.capture(listTypeRule), sequence.cut(), lop.rules.tokenOfType(\"open-paren\"), sequence.capture(integerRule), lop.rules.tokenOfType(\"close-paren\")).map(function (listType, levelNumber) {\n    return {\n      list: {\n        isOrdered: listType.isOrdered,\n        levelIndex: levelNumber - 1\n      }\n    };\n  });\n  function createMatcherSuffixesRule(rules) {\n    var matcherSuffix = lop.rules.firstOf.apply(lop.rules.firstOf, [\"matcher suffix\"].concat(rules));\n    var matcherSuffixes = lop.rules.zeroOrMore(matcherSuffix);\n    return lop.rules.then(matcherSuffixes, function (suffixes) {\n      var matcherOptions = {};\n      suffixes.forEach(function (suffix) {\n        _.extend(matcherOptions, suffix);\n      });\n      return matcherOptions;\n    });\n  }\n  var paragraphOrRun = sequence(sequence.capture(elementTypeRule), sequence.capture(createMatcherSuffixesRule([styleIdRule, styleNameRule, listRule]))).map(function (createMatcher, matcherOptions) {\n    return createMatcher(matcherOptions);\n  });\n  var table = sequence(lop.rules.token(\"identifier\", \"table\"), sequence.capture(createMatcherSuffixesRule([styleIdRule, styleNameRule]))).map(function (options) {\n    return documentMatchers.table(options);\n  });\n  var bold = identifierToConstant(\"b\", documentMatchers.bold);\n  var italic = identifierToConstant(\"i\", documentMatchers.italic);\n  var underline = identifierToConstant(\"u\", documentMatchers.underline);\n  var strikethrough = identifierToConstant(\"strike\", documentMatchers.strikethrough);\n  var allCaps = identifierToConstant(\"all-caps\", documentMatchers.allCaps);\n  var smallCaps = identifierToConstant(\"small-caps\", documentMatchers.smallCaps);\n  var highlight = sequence(lop.rules.token(\"identifier\", \"highlight\"), lop.rules.sequence.capture(lop.rules.optional(lop.rules.sequence(lop.rules.tokenOfType(\"open-square-bracket\"), lop.rules.sequence.cut(), lop.rules.token(\"identifier\", \"color\"), lop.rules.tokenOfType(\"equals\"), lop.rules.sequence.capture(stringRule), lop.rules.tokenOfType(\"close-square-bracket\")).head()))).map(function (color) {\n    return documentMatchers.highlight({\n      color: color.valueOrElse(undefined)\n    });\n  });\n  var commentReference = identifierToConstant(\"comment-reference\", documentMatchers.commentReference);\n  var breakMatcher = sequence(lop.rules.token(\"identifier\", \"br\"), sequence.cut(), lop.rules.tokenOfType(\"open-square-bracket\"), lop.rules.token(\"identifier\", \"type\"), lop.rules.tokenOfType(\"equals\"), sequence.capture(stringRule), lop.rules.tokenOfType(\"close-square-bracket\")).map(function (breakType) {\n    switch (breakType) {\n      case \"line\":\n        return documentMatchers.lineBreak;\n      case \"page\":\n        return documentMatchers.pageBreak;\n      case \"column\":\n        return documentMatchers.columnBreak;\n      default:\n      // TODO: handle unknown document matchers\n    }\n  });\n\n  return lop.rules.firstOf(\"element type\", paragraphOrRun, table, bold, italic, underline, strikethrough, allCaps, smallCaps, highlight, commentReference, breakMatcher);\n}\nfunction readHtmlPath(string) {\n  return parseString(htmlPathRule(), string);\n}\nfunction htmlPathRule() {\n  var capture = lop.rules.sequence.capture;\n  var whitespaceRule = lop.rules.tokenOfType(\"whitespace\");\n  var freshRule = lop.rules.then(lop.rules.optional(lop.rules.sequence(lop.rules.tokenOfType(\"colon\"), lop.rules.token(\"identifier\", \"fresh\"))), function (option) {\n    return option.map(function () {\n      return true;\n    }).valueOrElse(false);\n  });\n  var separatorRule = lop.rules.then(lop.rules.optional(lop.rules.sequence(lop.rules.tokenOfType(\"colon\"), lop.rules.token(\"identifier\", \"separator\"), lop.rules.tokenOfType(\"open-paren\"), capture(stringRule), lop.rules.tokenOfType(\"close-paren\")).head()), function (option) {\n    return option.valueOrElse(\"\");\n  });\n  var tagNamesRule = lop.rules.oneOrMoreWithSeparator(identifierRule, lop.rules.tokenOfType(\"choice\"));\n  var styleElementRule = lop.rules.sequence(capture(tagNamesRule), capture(lop.rules.zeroOrMore(attributeOrClassRule)), capture(freshRule), capture(separatorRule)).map(function (tagName, attributesList, fresh, separator) {\n    var attributes = {};\n    var options = {};\n    attributesList.forEach(function (attribute) {\n      if (attribute.append && attributes[attribute.name]) {\n        attributes[attribute.name] += \" \" + attribute.value;\n      } else {\n        attributes[attribute.name] = attribute.value;\n      }\n    });\n    if (fresh) {\n      options.fresh = true;\n    }\n    if (separator) {\n      options.separator = separator;\n    }\n    return htmlPaths.element(tagName, attributes, options);\n  });\n  return lop.rules.firstOf(\"html path\", lop.rules.then(lop.rules.tokenOfType(\"bang\"), function () {\n    return htmlPaths.ignore;\n  }), lop.rules.then(lop.rules.zeroOrMoreWithSeparator(styleElementRule, lop.rules.sequence(whitespaceRule, lop.rules.tokenOfType(\"gt\"), whitespaceRule)), htmlPaths.elements));\n}\nvar identifierRule = lop.rules.then(lop.rules.tokenOfType(\"identifier\"), decodeEscapeSequences);\nvar integerRule = lop.rules.tokenOfType(\"integer\");\nvar stringRule = lop.rules.then(lop.rules.tokenOfType(\"string\"), decodeEscapeSequences);\nvar escapeSequences = {\n  \"n\": \"\\n\",\n  \"r\": \"\\r\",\n  \"t\": \"\\t\"\n};\nfunction decodeEscapeSequences(value) {\n  return value.replace(/\\\\(.)/g, function (match, code) {\n    return escapeSequences[code] || code;\n  });\n}\nvar attributeRule = lop.rules.sequence(lop.rules.tokenOfType(\"open-square-bracket\"), lop.rules.sequence.cut(), lop.rules.sequence.capture(identifierRule), lop.rules.tokenOfType(\"equals\"), lop.rules.sequence.capture(stringRule), lop.rules.tokenOfType(\"close-square-bracket\")).map(function (name, value) {\n  return {\n    name: name,\n    value: value,\n    append: false\n  };\n});\nvar classRule = lop.rules.sequence(lop.rules.tokenOfType(\"dot\"), lop.rules.sequence.cut(), lop.rules.sequence.capture(identifierRule)).map(function (className) {\n  return {\n    name: \"class\",\n    value: className,\n    append: true\n  };\n});\nvar attributeOrClassRule = lop.rules.firstOf(\"attribute or class\", attributeRule, classRule);\nfunction parseString(rule, string) {\n  var tokens = tokenise(string);\n  var parser = lop.Parser();\n  var parseResult = parser.parseTokens(rule, tokens);\n  if (parseResult.isSuccess()) {\n    return results.success(parseResult.value());\n  } else {\n    return new results.Result(null, [results.warning(describeFailure(string, parseResult))]);\n  }\n}\nfunction describeFailure(input, parseResult) {\n  return \"Did not understand this style mapping, so ignored it: \" + input + \"\\n\" + parseResult.errors().map(describeError).join(\"\\n\");\n}\nfunction describeError(error) {\n  return \"Error was at character number \" + error.characterNumber() + \": \" + \"Expected \" + error.expected + \" but got \" + error.actual;\n}\nvar styleRule = createStyleRule();","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}