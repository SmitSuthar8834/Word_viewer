{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {\n  var util = require(\"./util\");\n  var canEvaluate = util.canEvaluate;\n  var tryCatch = util.tryCatch;\n  var errorObj = util.errorObj;\n  var reject;\n  if (!false) {\n    if (canEvaluate) {\n      var thenCallback = function (i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n      };\n      var promiseSetter = function (i) {\n        return new Function(\"promise\", \"holder\", \"                           \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = promise;                                         \\n\\\n            \".replace(/Index/g, i));\n      };\n      var generateHolderClass = function (total) {\n        var props = new Array(total);\n        for (var i = 0; i < props.length; ++i) {\n          props[i] = \"this.p\" + (i + 1);\n        }\n        var assignment = props.join(\" = \") + \" = null;\";\n        var cancellationCode = \"var promise;\\n\" + props.map(function (prop) {\n          return \"                                                         \\n\\\n                promise = \" + prop + \";                                      \\n\\\n                if (promise instanceof Promise) {                            \\n\\\n                    promise.cancel();                                        \\n\\\n                }                                                            \\n\\\n            \";\n        }).join(\"\\n\");\n        var passedArguments = props.join(\", \");\n        var name = \"Holder$\" + total;\n        var code = \"return function(tryCatch, errorObj, Promise, async) {    \\n\\\n            'use strict';                                                    \\n\\\n            function [TheName](fn) {                                         \\n\\\n                [TheProperties]                                              \\n\\\n                this.fn = fn;                                                \\n\\\n                this.asyncNeeded = true;                                     \\n\\\n                this.now = 0;                                                \\n\\\n            }                                                                \\n\\\n                                                                             \\n\\\n            [TheName].prototype._callFunction = function(promise) {          \\n\\\n                promise._pushContext();                                      \\n\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\n\\\n                promise._popContext();                                       \\n\\\n                if (ret === errorObj) {                                      \\n\\\n                    promise._rejectCallback(ret.e, false);                   \\n\\\n                } else {                                                     \\n\\\n                    promise._resolveCallback(ret);                           \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\n\\\n                var now = ++this.now;                                        \\n\\\n                if (now === [TheTotal]) {                                    \\n\\\n                    if (this.asyncNeeded) {                                  \\n\\\n                        async.invoke(this._callFunction, this, promise);     \\n\\\n                    } else {                                                 \\n\\\n                        this._callFunction(promise);                         \\n\\\n                    }                                                        \\n\\\n                                                                             \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype._resultCancelled = function() {              \\n\\\n                [CancellationCode]                                           \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            return [TheName];                                                \\n\\\n        }(tryCatch, errorObj, Promise, async);                               \\n\\\n        \";\n        code = code.replace(/\\[TheName\\]/g, name).replace(/\\[TheTotal\\]/g, total).replace(/\\[ThePassedArguments\\]/g, passedArguments).replace(/\\[TheProperties\\]/g, assignment).replace(/\\[CancellationCode\\]/g, cancellationCode);\n        return new Function(\"tryCatch\", \"errorObj\", \"Promise\", \"async\", code)(tryCatch, errorObj, Promise, async);\n      };\n      var holderClasses = [];\n      var thenCallbacks = [];\n      var promiseSetters = [];\n      for (var i = 0; i < 8; ++i) {\n        holderClasses.push(generateHolderClass(i + 1));\n        thenCallbacks.push(thenCallback(i + 1));\n        promiseSetters.push(promiseSetter(i + 1));\n      }\n      reject = function (reason) {\n        this._reject(reason);\n      };\n    }\n  }\n  Promise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n      fn = arguments[last];\n      if (!false) {\n        if (last <= 8 && canEvaluate) {\n          var ret = new Promise(INTERNAL);\n          ret._captureStackTrace();\n          var HolderClass = holderClasses[last - 1];\n          var holder = new HolderClass(fn);\n          var callbacks = thenCallbacks;\n          for (var i = 0; i < last; ++i) {\n            var maybePromise = tryConvertToPromise(arguments[i], ret);\n            if (maybePromise instanceof Promise) {\n              maybePromise = maybePromise._target();\n              var bitField = maybePromise._bitField;\n              ;\n              if ((bitField & 50397184) === 0) {\n                maybePromise._then(callbacks[i], reject, undefined, ret, holder);\n                promiseSetters[i](maybePromise, holder);\n                holder.asyncNeeded = false;\n              } else if ((bitField & 33554432) !== 0) {\n                callbacks[i].call(ret, maybePromise._value(), holder);\n              } else if ((bitField & 16777216) !== 0) {\n                ret._reject(maybePromise._reason());\n              } else {\n                ret._cancel();\n              }\n            } else {\n              callbacks[i].call(ret, maybePromise, holder);\n            }\n          }\n          if (!ret._isFateSealed()) {\n            if (holder.asyncNeeded) {\n              var domain = getDomain();\n              if (domain !== null) {\n                holder.fn = util.domainBind(domain, holder.fn);\n              }\n            }\n            ret._setAsyncGuaranteed();\n            ret._setOnCancel(holder);\n          }\n          return ret;\n        }\n      }\n    }\n    var $_len = arguments.length;\n    var args = new Array($_len);\n    for (var $_i = 0; $_i < $_len; ++$_i) {\n      args[$_i] = arguments[$_i];\n    }\n    ;\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}