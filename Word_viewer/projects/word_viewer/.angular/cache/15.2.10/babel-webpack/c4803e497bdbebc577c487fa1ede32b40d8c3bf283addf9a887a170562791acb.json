{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {\n  var getDomain = Promise._getDomain;\n  var util = require(\"./util\");\n  var tryCatch = util.tryCatch;\n  var errorObj = util.errorObj;\n  var async = Promise._async;\n  function MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var domain = getDomain();\n    this._callback = domain === null ? fn : util.domainBind(domain, fn);\n    this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = [];\n    async.invoke(this._asyncInit, this, undefined);\n  }\n  util.inherits(MappingPromiseArray, PromiseArray);\n  MappingPromiseArray.prototype._asyncInit = function () {\n    this._init$(undefined, -2);\n  };\n  MappingPromiseArray.prototype._init = function () {};\n  MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n    if (index < 0) {\n      index = index * -1 - 1;\n      values[index] = value;\n      if (limit >= 1) {\n        this._inFlight--;\n        this._drainQueue();\n        if (this._isResolved()) return true;\n      }\n    } else {\n      if (limit >= 1 && this._inFlight >= limit) {\n        values[index] = value;\n        this._queue.push(index);\n        return false;\n      }\n      if (preservedValues !== null) preservedValues[index] = value;\n      var promise = this._promise;\n      var callback = this._callback;\n      var receiver = promise._boundValue();\n      promise._pushContext();\n      var ret = tryCatch(callback).call(receiver, value, index, length);\n      var promiseCreated = promise._popContext();\n      debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? \"Promise.filter\" : \"Promise.map\", promise);\n      if (ret === errorObj) {\n        this._reject(ret.e);\n        return true;\n      }\n      var maybePromise = tryConvertToPromise(ret, this._promise);\n      if (maybePromise instanceof Promise) {\n        maybePromise = maybePromise._target();\n        var bitField = maybePromise._bitField;\n        ;\n        if ((bitField & 50397184) === 0) {\n          if (limit >= 1) this._inFlight++;\n          values[index] = maybePromise;\n          maybePromise._proxy(this, (index + 1) * -1);\n          return false;\n        } else if ((bitField & 33554432) !== 0) {\n          ret = maybePromise._value();\n        } else if ((bitField & 16777216) !== 0) {\n          this._reject(maybePromise._reason());\n          return true;\n        } else {\n          this._cancel();\n          return true;\n        }\n      }\n      values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n      if (preservedValues !== null) {\n        this._filter(values, preservedValues);\n      } else {\n        this._resolve(values);\n      }\n      return true;\n    }\n    return false;\n  };\n  MappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n      if (this._isResolved()) return;\n      var index = queue.pop();\n      this._promiseFulfilled(values[index], index);\n    }\n  };\n  MappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n      if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n  };\n  MappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n  };\n  function map(promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") {\n      return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var limit = 0;\n    if (options !== undefined) {\n      if (typeof options === \"object\" && options !== null) {\n        if (typeof options.concurrency !== \"number\") {\n          return Promise.reject(new TypeError(\"'concurrency' must be a number but it is \" + util.classString(options.concurrency)));\n        }\n        limit = options.concurrency;\n      } else {\n        return Promise.reject(new TypeError(\"options argument must be an object but it is \" + util.classString(options)));\n      }\n    }\n    limit = typeof limit === \"number\" && isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n  }\n  Promise.prototype.map = function (fn, options) {\n    return map(this, fn, options, null);\n  };\n  Promise.map = function (promises, fn, options, _filter) {\n    return map(promises, fn, options, _filter);\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}