{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, INTERNAL) {\n  var THIS = {};\n  var util = require(\"./util\");\n  var nodebackForPromise = require(\"./nodeback\");\n  var withAppended = util.withAppended;\n  var maybeWrapAsError = util.maybeWrapAsError;\n  var canEvaluate = util.canEvaluate;\n  var TypeError = require(\"./errors\").TypeError;\n  var defaultSuffix = \"Async\";\n  var defaultPromisified = {\n    __isPromisified__: true\n  };\n  var noCopyProps = [\"arity\", \"length\", \"name\", \"arguments\", \"caller\", \"callee\", \"prototype\", \"__isPromisified__\"];\n  var noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n  var defaultFilter = function (name) {\n    return util.isIdentifier(name) && name.charAt(0) !== \"_\" && name !== \"constructor\";\n  };\n  function propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n  }\n  function isPromisified(fn) {\n    try {\n      return fn.__isPromisified__ === true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);\n    return val ? isPromisified(val) : false;\n  }\n  function checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n      var key = ret[i];\n      if (suffixRegexp.test(key)) {\n        var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n        for (var j = 0; j < ret.length; j += 2) {\n          if (ret[j] === keyWithoutAsyncSuffix) {\n            throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\".replace(\"%s\", suffix));\n          }\n        }\n      }\n    }\n  }\n  function promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      var value = obj[key];\n      var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);\n      if (typeof value === \"function\" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {\n        ret.push(key, value);\n      }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n  }\n  var escapeIdentRegex = function (str) {\n    return str.replace(/([$])/, \"\\\\$\");\n  };\n  var makeNodePromisifiedEval;\n  if (!false) {\n    var switchCaseArgumentOrder = function (likelyArgumentCount) {\n      var ret = [likelyArgumentCount];\n      var min = Math.max(0, likelyArgumentCount - 1 - 3);\n      for (var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n      }\n      for (var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n      }\n      return ret;\n    };\n    var argumentSequence = function (argumentCount) {\n      return util.filledRange(argumentCount, \"_arg\", \"\");\n    };\n    var parameterDeclaration = function (parameterCount) {\n      return util.filledRange(Math.max(parameterCount, 3), \"_arg\", \"\");\n    };\n    var parameterCount = function (fn) {\n      if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n      }\n      return 0;\n    };\n    makeNodePromisifiedEval = function (callback, receiver, originalName, fn, _, multiArgs) {\n      var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n      var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n      var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n      function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n          ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n          ret = receiver === undefined ? \"ret = callback({{args}}, nodeback); break;\\n\" : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n      }\n      function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n          ret += \"case \" + argumentOrder[i] + \":\" + generateCallForArgumentCount(argumentOrder[i]);\n        }\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", shouldProxyThis ? \"ret = callback.apply(this, args);\\n\" : \"ret = callback.apply(receiver, args);\\n\");\n        return ret;\n      }\n      var getFunctionCode = typeof callback === \"string\" ? \"this != null ? this['\" + callback + \"'] : fn\" : \"fn\";\n      var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase()).replace(\"[GetFunctionCode]\", getFunctionCode);\n      body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n      return new Function(\"Promise\", \"fn\", \"receiver\", \"withAppended\", \"maybeWrapAsError\", \"nodebackForPromise\", \"tryCatch\", \"errorObj\", \"notEnumerableProp\", \"INTERNAL\", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);\n    };\n  }\n  function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = function () {\n      return this;\n    }();\n    var method = callback;\n    if (typeof method === \"string\") {\n      callback = fn;\n    }\n    function promisified() {\n      var _receiver = receiver;\n      if (receiver === THIS) _receiver = this;\n      var promise = new Promise(INTERNAL);\n      promise._captureStackTrace();\n      var cb = typeof method === \"string\" && this !== defaultThis ? this[method] : callback;\n      var fn = nodebackForPromise(promise, multiArgs);\n      try {\n        cb.apply(_receiver, withAppended(arguments, fn));\n      } catch (e) {\n        promise._rejectCallback(maybeWrapAsError(e), true, true);\n      }\n      if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n      return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n  }\n  var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;\n  function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);\n    for (var i = 0, len = methods.length; i < len; i += 2) {\n      var key = methods[i];\n      var fn = methods[i + 1];\n      var promisifiedKey = key + suffix;\n      if (promisifier === makeNodePromisified) {\n        obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n      } else {\n        var promisified = promisifier(fn, function () {\n          return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        });\n        util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n        obj[promisifiedKey] = promisified;\n      }\n    }\n    util.toFastProperties(obj);\n    return obj;\n  }\n  function promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);\n  }\n  Promise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    if (isPromisified(fn)) {\n      return fn;\n    }\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n  };\n  Promise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n      throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n    if (!util.isIdentifier(suffix)) {\n      throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n      var value = target[keys[i]];\n      if (keys[i] !== \"constructor\" && util.isClass(value)) {\n        promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);\n        promisifyAll(value, suffix, filter, promisifier, multiArgs);\n      }\n    }\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}