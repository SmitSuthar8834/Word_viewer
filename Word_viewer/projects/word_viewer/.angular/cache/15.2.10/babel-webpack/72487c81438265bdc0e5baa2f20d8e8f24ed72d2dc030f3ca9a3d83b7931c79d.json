{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, INTERNAL, debug) {\n  var util = require(\"./util\");\n  var TimeoutError = Promise.TimeoutError;\n  function HandleWrapper(handle) {\n    this.handle = handle;\n  }\n  HandleWrapper.prototype._resultCancelled = function () {\n    clearTimeout(this.handle);\n  };\n  var afterValue = function (value) {\n    return delay(+this).thenReturn(value);\n  };\n  var delay = Promise.delay = function (ms, value) {\n    var ret;\n    var handle;\n    if (value !== undefined) {\n      ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n      if (debug.cancellation() && value instanceof Promise) {\n        ret._setOnCancel(value);\n      }\n    } else {\n      ret = new Promise(INTERNAL);\n      handle = setTimeout(function () {\n        ret._fulfill();\n      }, +ms);\n      if (debug.cancellation()) {\n        ret._setOnCancel(new HandleWrapper(handle));\n      }\n      ret._captureStackTrace();\n    }\n    ret._setAsyncGuaranteed();\n    return ret;\n  };\n  Promise.prototype.delay = function (ms) {\n    return delay(ms, this);\n  };\n  var afterTimeout = function (promise, message, parent) {\n    var err;\n    if (typeof message !== \"string\") {\n      if (message instanceof Error) {\n        err = message;\n      } else {\n        err = new TimeoutError(\"operation timed out\");\n      }\n    } else {\n      err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._reject(err);\n    if (parent != null) {\n      parent.cancel();\n    }\n  };\n  function successClear(value) {\n    clearTimeout(this.handle);\n    return value;\n  }\n  function failureClear(reason) {\n    clearTimeout(this.handle);\n    throw reason;\n  }\n  Promise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret, parent;\n    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n      if (ret.isPending()) {\n        afterTimeout(ret, message, parent);\n      }\n    }, ms));\n    if (debug.cancellation()) {\n      parent = this.then();\n      ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);\n      ret._setOnCancel(handleWrapper);\n    } else {\n      ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);\n    }\n    return ret;\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}