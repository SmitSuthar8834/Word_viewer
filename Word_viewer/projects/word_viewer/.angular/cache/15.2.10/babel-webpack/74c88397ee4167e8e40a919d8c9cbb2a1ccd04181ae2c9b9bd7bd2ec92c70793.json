{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function () {\n  var makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n  };\n  var reflectHandler = function () {\n    return new Promise.PromiseInspection(this._target());\n  };\n  var apiRejection = function (msg) {\n    return Promise.reject(new TypeError(msg));\n  };\n  function Proxyable() {}\n  var UNDEFINED_BINDING = {};\n  var util = require(\"./util\");\n  var getDomain;\n  if (util.isNode) {\n    getDomain = function () {\n      var ret = process.domain;\n      if (ret === undefined) ret = null;\n      return ret;\n    };\n  } else {\n    getDomain = function () {\n      return null;\n    };\n  }\n  util.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n  var es5 = require(\"./es5\");\n  var Async = require(\"./async\");\n  var async = new Async();\n  es5.defineProperty(Promise, \"_async\", {\n    value: async\n  });\n  var errors = require(\"./errors\");\n  var TypeError = Promise.TypeError = errors.TypeError;\n  Promise.RangeError = errors.RangeError;\n  var CancellationError = Promise.CancellationError = errors.CancellationError;\n  Promise.TimeoutError = errors.TimeoutError;\n  Promise.OperationalError = errors.OperationalError;\n  Promise.RejectionError = errors.OperationalError;\n  Promise.AggregateError = errors.AggregateError;\n  var INTERNAL = function () {};\n  var APPLY = {};\n  var NEXT_FILTER = {};\n  var tryConvertToPromise = require(\"./thenables\")(Promise, INTERNAL);\n  var PromiseArray = require(\"./promise_array\")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);\n  var Context = require(\"./context\")(Promise);\n  /*jshint unused:false*/\n  var createContext = Context.create;\n  var debug = require(\"./debuggability\")(Promise, Context);\n  var CapturedTrace = debug.CapturedTrace;\n  var PassThroughHandlerContext = require(\"./finally\")(Promise, tryConvertToPromise);\n  var catchFilter = require(\"./catch_filter\")(NEXT_FILTER);\n  var nodebackForPromise = require(\"./nodeback\");\n  var errorObj = util.errorObj;\n  var tryCatch = util.tryCatch;\n  function check(self, executor) {\n    if (typeof executor !== \"function\") {\n      throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n    }\n    if (self.constructor !== Promise) {\n      throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n  }\n  function Promise(executor) {\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    if (executor !== INTERNAL) {\n      check(this, executor);\n      this._resolveFromExecutor(executor);\n    }\n    this._promiseCreated();\n    this._fireEvent(\"promiseCreated\", this);\n  }\n  Promise.prototype.toString = function () {\n    return \"[object Promise]\";\n  };\n  Promise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n      var catchInstances = new Array(len - 1),\n        j = 0,\n        i;\n      for (i = 0; i < len - 1; ++i) {\n        var item = arguments[i];\n        if (util.isObject(item)) {\n          catchInstances[j++] = item;\n        } else {\n          return apiRejection(\"expecting an object but got \" + \"A catch statement predicate \" + util.classString(item));\n        }\n      }\n      catchInstances.length = j;\n      fn = arguments[i];\n      return this.then(undefined, catchFilter(catchInstances, fn, this));\n    }\n    return this.then(undefined, fn);\n  };\n  Promise.prototype.reflect = function () {\n    return this._then(reflectHandler, reflectHandler, undefined, this, undefined);\n  };\n  Promise.prototype.then = function (didFulfill, didReject) {\n    if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== \"function\" && typeof didReject !== \"function\") {\n      var msg = \".then() only accepts functions but was passed: \" + util.classString(didFulfill);\n      if (arguments.length > 1) {\n        msg += \", \" + util.classString(didReject);\n      }\n      this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n  };\n  Promise.prototype.done = function (didFulfill, didReject) {\n    var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);\n    promise._setIsFinal();\n  };\n  Promise.prototype.spread = function (fn) {\n    if (typeof fn !== \"function\") {\n      return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n  };\n  Promise.prototype.toJSON = function () {\n    var ret = {\n      isFulfilled: false,\n      isRejected: false,\n      fulfillmentValue: undefined,\n      rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n      ret.fulfillmentValue = this.value();\n      ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n      ret.rejectionReason = this.reason();\n      ret.isRejected = true;\n    }\n    return ret;\n  };\n  Promise.prototype.all = function () {\n    if (arguments.length > 0) {\n      this._warn(\".all() was passed arguments but it does not take any\");\n    }\n    return new PromiseArray(this).promise();\n  };\n  Promise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n  };\n  Promise.getNewLibraryCopy = module.exports;\n  Promise.is = function (val) {\n    return val instanceof Promise;\n  };\n  Promise.fromNode = Promise.fromCallback = function (fn) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;\n    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n    if (result === errorObj) {\n      ret._rejectCallback(result.e, true);\n    }\n    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n    return ret;\n  };\n  Promise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n  };\n  Promise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n      ret = new Promise(INTERNAL);\n      ret._captureStackTrace();\n      ret._setFulfilled();\n      ret._rejectionHandler0 = obj;\n    }\n    return ret;\n  };\n  Promise.resolve = Promise.fulfilled = Promise.cast;\n  Promise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n  };\n  Promise.setScheduler = function (fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return async.setScheduler(fn);\n  };\n  Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {\n    var haveInternalData = internalData !== undefined;\n    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n    var target = this._target();\n    var bitField = target._bitField;\n    if (!haveInternalData) {\n      promise._propagateFrom(this, 3);\n      promise._captureStackTrace();\n      if (receiver === undefined && (this._bitField & 2097152) !== 0) {\n        if (!((bitField & 50397184) === 0)) {\n          receiver = this._boundValue();\n        } else {\n          receiver = target === this ? undefined : this._boundTo;\n        }\n      }\n      this._fireEvent(\"promiseChained\", this, promise);\n    }\n    var domain = getDomain();\n    if (!((bitField & 50397184) === 0)) {\n      var handler,\n        value,\n        settler = target._settlePromiseCtx;\n      if ((bitField & 33554432) !== 0) {\n        value = target._rejectionHandler0;\n        handler = didFulfill;\n      } else if ((bitField & 16777216) !== 0) {\n        value = target._fulfillmentHandler0;\n        handler = didReject;\n        target._unsetRejectionIsUnhandled();\n      } else {\n        settler = target._settlePromiseLateCancellationObserver;\n        value = new CancellationError(\"late cancellation observer\");\n        target._attachExtraTrace(value);\n        handler = didReject;\n      }\n      async.invoke(settler, target, {\n        handler: domain === null ? handler : typeof handler === \"function\" && util.domainBind(domain, handler),\n        promise: promise,\n        receiver: receiver,\n        value: value\n      });\n    } else {\n      target._addCallbacks(didFulfill, didReject, promise, receiver, domain);\n    }\n    return promise;\n  };\n  Promise.prototype._length = function () {\n    return this._bitField & 65535;\n  };\n  Promise.prototype._isFateSealed = function () {\n    return (this._bitField & 117506048) !== 0;\n  };\n  Promise.prototype._isFollowing = function () {\n    return (this._bitField & 67108864) === 67108864;\n  };\n  Promise.prototype._setLength = function (len) {\n    this._bitField = this._bitField & -65536 | len & 65535;\n  };\n  Promise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 33554432;\n    this._fireEvent(\"promiseFulfilled\", this);\n  };\n  Promise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 16777216;\n    this._fireEvent(\"promiseRejected\", this);\n  };\n  Promise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 67108864;\n    this._fireEvent(\"promiseResolved\", this);\n  };\n  Promise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 4194304;\n  };\n  Promise.prototype._isFinal = function () {\n    return (this._bitField & 4194304) > 0;\n  };\n  Promise.prototype._unsetCancelled = function () {\n    this._bitField = this._bitField & ~65536;\n  };\n  Promise.prototype._setCancelled = function () {\n    this._bitField = this._bitField | 65536;\n    this._fireEvent(\"promiseCancelled\", this);\n  };\n  Promise.prototype._setWillBeCancelled = function () {\n    this._bitField = this._bitField | 8388608;\n  };\n  Promise.prototype._setAsyncGuaranteed = function () {\n    if (async.hasCustomScheduler()) return;\n    this._bitField = this._bitField | 134217728;\n  };\n  Promise.prototype._receiverAt = function (index) {\n    var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];\n    if (ret === UNDEFINED_BINDING) {\n      return undefined;\n    } else if (ret === undefined && this._isBound()) {\n      return this._boundValue();\n    }\n    return ret;\n  };\n  Promise.prototype._promiseAt = function (index) {\n    return this[index * 4 - 4 + 2];\n  };\n  Promise.prototype._fulfillmentHandlerAt = function (index) {\n    return this[index * 4 - 4 + 0];\n  };\n  Promise.prototype._rejectionHandlerAt = function (index) {\n    return this[index * 4 - 4 + 1];\n  };\n  Promise.prototype._boundValue = function () {};\n  Promise.prototype._migrateCallback0 = function (follower) {\n    var bitField = follower._bitField;\n    var fulfill = follower._fulfillmentHandler0;\n    var reject = follower._rejectionHandler0;\n    var promise = follower._promise0;\n    var receiver = follower._receiverAt(0);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n  };\n  Promise.prototype._migrateCallbackAt = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n  };\n  Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {\n    var index = this._length();\n    if (index >= 65535 - 4) {\n      index = 0;\n      this._setLength(0);\n    }\n    if (index === 0) {\n      this._promise0 = promise;\n      this._receiver0 = receiver;\n      if (typeof fulfill === \"function\") {\n        this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);\n      }\n      if (typeof reject === \"function\") {\n        this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);\n      }\n    } else {\n      var base = index * 4 - 4;\n      this[base + 2] = promise;\n      this[base + 3] = receiver;\n      if (typeof fulfill === \"function\") {\n        this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);\n      }\n      if (typeof reject === \"function\") {\n        this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);\n      }\n    }\n    this._setLength(index + 1);\n    return index;\n  };\n  Promise.prototype._proxy = function (proxyable, arg) {\n    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n  };\n  Promise.prototype._resolveCallback = function (value, shouldBind) {\n    if ((this._bitField & 117506048) !== 0) return;\n    if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n    if (shouldBind) this._propagateFrom(maybePromise, 2);\n    var promise = maybePromise._target();\n    if (promise === this) {\n      this._reject(makeSelfResolutionError());\n      return;\n    }\n    var bitField = promise._bitField;\n    if ((bitField & 50397184) === 0) {\n      var len = this._length();\n      if (len > 0) promise._migrateCallback0(this);\n      for (var i = 1; i < len; ++i) {\n        promise._migrateCallbackAt(this, i);\n      }\n      this._setFollowing();\n      this._setLength(0);\n      this._setFollowee(promise);\n    } else if ((bitField & 33554432) !== 0) {\n      this._fulfill(promise._value());\n    } else if ((bitField & 16777216) !== 0) {\n      this._reject(promise._reason());\n    } else {\n      var reason = new CancellationError(\"late cancellation observer\");\n      promise._attachExtraTrace(reason);\n      this._reject(reason);\n    }\n  };\n  Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n      var message = \"a promise was rejected with a non-error: \" + util.classString(reason);\n      this._warn(message, true);\n    }\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason);\n  };\n  Promise.prototype._resolveFromExecutor = function (executor) {\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = this._execute(executor, function (value) {\n      promise._resolveCallback(value);\n    }, function (reason) {\n      promise._rejectCallback(reason, synchronous);\n    });\n    synchronous = false;\n    this._popContext();\n    if (r !== undefined) {\n      promise._rejectCallback(r, true);\n    }\n  };\n  Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {\n    var bitField = promise._bitField;\n    if ((bitField & 65536) !== 0) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY) {\n      if (!value || typeof value.length !== \"number\") {\n        x = errorObj;\n        x.e = new TypeError(\"cannot .spread() a non-array: \" + util.classString(value));\n      } else {\n        x = tryCatch(handler).apply(this._boundValue(), value);\n      }\n    } else {\n      x = tryCatch(handler).call(receiver, value);\n    }\n    var promiseCreated = promise._popContext();\n    bitField = promise._bitField;\n    if ((bitField & 65536) !== 0) return;\n    if (x === NEXT_FILTER) {\n      promise._reject(value);\n    } else if (x === errorObj) {\n      promise._rejectCallback(x.e, false);\n    } else {\n      debug.checkForgottenReturns(x, promiseCreated, \"\", promise, this);\n      promise._resolveCallback(x);\n    }\n  };\n  Promise.prototype._target = function () {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n  };\n  Promise.prototype._followee = function () {\n    return this._rejectionHandler0;\n  };\n  Promise.prototype._setFollowee = function (promise) {\n    this._rejectionHandler0 = promise;\n  };\n  Promise.prototype._settlePromise = function (promise, handler, receiver, value) {\n    var isPromise = promise instanceof Promise;\n    var bitField = this._bitField;\n    var asyncGuaranteed = (bitField & 134217728) !== 0;\n    if ((bitField & 65536) !== 0) {\n      if (isPromise) promise._invokeInternalOnCancel();\n      if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {\n        receiver.cancelPromise = promise;\n        if (tryCatch(handler).call(receiver, value) === errorObj) {\n          promise._reject(errorObj.e);\n        }\n      } else if (handler === reflectHandler) {\n        promise._fulfill(reflectHandler.call(receiver));\n      } else if (receiver instanceof Proxyable) {\n        receiver._promiseCancelled(promise);\n      } else if (isPromise || promise instanceof PromiseArray) {\n        promise._cancel();\n      } else {\n        receiver.cancel();\n      }\n    } else if (typeof handler === \"function\") {\n      if (!isPromise) {\n        handler.call(receiver, value, promise);\n      } else {\n        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n        this._settlePromiseFromHandler(handler, receiver, value, promise);\n      }\n    } else if (receiver instanceof Proxyable) {\n      if (!receiver._isResolved()) {\n        if ((bitField & 33554432) !== 0) {\n          receiver._promiseFulfilled(value, promise);\n        } else {\n          receiver._promiseRejected(value, promise);\n        }\n      }\n    } else if (isPromise) {\n      if (asyncGuaranteed) promise._setAsyncGuaranteed();\n      if ((bitField & 33554432) !== 0) {\n        promise._fulfill(value);\n      } else {\n        promise._reject(value);\n      }\n    }\n  };\n  Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {\n    var handler = ctx.handler;\n    var promise = ctx.promise;\n    var receiver = ctx.receiver;\n    var value = ctx.value;\n    if (typeof handler === \"function\") {\n      if (!(promise instanceof Promise)) {\n        handler.call(receiver, value, promise);\n      } else {\n        this._settlePromiseFromHandler(handler, receiver, value, promise);\n      }\n    } else if (promise instanceof Promise) {\n      promise._reject(value);\n    }\n  };\n  Promise.prototype._settlePromiseCtx = function (ctx) {\n    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n  };\n  Promise.prototype._settlePromise0 = function (handler, value, bitField) {\n    var promise = this._promise0;\n    var receiver = this._receiverAt(0);\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settlePromise(promise, handler, receiver, value);\n  };\n  Promise.prototype._clearCallbackDataAtIndex = function (index) {\n    var base = index * 4 - 4;\n    this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;\n  };\n  Promise.prototype._fulfill = function (value) {\n    var bitField = this._bitField;\n    if ((bitField & 117506048) >>> 16) return;\n    if (value === this) {\n      var err = makeSelfResolutionError();\n      this._attachExtraTrace(err);\n      return this._reject(err);\n    }\n    this._setFulfilled();\n    this._rejectionHandler0 = value;\n    if ((bitField & 65535) > 0) {\n      if ((bitField & 134217728) !== 0) {\n        this._settlePromises();\n      } else {\n        async.settlePromises(this);\n      }\n    }\n  };\n  Promise.prototype._reject = function (reason) {\n    var bitField = this._bitField;\n    if ((bitField & 117506048) >>> 16) return;\n    this._setRejected();\n    this._fulfillmentHandler0 = reason;\n    if (this._isFinal()) {\n      return async.fatalError(reason, util.isNode);\n    }\n    if ((bitField & 65535) > 0) {\n      async.settlePromises(this);\n    } else {\n      this._ensurePossibleRejectionHandled();\n    }\n  };\n  Promise.prototype._fulfillPromises = function (len, value) {\n    for (var i = 1; i < len; i++) {\n      var handler = this._fulfillmentHandlerAt(i);\n      var promise = this._promiseAt(i);\n      var receiver = this._receiverAt(i);\n      this._clearCallbackDataAtIndex(i);\n      this._settlePromise(promise, handler, receiver, value);\n    }\n  };\n  Promise.prototype._rejectPromises = function (len, reason) {\n    for (var i = 1; i < len; i++) {\n      var handler = this._rejectionHandlerAt(i);\n      var promise = this._promiseAt(i);\n      var receiver = this._receiverAt(i);\n      this._clearCallbackDataAtIndex(i);\n      this._settlePromise(promise, handler, receiver, reason);\n    }\n  };\n  Promise.prototype._settlePromises = function () {\n    var bitField = this._bitField;\n    var len = bitField & 65535;\n    if (len > 0) {\n      if ((bitField & 16842752) !== 0) {\n        var reason = this._fulfillmentHandler0;\n        this._settlePromise0(this._rejectionHandler0, reason, bitField);\n        this._rejectPromises(len, reason);\n      } else {\n        var value = this._rejectionHandler0;\n        this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n        this._fulfillPromises(len, value);\n      }\n      this._setLength(0);\n    }\n    this._clearCancellationData();\n  };\n  Promise.prototype._settledValue = function () {\n    var bitField = this._bitField;\n    if ((bitField & 33554432) !== 0) {\n      return this._rejectionHandler0;\n    } else if ((bitField & 16777216) !== 0) {\n      return this._fulfillmentHandler0;\n    }\n  };\n  function deferResolve(v) {\n    this.promise._resolveCallback(v);\n  }\n  function deferReject(v) {\n    this.promise._rejectCallback(v, false);\n  }\n  Promise.defer = Promise.pending = function () {\n    debug.deprecated(\"Promise.defer\", \"new Promise\");\n    var promise = new Promise(INTERNAL);\n    return {\n      promise: promise,\n      resolve: deferResolve,\n      reject: deferReject\n    };\n  };\n  util.notEnumerableProp(Promise, \"_makeSelfResolutionError\", makeSelfResolutionError);\n  require(\"./method\")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);\n  require(\"./bind\")(Promise, INTERNAL, tryConvertToPromise, debug);\n  require(\"./cancel\")(Promise, PromiseArray, apiRejection, debug);\n  require(\"./direct_resolve\")(Promise);\n  require(\"./synchronous_inspection\")(Promise);\n  require(\"./join\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);\n  Promise.Promise = Promise;\n  Promise.version = \"3.4.7\";\n  require('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n  require('./call_get.js')(Promise);\n  require('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\n  require('./timers.js')(Promise, INTERNAL, debug);\n  require('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\n  require('./nodeify.js')(Promise);\n  require('./promisify.js')(Promise, INTERNAL);\n  require('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n  require('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n  require('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n  require('./settle.js')(Promise, PromiseArray, debug);\n  require('./some.js')(Promise, PromiseArray, apiRejection);\n  require('./filter.js')(Promise, INTERNAL);\n  require('./each.js')(Promise, INTERNAL);\n  require('./any.js')(Promise);\n  util.toFastProperties(Promise);\n  util.toFastProperties(Promise.prototype);\n  function fillTypes(value) {\n    var p = new Promise(INTERNAL);\n    p._fulfillmentHandler0 = value;\n    p._rejectionHandler0 = value;\n    p._promise0 = value;\n    p._receiver0 = value;\n  }\n  // Complete slack tracking, opt out of field-type tracking and           \n  // stabilize map                                                         \n  fillTypes({\n    a: 1\n  });\n  fillTypes({\n    b: 2\n  });\n  fillTypes({\n    c: 3\n  });\n  fillTypes(1);\n  fillTypes(function () {});\n  fillTypes(undefined);\n  fillTypes(false);\n  fillTypes(new Promise(INTERNAL));\n  debug.setBounds(Async.firstLineError, util.lastLineError);\n  return Promise;\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}