{"ast":null,"code":"var _ = require(\"underscore\");\nvar options = require(\"option\");\nvar results = require(\"./parsing-results\");\nvar errors = require(\"./errors\");\nvar lazyIterators = require(\"./lazy-iterators\");\nexports.token = function (tokenType, value) {\n  var matchValue = value !== undefined;\n  return function (input) {\n    var token = input.head();\n    if (token && token.name === tokenType && (!matchValue || token.value === value)) {\n      return results.success(token.value, input.tail(), token.source);\n    } else {\n      var expected = describeToken({\n        name: tokenType,\n        value: value\n      });\n      return describeTokenMismatch(input, expected);\n    }\n  };\n};\nexports.tokenOfType = function (tokenType) {\n  return exports.token(tokenType);\n};\nexports.firstOf = function (name, parsers) {\n  if (!_.isArray(parsers)) {\n    parsers = Array.prototype.slice.call(arguments, 1);\n  }\n  return function (input) {\n    return lazyIterators.fromArray(parsers).map(function (parser) {\n      return parser(input);\n    }).filter(function (result) {\n      return result.isSuccess() || result.isError();\n    }).first() || describeTokenMismatch(input, name);\n  };\n};\nexports.then = function (parser, func) {\n  return function (input) {\n    var result = parser(input);\n    if (!result.map) {\n      console.log(result);\n    }\n    return result.map(func);\n  };\n};\nexports.sequence = function () {\n  var parsers = Array.prototype.slice.call(arguments, 0);\n  var rule = function (input) {\n    var result = _.foldl(parsers, function (memo, parser) {\n      var result = memo.result;\n      var hasCut = memo.hasCut;\n      if (!result.isSuccess()) {\n        return {\n          result: result,\n          hasCut: hasCut\n        };\n      }\n      var subResult = parser(result.remaining());\n      if (subResult.isCut()) {\n        return {\n          result: result,\n          hasCut: true\n        };\n      } else if (subResult.isSuccess()) {\n        var values;\n        if (parser.isCaptured) {\n          values = result.value().withValue(parser, subResult.value());\n        } else {\n          values = result.value();\n        }\n        var remaining = subResult.remaining();\n        var source = input.to(remaining);\n        return {\n          result: results.success(values, remaining, source),\n          hasCut: hasCut\n        };\n      } else if (hasCut) {\n        return {\n          result: results.error(subResult.errors(), subResult.remaining()),\n          hasCut: hasCut\n        };\n      } else {\n        return {\n          result: subResult,\n          hasCut: hasCut\n        };\n      }\n    }, {\n      result: results.success(new SequenceValues(), input),\n      hasCut: false\n    }).result;\n    var source = input.to(result.remaining());\n    return result.map(function (values) {\n      return values.withValue(exports.sequence.source, source);\n    });\n  };\n  rule.head = function () {\n    var firstCapture = _.find(parsers, isCapturedRule);\n    return exports.then(rule, exports.sequence.extract(firstCapture));\n  };\n  rule.map = function (func) {\n    return exports.then(rule, function (result) {\n      return func.apply(this, result.toArray());\n    });\n  };\n  function isCapturedRule(subRule) {\n    return subRule.isCaptured;\n  }\n  return rule;\n};\nvar SequenceValues = function (values, valuesArray) {\n  this._values = values || {};\n  this._valuesArray = valuesArray || [];\n};\nSequenceValues.prototype.withValue = function (rule, value) {\n  if (rule.captureName && rule.captureName in this._values) {\n    throw new Error(\"Cannot add second value for capture \\\"\" + rule.captureName + \"\\\"\");\n  } else {\n    var newValues = _.clone(this._values);\n    newValues[rule.captureName] = value;\n    var newValuesArray = this._valuesArray.concat([value]);\n    return new SequenceValues(newValues, newValuesArray);\n  }\n};\nSequenceValues.prototype.get = function (rule) {\n  if (rule.captureName in this._values) {\n    return this._values[rule.captureName];\n  } else {\n    throw new Error(\"No value for capture \\\"\" + rule.captureName + \"\\\"\");\n  }\n};\nSequenceValues.prototype.toArray = function () {\n  return this._valuesArray;\n};\nexports.sequence.capture = function (rule, name) {\n  var captureRule = function () {\n    return rule.apply(this, arguments);\n  };\n  captureRule.captureName = name;\n  captureRule.isCaptured = true;\n  return captureRule;\n};\nexports.sequence.extract = function (rule) {\n  return function (result) {\n    return result.get(rule);\n  };\n};\nexports.sequence.applyValues = function (func) {\n  // TODO: check captureName doesn't conflict with source or other captures\n  var rules = Array.prototype.slice.call(arguments, 1);\n  return function (result) {\n    var values = rules.map(function (rule) {\n      return result.get(rule);\n    });\n    return func.apply(this, values);\n  };\n};\nexports.sequence.source = {\n  captureName: \"☃source☃\"\n};\nexports.sequence.cut = function () {\n  return function (input) {\n    return results.cut(input);\n  };\n};\nexports.optional = function (rule) {\n  return function (input) {\n    var result = rule(input);\n    if (result.isSuccess()) {\n      return result.map(options.some);\n    } else if (result.isFailure()) {\n      return results.success(options.none, input);\n    } else {\n      return result;\n    }\n  };\n};\nexports.zeroOrMoreWithSeparator = function (rule, separator) {\n  return repeatedWithSeparator(rule, separator, false);\n};\nexports.oneOrMoreWithSeparator = function (rule, separator) {\n  return repeatedWithSeparator(rule, separator, true);\n};\nvar zeroOrMore = exports.zeroOrMore = function (rule) {\n  return function (input) {\n    var values = [];\n    var result;\n    while ((result = rule(input)) && result.isSuccess()) {\n      input = result.remaining();\n      values.push(result.value());\n    }\n    if (result.isError()) {\n      return result;\n    } else {\n      return results.success(values, input);\n    }\n  };\n};\nexports.oneOrMore = function (rule) {\n  return exports.oneOrMoreWithSeparator(rule, noOpRule);\n};\nfunction noOpRule(input) {\n  return results.success(null, input);\n}\nvar repeatedWithSeparator = function (rule, separator, isOneOrMore) {\n  return function (input) {\n    var result = rule(input);\n    if (result.isSuccess()) {\n      var mainRule = exports.sequence.capture(rule, \"main\");\n      var remainingRule = zeroOrMore(exports.then(exports.sequence(separator, mainRule), exports.sequence.extract(mainRule)));\n      var remainingResult = remainingRule(result.remaining());\n      return results.success([result.value()].concat(remainingResult.value()), remainingResult.remaining());\n    } else if (isOneOrMore || result.isError()) {\n      return result;\n    } else {\n      return results.success([], input);\n    }\n  };\n};\nexports.leftAssociative = function (leftRule, rightRule, func) {\n  var rights;\n  if (func) {\n    rights = [{\n      func: func,\n      rule: rightRule\n    }];\n  } else {\n    rights = rightRule;\n  }\n  rights = rights.map(function (right) {\n    return exports.then(right.rule, function (rightValue) {\n      return function (leftValue, source) {\n        return right.func(leftValue, rightValue, source);\n      };\n    });\n  });\n  var repeatedRule = exports.firstOf.apply(null, [\"rules\"].concat(rights));\n  return function (input) {\n    var start = input;\n    var leftResult = leftRule(input);\n    if (!leftResult.isSuccess()) {\n      return leftResult;\n    }\n    var repeatedResult = repeatedRule(leftResult.remaining());\n    while (repeatedResult.isSuccess()) {\n      var remaining = repeatedResult.remaining();\n      var source = start.to(repeatedResult.remaining());\n      var right = repeatedResult.value();\n      leftResult = results.success(right(leftResult.value(), source), remaining, source);\n      repeatedResult = repeatedRule(leftResult.remaining());\n    }\n    if (repeatedResult.isError()) {\n      return repeatedResult;\n    }\n    return leftResult;\n  };\n};\nexports.leftAssociative.firstOf = function () {\n  return Array.prototype.slice.call(arguments, 0);\n};\nexports.nonConsuming = function (rule) {\n  return function (input) {\n    return rule(input).changeRemaining(input);\n  };\n};\nvar describeToken = function (token) {\n  if (token.value) {\n    return token.name + \" \\\"\" + token.value + \"\\\"\";\n  } else {\n    return token.name;\n  }\n};\nfunction describeTokenMismatch(input, expected) {\n  var error;\n  var token = input.head();\n  if (token) {\n    error = errors.error({\n      expected: expected,\n      actual: describeToken(token),\n      location: token.source\n    });\n  } else {\n    error = errors.error({\n      expected: expected,\n      actual: \"end of tokens\"\n    });\n  }\n  return results.failure([error], input);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}