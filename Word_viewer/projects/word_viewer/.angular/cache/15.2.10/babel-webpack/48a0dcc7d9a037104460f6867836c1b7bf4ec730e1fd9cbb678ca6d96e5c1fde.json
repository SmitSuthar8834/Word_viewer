{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\n  var util = require(\"./util\");\n  var tryCatch = util.tryCatch;\n  Promise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n      throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return function () {\n      var ret = new Promise(INTERNAL);\n      ret._captureStackTrace();\n      ret._pushContext();\n      var value = tryCatch(fn).apply(this, arguments);\n      var promiseCreated = ret._popContext();\n      debug.checkForgottenReturns(value, promiseCreated, \"Promise.method\", ret);\n      ret._resolveFromSyncValue(value);\n      return ret;\n    };\n  };\n  Promise.attempt = Promise[\"try\"] = function (fn) {\n    if (typeof fn !== \"function\") {\n      return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value;\n    if (arguments.length > 1) {\n      debug.deprecated(\"calling Promise.try with more than 1 argument\");\n      var arg = arguments[1];\n      var ctx = arguments[2];\n      value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);\n    } else {\n      value = tryCatch(fn)();\n    }\n    var promiseCreated = ret._popContext();\n    debug.checkForgottenReturns(value, promiseCreated, \"Promise.try\", ret);\n    ret._resolveFromSyncValue(value);\n    return ret;\n  };\n  Promise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n      this._rejectCallback(value.e, false);\n    } else {\n      this._resolveCallback(value, true);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}