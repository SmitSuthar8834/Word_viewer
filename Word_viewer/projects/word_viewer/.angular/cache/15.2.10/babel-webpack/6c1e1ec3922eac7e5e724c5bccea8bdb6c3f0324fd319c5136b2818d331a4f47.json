{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Lenovo/Desktop/WORD_viewer/Word_viewer/projects/word_viewer/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ɵAggregationType, ɵAggregationFunction, ɵAggregationEvalType, ɵDatePartType, ɵFunctionType, ɵOrderDirection, ɵgenerateGuid, ɵNextHandlerAlreadySpecifiedException, ɵBaseRequest } from '@creatio/base';\nexport { ɵAggregationEvalType as AggregationEvalType, ɵAggregationFunction as AggregationFunction, ɵAggregationFunctionColumn as AggregationFunctionColumn, ɵAggregationFunctionExpression as AggregationFunctionExpression, ɵAggregationSubQueryColumn as AggregationSubQueryColumn, ɵAggregationSubQueryExpression as AggregationSubQueryExpression, ɵAggregationType as AggregationType, ɵArgumentEmptyException as ArgumentEmptyException, ɵArgumentFunctionExpression as ArgumentFunctionExpression, ɵArgumentOutOfRangeException as ArgumentOutOfRangeException, ɵArithmeticExpression as ArithmeticExpression, ɵArithmeticOperation as ArithmeticOperation, ɵArithmeticQueryColumn as ArithmeticQueryColumn, ɵBaseExpression as BaseExpression, ɵBaseExpressionParser as BaseExpressionParser, ɵBaseFilter as BaseFilter, ɵBaseFilterParser as BaseFilterParser, ɵBaseFilterableQuery as BaseFilterableQuery, ɵBaseQuery as BaseQuery, ɵBaseQueryColumn as BaseQueryColumn, ɵBaseRequest as BaseRequest, ɵBetweenFilter as BetweenFilter, ɵColumnExpression as ColumnExpression, ɵCompareFilter as CompareFilter, ɵComparisonType as ComparisonType, ɵDEFAULT_COLUMN_PLAIN_OBJ as DEFAULT_COLUMN_PLAIN_OBJ, ɵDEFAULT_FILTER_PLAIN_OBJ as DEFAULT_FILTER_PLAIN_OBJ, ɵDataSchemaAttributeType as DataSchemaAttributeType, ɵDataSchemaAttributeUsageType as DataSchemaAttributeUsageType, ɵDataSchemaType as DataSchemaType, ɵDataSourceScope as DataSourceScope, ɵDataValueType as DataValueType, ɵDatePartFunctionColumn as DatePartFunctionColumn, ɵDatePartFunctionExpression as DatePartFunctionExpression, ɵDatePartType as DatePartType, ɵDefaultValueSource as DefaultValueSource, ɵDeleteQuery as DeleteQuery, ɵEMPTY_GUID as EMPTY_GUID, ɵEntityQueryColumn as EntityQueryColumn, ɵEntitySchemaQuery as EntitySchemaQuery, ɵExistsFilter as ExistsFilter, ɵExpressionMock as ExpressionMock, ɵExpressionParser as ExpressionParser, ɵExpressionResolver as ExpressionResolver, ɵExpressionType as ExpressionType, ɵFilterGroup as FilterGroup, ɵFilterMock as FilterMock, ɵFilterParser as FilterParser, ɵFilterResolver as FilterResolver, ɵFilterType as FilterType, ɵFunctionExpression as FunctionExpression, ɵFunctionType as FunctionType, ɵInFilter as InFilter, ɵInsertQuery as InsertQuery, ɵIsNullFilter as IsNullFilter, ɵItemNotFoundException as ItemNotFoundException, ɵLengthFunctionColumn as LengthFunctionColumn, ɵLengthFunctionExpression as LengthFunctionExpression, ɵLogicalOperatorType as LogicalOperatorType, ɵMacrosFunctionColumn as MacrosFunctionColumn, ɵMacrosFunctionExpression as MacrosFunctionExpression, ɵModelParameterType as ModelParameterType, ɵNextHandlerAlreadySpecifiedException as NextHandlerAlreadySpecifiedException, ɵOrderDirection as OrderDirection, ɵParameterExpression as ParameterExpression, ɵParameterQueryColumn as ParameterQueryColumn, ɵQueryMacrosType as QueryMacrosType, ɵQueryOperationType as QueryOperationType, ɵSelectLocalizationQuery as SelectLocalizationQuery, ɵSingleFilter as SingleFilter, ɵSubQueryColumn as SubQueryColumn, ɵSubQueryExpression as SubQueryExpression, ɵUpdateQuery as UpdateQuery, ɵValidationUtilities as ValidationUtilities, ɵWindowFunctionColumn as WindowFunctionColumn, ɵWindowFunctionExpression as WindowFunctionExpression, ɵencodeDate as encodeDate, ɵgenerateGuid as generateGuid, ɵgetColumnPlainObj as getColumnPlainObj, ɵgetFilterPlainObj as getFilterPlainObj, ɵisEmptyGuid as isEmptyGuid, ɵisGuid as isGuid, ɵparserMock as parserMock, ɵtoLocalISOString as toLocalISOString } from '@creatio/base';\nimport { get, set, upperFirst, camelCase, isEqual, cloneDeep } from 'lodash';\nimport 'reflect-metadata';\nimport { __decorate, __metadata } from 'tslib';\n\n/**\n * @internal\n */\nfunction toAggregationType(aggregationFunction) {\n  switch (aggregationFunction) {\n    case ɵAggregationFunction.Count:\n      return ɵAggregationType.Count;\n    case ɵAggregationFunction.Sum:\n      return ɵAggregationType.Sum;\n    case ɵAggregationFunction.Avg:\n      return ɵAggregationType.Avg;\n    case ɵAggregationFunction.Min:\n      return ɵAggregationType.Min;\n    case ɵAggregationFunction.Max:\n      return ɵAggregationType.Max;\n    case ɵAggregationFunction.TopOne:\n      return ɵAggregationType.TopOne;\n    default:\n      return ɵAggregationType.None;\n  }\n}\n/**\n * @internal\n */\nfunction toAggregationFunction(aggregationType) {\n  switch (aggregationType) {\n    case ɵAggregationType.Count:\n      return ɵAggregationFunction.Count;\n    case ɵAggregationType.Sum:\n      return ɵAggregationFunction.Sum;\n    case ɵAggregationType.Avg:\n      return ɵAggregationFunction.Avg;\n    case ɵAggregationType.Min:\n      return ɵAggregationFunction.Min;\n    case ɵAggregationType.Max:\n      return ɵAggregationFunction.Max;\n    case ɵAggregationType.TopOne:\n      return ɵAggregationFunction.TopOne;\n    default:\n      return ɵAggregationFunction.None;\n  }\n}\n/**\n * @internal\n */\nfunction toAggregationEvalType(aggregationEval) {\n  switch (aggregationEval) {\n    case 'all':\n      return ɵAggregationEvalType.All;\n    case 'distinct':\n      return ɵAggregationEvalType.Distinct;\n    default:\n      return ɵAggregationEvalType.None;\n  }\n}\n/**\n * @internal\n */\nfunction toAggregationEval(aggregationEvalType) {\n  switch (aggregationEvalType) {\n    case ɵAggregationEvalType.All:\n      return 'all';\n    case ɵAggregationEvalType.Distinct:\n      return 'distinct';\n    default:\n      return 'none';\n  }\n}\n\n/**\n * @internal\n */\nfunction toDatePartType(aggregationFunction) {\n  switch (aggregationFunction) {\n    case 'minute':\n      return ɵDatePartType.HourMinute;\n    case 'hour':\n      return ɵDatePartType.Hour;\n    case 'day':\n      return ɵDatePartType.Day;\n    case 'weekday':\n      return ɵDatePartType.WeekDay;\n    case 'week':\n      return ɵDatePartType.Week;\n    case 'month':\n      return ɵDatePartType.Month;\n    case 'year':\n      return ɵDatePartType.Year;\n    default:\n      return ɵDatePartType.None;\n  }\n}\n/**\n * @internal\n */\nfunction toDatePart(aggregationType) {\n  switch (aggregationType) {\n    case ɵDatePartType.HourMinute:\n      return 'minute';\n    case ɵDatePartType.Hour:\n      return 'hour';\n    case ɵDatePartType.Day:\n      return 'day';\n    case ɵDatePartType.WeekDay:\n      return 'weekday';\n    case ɵDatePartType.Week:\n      return 'week';\n    case ɵDatePartType.Month:\n      return 'month';\n    case ɵDatePartType.Year:\n      return 'year';\n    default:\n      return 'none';\n  }\n}\n\n/**\n * @internal\n */\nfunction toStringFunctionType(functionType) {\n  switch (functionType) {\n    case ɵFunctionType.Aggregation:\n      return 'aggregation';\n    case ɵFunctionType.DatePart:\n      return 'datePart';\n    default:\n      return 'none';\n  }\n}\n/**\n * @internal\n */\nfunction toNumericFunctionType(functionType) {\n  switch (functionType) {\n    case 'aggregation':\n      return ɵFunctionType.Aggregation;\n    case 'datePart':\n      return ɵFunctionType.DatePart;\n    default:\n      return ɵFunctionType.None;\n  }\n}\n\n/**\n * @internal\n */\nfunction toOrderDirection(sortDirection) {\n  switch (sortDirection) {\n    case 'asc':\n      return ɵOrderDirection.Asc;\n    case 'desc':\n      return ɵOrderDirection.Desc;\n    default:\n      return ɵOrderDirection.None;\n  }\n}\n/**\n * @internal\n */\nfunction toSortDirection(orderDirection) {\n  switch (orderDirection) {\n    case ɵOrderDirection.Asc:\n      return 'asc';\n    case ɵOrderDirection.Desc:\n      return 'desc';\n    default:\n      return 'none';\n  }\n}\n\n/**\n * @internal\n */\nconst crtInputPrefix = 'crtInput:';\n/**\n * @internal\n */\nconst crtOutputPrefix = 'crtOutput:';\n/**\n * @internal\n */\nconst crtValidationInputPrefix = 'crtValidationInput:';\n/**\n * @internal\n */\nconst crtInjectPrefix = 'crtInject:';\n\n/**\n * @internal\n * @hostPublicApi\n */\nvar ViewElementGroupType = /*#__PURE__*/(() => {\n  (function (ViewElementGroupType) {\n    ViewElementGroupType[\"Charts\"] = \"Charts\";\n    ViewElementGroupType[\"Components\"] = \"Components\";\n    ViewElementGroupType[\"LayoutElements\"] = \"LayoutElements\";\n    ViewElementGroupType[\"Inputs\"] = \"Inputs\";\n    ViewElementGroupType[\"CustomElements\"] = \"CustomElements\";\n  })(ViewElementGroupType || (ViewElementGroupType = {}));\n  return ViewElementGroupType;\n})();\n/**\n * @internal\n * @hostPublicApi\n */\nvar ViewElementDataGroupType = /*#__PURE__*/(() => {\n  (function (ViewElementDataGroupType) {\n    ViewElementDataGroupType[\"Data\"] = \"Data\";\n  })(ViewElementDataGroupType || (ViewElementDataGroupType = {}));\n  return ViewElementDataGroupType;\n})();\n/**\n * @internal\n * @hostPublicApi\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst DesignerToolGroupType = {\n  ...ViewElementDataGroupType,\n  ...ViewElementGroupType\n};\n\n/**\n * Handler source types in order of call priority.\n * @internal\n * @hostPublicApi\n */\nvar HandlerSourceType = /*#__PURE__*/(() => {\n  (function (HandlerSourceType) {\n    HandlerSourceType[HandlerSourceType[\"Schema\"] = 0] = \"Schema\";\n    HandlerSourceType[HandlerSourceType[\"Remote\"] = 1] = \"Remote\";\n    HandlerSourceType[HandlerSourceType[\"Host\"] = 2] = \"Host\";\n  })(HandlerSourceType || (HandlerSourceType = {}));\n  return HandlerSourceType;\n})();\n/**\n * @internal\n */\nvar ModelInPageAction = /*#__PURE__*/(() => {\n  (function (ModelInPageAction) {\n    ModelInPageAction[\"Edit\"] = \"edit\";\n    ModelInPageAction[\"Add\"] = \"add\";\n    ModelInPageAction[\"Copy\"] = \"copy\";\n  })(ModelInPageAction || (ModelInPageAction = {}));\n  return ModelInPageAction;\n})();\nconst global$3 = window;\n/**\n * @public\n * @description For internal use only.\n * @hostPublicApi\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nlet ɵBaseRegistry = /*#__PURE__*/(() => {\n  class ɵBaseRegistry {\n    constructor() {\n      /**\n       * @hostPubicApi available through window.creatio.registry.<registryKey>.store\n       */\n      this.store = {\n        typeInfos: new Map()\n      };\n    }\n    static get store() {\n      if (!this._instance) {\n        let globalInstance = get(global$3, this._prefix + this.registryKey);\n        if (!globalInstance) {\n          globalInstance = new this();\n          set(global$3, this._prefix + this.registryKey, globalInstance);\n        }\n        this._instance = globalInstance;\n      }\n      return this._instance.store;\n    }\n  }\n  ɵBaseRegistry._prefix = 'creatio.registry.';\n\n  /**\n   * @internal\n   */\n  return ɵBaseRegistry;\n})();\nlet PkgTopology = /*#__PURE__*/(() => {\n  class PkgTopology extends ɵBaseRegistry {\n    static get items() {\n      return this.store.typeInfos;\n    }\n    static get(pkgName) {\n      const order = this.items.get(pkgName);\n      if (order === undefined) {\n        throw new Error(`Package with name ${pkgName} not found in topology`);\n      }\n      return order;\n    }\n  }\n  PkgTopology.registryKey = 'pkgTopology';\n\n  /**\n   * @internal\n   */\n  return PkgTopology;\n})();\nclass HandlersOrderComparer {\n  constructor(_request) {\n    this._request = _request;\n    const scopesOrderEntries = [...(this._request.scopes ?? [])].reverse().map((scope, index) => [scope, index]);\n    this._scopesOrder = Object.fromEntries(scopesOrderEntries);\n  }\n  _getOrderByScopes(handler) {\n    if (!handler.scopes) {\n      return Number.MAX_VALUE;\n    }\n    const scopesOrder = handler.scopes.filter(s => s in this._scopesOrder).map(s => this._scopesOrder[s]);\n    return Math.min(...scopesOrder);\n  }\n  _getOrderByPkgTopology(handler) {\n    if (handler.source.type === HandlerSourceType.Host) {\n      return Number.MAX_VALUE;\n    }\n    return PkgTopology.get(handler.source.packageName);\n  }\n  compare(a, b) {\n    const aScopeOrder = this._getOrderByScopes(a);\n    const bScopeOrder = this._getOrderByScopes(b);\n    let diff = aScopeOrder - bScopeOrder;\n    if (diff) {\n      return diff;\n    }\n    const aPkgTopologyOrder = this._getOrderByPkgTopology(a);\n    const bPkgTopologyOrder = this._getOrderByPkgTopology(b);\n    diff = aPkgTopologyOrder - bPkgTopologyOrder;\n    if (diff) {\n      return diff;\n    }\n    diff = a.source.type - b.source.type;\n    return diff;\n  }\n}\n\n/**\n * @internal\n * @hostPublicApi available through window.handlerChain\n */\nclass InternalHandlerChain {\n  constructor() {\n    var _this = this;\n    this._handlers = [];\n    this._requestListeners = new Map();\n    this._handlersCache = new Map();\n    this._handlersScopesByContextId = new Map();\n    /**\n     * @hostPublicApi\n     */\n    this.handlerChain$ = {\n      /**\n       * @hostPublicApi\n       */\n      process: function () {\n        var _ref = _asyncToGenerator(function* (request) {\n          const handler = _this._getHandler(request);\n          _this._requestListeners.forEach(listener => listener?.(request));\n          return handler?.handle(request);\n        });\n        return function process(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }(),\n      /**\n       * @hostPublicApi\n       */\n      register: info => {\n        this._handlersCache.delete(info.requestType);\n        this._handlers.push(info);\n        return () => {\n          const index = this._handlers.indexOf(info);\n          if (index > -1) {\n            this._handlers.splice(index, 1);\n            this._handlersCache.delete(info.requestType);\n          } else {\n            console.warn(`${info?.requestType} not found to unsubscribe`);\n          }\n        };\n      },\n      /**\n       * @hostPublicApi\n       */\n      subscribe: (callback, context) => {\n        if (!callback) {\n          return () => void 0;\n        }\n        const listenerId = ɵgenerateGuid();\n        const listenerFn = request => {\n          if (!context || request.$context === context) {\n            callback(request);\n          }\n        };\n        this._requestListeners.set(listenerId, listenerFn);\n        return () => this._requestListeners.delete(listenerId);\n      }\n    };\n  }\n  /**\n   * @hostPublicApi\n   */\n  clearContextedHandlersCache(contextId) {\n    const configs = this._handlersScopesByContextId.get(contextId) ?? [];\n    return configs.every(({\n      requestType,\n      scope\n    }) => this._handlersCache.get(requestType)?.delete(scope));\n  }\n  _getHandler(request) {\n    return this._hasCacheHandler(request) ? this._getCacheHandler(request) : this._buildHandlersChain(request);\n  }\n  _getCacheHandler(request) {\n    const map = this._handlersCache.get(request.type);\n    const key = this._getCacheScopesKey(request);\n    return map.get(key);\n  }\n  _hasCacheHandler(request) {\n    const map = this._handlersCache.get(request.type);\n    const key = this._getCacheScopesKey(request);\n    return map && map.has(key);\n  }\n  _getCacheScopesKey(request) {\n    const injectionContextKey = this._getInjectionContext(request?.$context)?.id ?? '';\n    return (request.scopes || ['']).join('_').concat(injectionContextKey);\n  }\n  _getInjectionContext(viewModel) {\n    return viewModel?.['_injectionContext'] || viewModel?.['parent'] && this._getInjectionContext(viewModel['parent']);\n  }\n  _setContextedScopes(request, scope) {\n    const injectionContext = this._getInjectionContext(request?.$context)?.id;\n    const configs = this._handlersScopesByContextId.has(injectionContext) ? this._handlersScopesByContextId.get(injectionContext) : [];\n    configs.push({\n      requestType: request.type,\n      scope\n    });\n    this._handlersScopesByContextId.set(injectionContext, configs);\n  }\n  _setCacheHandler(request, handler) {\n    const map = this._handlersCache.has(request.type) ? this._handlersCache.get(request.type) : new Map();\n    const key = this._getCacheScopesKey(request);\n    map.set(key, handler);\n    if (this._getInjectionContext(request?.$context)?.id) {\n      this._setContextedScopes(request, key);\n    }\n    this._handlersCache.set(request.type, map);\n  }\n  _isRequestHandler(handler) {\n    return typeof handler.handle === 'function' && typeof handler.setNext === 'function';\n  }\n  _checkHandlerInstanceOf(handler) {\n    if (!this._isRequestHandler(handler)) {\n      throw new Error('Handler should implement \"BaseRequestHandler\"');\n    }\n  }\n  _buildHandlersChain(request) {\n    const handlers = this._handlers.filter(h => {\n      if (h.requestType !== request.type) {\n        return false;\n      }\n      if (!h.scopes?.length) {\n        return true;\n      }\n      return h.scopes.some(s => request.scopes?.includes(s));\n    });\n    const comparer = new HandlersOrderComparer(request);\n    handlers.sort((a, b) => comparer.compare(a, b));\n    const handlerInstances = handlers.map(handlerConfig => {\n      const injectionContext = this._getInjectionContext(request?.$context);\n      return handlerConfig.createHandler(injectionContext);\n    });\n    handlerInstances.forEach(handler => this._checkHandlerInstanceOf(handler));\n    this._joinHandlersInChain(handlerInstances);\n    const result = handlerInstances[0];\n    this._setCacheHandler(request, result);\n    return result;\n  }\n  _joinHandlersInChain(handlers) {\n    for (let index = 0; index < handlers.length - 1; index++) {\n      try {\n        handlers[index].setNext(handlers[index + 1]);\n      } catch (error) {\n        if (error instanceof ɵNextHandlerAlreadySpecifiedException) {\n          throw new Error('Handler factory should return new instance of ' + 'BaseRequestHandler class or its subclass ' + '(next handler should not be specified)');\n        }\n        throw error;\n      }\n    }\n  }\n}\nconst global$2 = window;\n/**\n * @public\n * @class HandlerChainService\n * @classdesc Service to design handlers in chain.\n */\nclass HandlerChainService {\n  get _chain() {\n    return global$2.handlerChain;\n  }\n  set _chain(value) {\n    global$2.handlerChain = value;\n  }\n  static get instance() {\n    return HandlerChainService._instance || (HandlerChainService._instance = new HandlerChainService());\n  }\n  constructor() {\n    if (!this._chain) {\n      this._createGlobalHandlerChain();\n    }\n  }\n  _createGlobalHandlerChain() {\n    this._chain = new InternalHandlerChain();\n  }\n  /**\n   * @internal\n   */\n  clearContextedHandlersCache(contextId) {\n    return this._chain.clearContextedHandlersCache(contextId);\n  }\n  /**\n   * @internal\n   */\n  register(handlerConfig) {\n    return this._chain.handlerChain$.register(handlerConfig);\n  }\n  /**\n   * @description Method to process passed request\n   * @param request - {@link ɵBaseRequest}\n   * @return `Promise<unknown>`\n   */\n  process(request) {\n    return this._chain.handlerChain$.process(request);\n  }\n  /**\n   * @internal\n   * Subscribes to requests.\n   * @param callback A handler function for each request triggered.\n   * @param context (optional) A context in which the requests were triggered.\n   * The `callback` will be called only for requests with specified context.\n   * If not  specified, will be called for all requests.\n   * @returns A function to cancel the subscription.\n   */\n  subscribe(callback, context) {\n    return this._chain.handlerChain$.subscribe(callback, context);\n  }\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction ImplementUsingHandlerChain(config) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (target, method, descriptor) {\n    const methodImplementation = function (...args) {\n      return HandlerChainService.instance.process({\n        type: config?.requestType ? config.requestType : this.requestType,\n        method: config?.methodName ? config.methodName : method,\n        args\n      });\n    };\n    if (descriptor) {\n      descriptor.value = methodImplementation;\n    } else {\n      target[method] = methodImplementation;\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction objectDeepKeys(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return [];\n  }\n  return Object.keys(obj).filter(key => obj[key] instanceof Object).map(key => objectDeepKeys(obj[key]).map(k => [key, ...k])).reduce((x, y) => [...x, ...y], Object.keys(obj).map(x => [x]));\n}\n\n/**\n * @internal\n */\nfunction checkTypeNameFormat(type, element) {\n  const typeParts = type.split('.');\n  if (typeParts.length < 2) {\n    throw new Error(`Error when register ${type}. Type property should have format \"VendorPrefix.${element}\"`);\n  }\n}\n/**\n * @public\n * @description For internal use only.\n */\nfunction ɵcheckTypeNameFormat(type, element) {\n  return checkTypeNameFormat(type, element);\n}\n/**\n * @internal\n */\nfunction checkTypeNamePascalCase(type) {\n  const [vendor, typeName] = type.split('.');\n  const pascalTypeName = toPascalCase(typeName);\n  if (!vendor || pascalTypeName !== typeName) {\n    throw new Error(`Error when register ${type}. Type property should have Pascal case, e.g. ${vendor + '.' + pascalTypeName}. ` + 'The first letter of each word in a compound word should be capitalized');\n  }\n}\n/**\n * @internal\n */\nfunction checkCrtTypeNamePascalCase(type) {\n  const [vendor, typeName] = type.split('.');\n  const pascalTypeName = toPascalCase(typeName);\n  if (vendor.toLowerCase() === 'crt' && pascalTypeName !== typeName) {\n    throw new Error(`Error when register ${type}. Type property should have Pascal case, e.g. ${vendor + '.' + pascalTypeName}. ` + 'The first letter of each word in a compound word should be capitalized');\n  }\n}\n/**\n * @internal\n */\nfunction toPascalCase(source) {\n  return upperFirst(camelCase(source));\n}\n/**\n * @internal\n */\nfunction checkIfTypeRegistered(type, item) {\n  if (!item) {\n    throw new Error(`Error when resolve ${type}. Type was not registered.`);\n  }\n}\n/**\n * @internal\n */\nfunction checkOnlyOneRegistration(type, item, map) {\n  if (map.has(type) && !isEqual(map.get(type), item)) {\n    throw new Error(`Error when register ${type}. Element with this type has already exist`);\n  }\n}\n\n/**\n * @internal\n * @hostPublicApi available through window.creatio.requestHandlerRegistry\n */\nclass InternalRequestHandlerRegistryType {\n  /**\n   * @publicHostApi\n   */\n  static get requestHandlersMap() {\n    return this._requestHandlersMap;\n  }\n  /**\n   * @publicHostApi\n   */\n  static onAddRequestHandler(handler) {\n    this._addItemListeners.push(handler);\n    return () => {\n      this._addItemListeners.splice(this._addItemListeners.indexOf(handler), 1);\n    };\n  }\n  /**\n   * @publicHostApi\n   */\n  static onRemoveRequestHandler(handler) {\n    this._removeItemListeners.push(handler);\n    return () => {\n      this._removeItemListeners.splice(this._removeItemListeners.indexOf(handler), 1);\n    };\n  }\n  /**\n   * @publicHostApi\n   */\n  static addRequestHandler(handlerType, config) {\n    if (!this._requestHandlersMap.has(handlerType)) {\n      this._requestHandlersMap.set(handlerType, config);\n      for (const listener of this._addItemListeners) {\n        listener(handlerType, config);\n      }\n    }\n  }\n  /**\n   * @publicHostApi\n   */\n  static removeRequestHandler(handlerType) {\n    const config = this._requestHandlersMap.get(handlerType);\n    if (config) {\n      this._requestHandlersMap.delete(handlerType);\n      for (const listener of this._removeItemListeners) {\n        listener(handlerType, config);\n      }\n    }\n  }\n}\nInternalRequestHandlerRegistryType._addItemListeners = [];\nInternalRequestHandlerRegistryType._removeItemListeners = [];\nInternalRequestHandlerRegistryType._requestHandlersMap = new Map();\nconst global$1 = window;\nglobal$1.creatio ?? (global$1.creatio = {});\nif (!global$1.creatio.requestHandlerRegistry) {\n  Object.defineProperty(global$1.creatio, 'requestHandlerRegistry', {\n    get: () => InternalRequestHandlerRegistryType,\n    configurable: false\n  });\n}\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InternalRequestHandlerRegistry = InternalRequestHandlerRegistryType;\n/**\n * @internal\n */\nclass RequestHandlerRegistryService {\n  /**\n   * Register request handler class.\n   * @param config Request handler registration config.\n   * @param type Request handler type.\n   */\n  static register(config, type) {\n    const requestType = config.requestType;\n    const requestHandlerType = config.type;\n    if (!requestType) {\n      throw new Error(`Error when register ${requestHandlerType}. Request type not specified.`);\n    }\n    const requestHandlerMapValue = {\n      instanceType: type,\n      instanceConfig: config\n    };\n    RequestHandlerRegistryService._internalRegistry.addRequestHandler(requestHandlerType, requestHandlerMapValue);\n  }\n}\nRequestHandlerRegistryService._internalRegistry = global$1.creatio.requestHandlerRegistry;\n\n/**\n * @internal\n */\nclass RequestRegistryService {\n  static get requestsRegistrationInfos() {\n    return this._requestsRegistrationInfos;\n  }\n  /**\n   * Registers a specified request class.\n   * @param config Request registration config.\n   * @param type Request type.\n   */\n  static register(config, type) {\n    const requestType = config.type;\n    // TODO RND-21723\n    RequestRegistryService._requestsMap.set(requestType, type);\n    RequestRegistryService._requestsRegistrationInfos.set(requestType, config);\n  }\n  /**\n   * Creates request instance by specified registered request type.\n   * @param type Request type.\n   * @returns The instance of registered request.\n   */\n  static get(type) {\n    const requestInstanceConstructor = RequestRegistryService._requestsMap.get(type);\n    checkIfTypeRegistered(type, requestInstanceConstructor);\n    return requestInstanceConstructor && new requestInstanceConstructor();\n  }\n}\nRequestRegistryService._requestsMap = new Map();\nRequestRegistryService._requestsRegistrationInfos = new Map();\n\n/**\n * @internal\n * @hostPublicApi available through window.creatio.registry.ConverterRegistry\n */\nlet ConverterRegistry = /*#__PURE__*/(() => {\n  class ConverterRegistry extends ɵBaseRegistry {\n    static get(type) {\n      if (!this.store.typeInfos.has(type)) {\n        throw new Error(`'${type}' converter doesn't exist`);\n      }\n      return this.store.typeInfos.get(type);\n    }\n    static register(item) {\n      checkTypeNameFormat(item.type, 'ConverterTypeName');\n      checkCrtTypeNamePascalCase(item.type);\n      // TODO RND-21723\n      this.store.typeInfos.set(item.type, item);\n    }\n    static clear() {\n      this.store.typeInfos.clear();\n    }\n  }\n  ConverterRegistry.registryKey = 'ConverterRegistry';\n\n  /**\n   * @internal\n   */\n  return ConverterRegistry;\n})();\nconst viewElementRegistryKey = 'ViewElementRegistry';\n/**\n * @internal\n * @hostPublicApi available through window.creatio.registry.ValidatorRegistry\n */\nlet ViewElementRegistry = /*#__PURE__*/(() => {\n  class ViewElementRegistry extends ɵBaseRegistry {\n    static validate(config) {\n      checkTypeNameFormat(config.type, 'ViewElementTypeName');\n      checkOnlyOneRegistration(config.type, config, ViewElementRegistry.viewElements);\n    }\n    static get viewElements() {\n      return this.store.typeInfos;\n    }\n    static register(config) {\n      this.viewElements.set(config.type, config);\n    }\n    static getFormControlRelatesAttribute(type) {\n      const config = this.store.typeInfos.get(type);\n      return config && 'formControlConfig' in config && config.formControlConfig?.relatesTo || null;\n    }\n  }\n  ViewElementRegistry.registryKey = viewElementRegistryKey;\n\n  /**\n   * @internal\n   */\n  return ViewElementRegistry;\n})();\nconst interfaceDesignerItemRegistryKey = 'InterfaceDesignerItemRegistry';\n/**\n * @internal\n * @hostPublicApi available through window.creatio.registry.InterfaceDesignerItemRegistry\n */\nlet InterfaceDesignerItemRegistry = /*#__PURE__*/(() => {\n  class InterfaceDesignerItemRegistry extends ɵBaseRegistry {\n    static validate(config) {\n      checkTypeNameFormat(config.type, 'InterfaceDesignerItemTypeName');\n      checkCrtTypeNamePascalCase(config.type);\n      checkOnlyOneRegistration(config.type, config, this.interfaceDesignerItemRegistrationInfos);\n    }\n    static register(config) {\n      this.interfaceDesignerItemRegistrationInfos.set(config.type, config);\n    }\n    static get interfaceDesignerItemRegistrationInfos() {\n      return this.store.typeInfos;\n    }\n    static get(type) {\n      return this.interfaceDesignerItemRegistrationInfos.get(type);\n    }\n  }\n  InterfaceDesignerItemRegistry.registryKey = interfaceDesignerItemRegistryKey;\n  return InterfaceDesignerItemRegistry;\n})();\nconst global = window;\n/**\n * @internal\n */\nclass BootstrapNotifier {\n  static get instance() {\n    if (!global.__crtModuleBootstrapNotifier) {\n      global.__crtModuleBootstrapNotifier = new BootstrapNotifier();\n    }\n    return global.__crtModuleBootstrapNotifier;\n  }\n  constructor() {\n    this._subscribers = new Set();\n    // private constructor prevent instantiation via 'new' keyword\n  }\n\n  notify(moduleType) {\n    for (const subscriber of this._subscribers.values()) {\n      subscriber(moduleType);\n    }\n  }\n  subscribe(subscriber) {\n    this._subscribers.add(subscriber);\n    return {\n      unsubscribe: () => this._subscribers.delete(subscriber)\n    };\n  }\n}\n\n/**\n * @internal\n */\nlet HandlerChainServicesRegistry = /*#__PURE__*/(() => {\n  class HandlerChainServicesRegistry extends ɵBaseRegistry {\n    static validate({\n      requestType\n    }) {\n      checkTypeNameFormat(requestType, this.registryKey);\n      checkCrtTypeNamePascalCase(requestType);\n      this.checkUniqueRequestType(requestType);\n    }\n    static checkUniqueRequestType(requestType) {\n      if (this.services.get(requestType)) {\n        throw new Error(`${requestType} already registered`);\n      }\n    }\n    static register(config) {\n      this.validate(config);\n      this.services.set(config.requestType, config);\n    }\n    static get services() {\n      return this.store.typeInfos;\n    }\n  }\n  HandlerChainServicesRegistry.registryKey = 'HandlerChainServicesRegistry';\n\n  /**\n   * @internal\n   */\n  return HandlerChainServicesRegistry;\n})();\nconst designTimeViewElementRegistryKey = 'DesignTimeViewElementRegistry';\n/**\n * @internal\n * @hostPublicApi available through window.creatio.registry.DesignTimeViewElementRegistry\n */\nlet DesignTimeViewElementRegistry = /*#__PURE__*/(() => {\n  class DesignTimeViewElementRegistry extends ɵBaseRegistry {\n    static validate(config) {\n      checkTypeNameFormat(config.type, 'DesignTimeViewElementRegistryItemTypeName');\n      checkCrtTypeNamePascalCase(config.type);\n      checkOnlyOneRegistration(config.type, config, this.infos);\n    }\n    static register(config) {\n      this.infos.set(config.type, config);\n    }\n    static getByOverriddenType(type) {\n      const item = Array.from(this.infos).find(([_, info]) => info.overrideType === type);\n      if (item) {\n        return item[1];\n      }\n      return null;\n    }\n    static get infos() {\n      return this.store.typeInfos;\n    }\n  }\n  DesignTimeViewElementRegistry.registryKey = designTimeViewElementRegistryKey;\n\n  /**\n   * @internal\n   */\n  return DesignTimeViewElementRegistry;\n})();\nclass ValidatorMapValue {}\n/**\n * @internal\n */\nconst validatorRegistryKey = 'ValidatorRegistry';\n/**\n * @internal\n * @hostPublicApi available through window.creatio.registry.ValidatorRegistry\n */\nlet ValidatorRegistry = /*#__PURE__*/(() => {\n  class ValidatorRegistry extends ɵBaseRegistry {\n    static _has(configType, type) {\n      return ValidatorRegistry.items.has(configType) && ValidatorRegistry.items.get(configType)?.typeRef !== type;\n    }\n    static validate(config) {\n      checkTypeNameFormat(config.type, 'ValidatorTypeName');\n      if (ValidatorRegistry._has(config.type, config.typeRef)) {\n        throw new Error(`Error when register ${config.type}. Element with this type has already exist`);\n      }\n    }\n    static get items() {\n      return this.store.typeInfos;\n    }\n    static register(config) {\n      this.items.set(config.type, config);\n    }\n  }\n  ValidatorRegistry.registryKey = validatorRegistryKey;\n\n  /**\n   * @internal\n   * @dontChange\n   */\n  return ValidatorRegistry;\n})();\nlet RemoteEntriesRegistry = /*#__PURE__*/(() => {\n  class RemoteEntriesRegistry extends ɵBaseRegistry {\n    /**\n     * @dontChange\n     */\n    static get items() {\n      return this.store.typeInfos;\n    }\n  }\n  /**\n   * @dontChange\n   */\n  RemoteEntriesRegistry.registryKey = 'remotes';\n\n  /**\n   * @internal\n   */\n  return RemoteEntriesRegistry;\n})();\nfunction isComponentPropertyBindable(viewConfigType, componentProperty) {\n  const componentConfig = ViewElementRegistry.viewElements.get(viewConfigType);\n  if (!componentConfig?.inputs) {\n    return false;\n  }\n  return !!componentConfig?.inputs[componentProperty]?.propertyBindable;\n}\nconst moduleMetadataKey = 'module';\nconst viewElementMetadataKey = 'viewElement';\nconst interfaceDesignerItemMetadataKey = 'interfaceDesignerItem';\nconst requestHandlerMetadataKey = 'requestHandler';\nconst designTimeViewElementMetadataKey = 'designTimeViewElement';\nconst validatorMetadataKey = 'validator';\nconst converterMetadataKey = 'converter';\n/**\n * @internal\n */\nfunction setModuleMetadata(metadata, type) {\n  Reflect.defineMetadata(moduleMetadataKey, metadata, type);\n}\n/**\n * @internal\n */\nfunction getModuleMetadata(type) {\n  const metadata = Reflect.getMetadata(moduleMetadataKey, type);\n  if (!metadata) {\n    throw new Error(`Module metadata was not found on '${type.name}' class`);\n  }\n  return metadata;\n}\n/**\n * @internal\n */\nfunction setViewElementMetadata(metadata, type) {\n  Reflect.defineMetadata(viewElementMetadataKey, metadata, type);\n}\n/**\n * @internal\n */\nfunction getViewElementMetadata(type) {\n  const metadata = Reflect.getMetadata(viewElementMetadataKey, type);\n  if (!metadata) {\n    throw new Error(`View element metadata was not found on '${type.name}' class`);\n  }\n  return metadata;\n}\n/**\n * @internal\n */\nfunction setValidatorMetadata(metadata, type) {\n  Reflect.defineMetadata(validatorMetadataKey, metadata, type);\n}\n/**\n * @internal\n */\nfunction getValidatorMetadata(type) {\n  const metadata = Reflect.getOwnMetadata(validatorMetadataKey, type);\n  if (!metadata) {\n    throw new Error(`Validator metadata was not found on '${type.name}' class`);\n  }\n  return metadata;\n}\n/**\n * @internal\n */\nfunction setConverterMetadata(metadata, type) {\n  Reflect.defineMetadata(converterMetadataKey, metadata, type);\n}\n/**\n * @internal\n */\nfunction getConverterMetadata(type) {\n  const metadata = Reflect.getOwnMetadata(converterMetadataKey, type);\n  if (!metadata) {\n    throw new Error(`Converter metadata was not found on '${type.name}' class`);\n  }\n  return metadata;\n}\n/**\n * @internal\n */\nfunction setInterfaceDesignerItemMetadata(metadata, type) {\n  Reflect.defineMetadata(interfaceDesignerItemMetadataKey, metadata, type);\n}\n/**\n * @internal\n */\nfunction getInterfaceDesignerItemMetadata(type) {\n  const metadata = Reflect.getOwnMetadata(interfaceDesignerItemMetadataKey, type);\n  if (!metadata) {\n    throw new Error(`Interface designer item metadata was not found on '${type.name}' class`);\n  }\n  return metadata;\n}\n/**\n * @internal\n */\nfunction setDesignTimeViewElementMetadata(metadata, type) {\n  Reflect.defineMetadata(designTimeViewElementMetadataKey, metadata, type);\n}\n/**\n * @internal\n */\nfunction getDesignTimeViewElementMetadata(type) {\n  const metadata = Reflect.getOwnMetadata(designTimeViewElementMetadataKey, type);\n  if (!metadata) {\n    throw new Error(`Design time view element metadata was not found on '${type.name}' class`);\n  }\n  return metadata;\n}\n/**\n * @internal\n */\nfunction hasInterfaceDesignerItemMetadata(type) {\n  return Reflect.hasOwnMetadata(interfaceDesignerItemMetadataKey, type);\n}\n/**\n * @internal\n */\nfunction setRequestHandlerMetadata(metadata, type) {\n  Reflect.defineMetadata(requestHandlerMetadataKey, metadata, type);\n}\n/**\n * @internal\n */\nfunction getRequestHandlerMetadata(type) {\n  const metadata = Reflect.getMetadata(requestHandlerMetadataKey, type);\n  if (!metadata) {\n    throw new Error(`Request handler metadata was not found on '${type.name}' class`);\n  }\n  return metadata;\n}\n/**\n * @internal\n */\nfunction getHandlerChainServiceMetadata(typeRef) {\n  const requestType = Reflect.getMetadata('requestType', typeRef);\n  if (!requestType) {\n    throw new Error(`requestType was not found on '${typeRef.name}' class`);\n  }\n  return {\n    requestType,\n    typeRef\n  };\n}\n/**\n * @internal\n */\nfunction getCrtInputsMetadata(type) {\n  const keys = Reflect.getMetadataKeys(type);\n  const crtInputKeys = keys.filter(x => x.startsWith(crtInputPrefix));\n  return Object.fromEntries(crtInputKeys.map(key => {\n    const data = Reflect.getMetadata(key, type);\n    return [key.replace(crtInputPrefix, ''), data];\n  }));\n}\n/**\n * @internal\n */\nfunction getCrtOutputsMetadata(type) {\n  const keys = Reflect.getMetadataKeys(type);\n  const crtOutputKeys = keys.filter(x => x.startsWith(crtOutputPrefix));\n  return Object.fromEntries(crtOutputKeys.map(key => {\n    const data = Reflect.getMetadata(key, type);\n    return [key.replace(crtOutputPrefix, ''), data];\n  }));\n}\n/**\n * @internal\n */\nfunction getCrtValidationInputsMetadata(type) {\n  const keys = Reflect.getMetadataKeys(type);\n  const crtValidationInputKeys = keys.filter(x => x.startsWith(crtValidationInputPrefix));\n  return Object.fromEntries(crtValidationInputKeys.map(key => {\n    const data = Reflect.getMetadata(key, type);\n    return [key.replace(crtValidationInputPrefix, ''), data];\n  }));\n}\n/**\n * @internal\n */\nfunction getCrtInjectMetadata(type) {\n  const keys = Reflect.getOwnMetadataKeys(type);\n  const crtInjectKeys = keys.filter(x => x.startsWith(crtInjectPrefix));\n  return Object.fromEntries(crtInjectKeys.map(key => {\n    const index = Number(key.replace(crtInjectPrefix, ''));\n    const data = Reflect.getMetadata(key, type);\n    return [index, data];\n  }));\n}\n/**\n * @internal\n */\nfunction getParentType(type) {\n  const parentProto = type.prototype ? Object.getPrototypeOf(type.prototype) : null;\n  return parentProto ? parentProto.constructor : null;\n}\n/**\n * @internal\n */\nfunction getTypeDependencies(type) {\n  const paramTypes = Reflect.getOwnMetadata('design:paramtypes', type);\n  if (!paramTypes) {\n    if (type.length > 0) {\n      throw new Error(`Dependency Injection error. Cannot read dependencies of class '${type.name}'. ` + `Please make sure class '${type.name}' has decorator and ` + \"'emitDecoratorMetadata' option is enabled in your 'tsconfig.json' file.\");\n    }\n    const parentType = getParentType(type);\n    return parentType && parentType !== Object ? getTypeDependencies(parentType) : [];\n  }\n  const crtInjectMetadata = getCrtInjectMetadata(type);\n  Object.entries(crtInjectMetadata).forEach(([index, token]) => paramTypes[index] = token);\n  return paramTypes;\n}\n\n/**\n * @internal\n */\nfunction instantiate(type, resolveDependency) {\n  const deps = getTypeDependencies(type);\n  if (deps.length > 0) {\n    if (!resolveDependency) {\n      throw new Error(`Cannot resolve dependencies for ${type.name}. ` + \"Please provide 'resolveDependency' bootstrap option\");\n    }\n    const depInstances = deps.map(resolveDependency);\n    return new type(...depInstances);\n  }\n  return new type();\n}\n/**\n * @public\n * @description For internal use only.\n */\nfunction ɵinstantiate(type, resolveDependency) {\n  return instantiate(type, resolveDependency);\n}\n\n/**\n * @public\n */\nclass CrtInputRegistrationConfig {}\n\n/**\n * @public\n * @class DataRequest\n * @description Definition of data source request.\n * @extends {ɵBaseRequest} {@link ɵBaseRequest}\n * @property {string} dataSourceName - name of assigned data source.\n */\nclass DataRequest extends ɵBaseRequest {}\n\n/**\n * @public\n * @description Request payload\n * @property {string} request - request name.\n * @property {unknown} params - request parameters.\n */\n\n/**\n * @internal\n */\nvar ViewElementReuseStrategy = /*#__PURE__*/(() => {\n  (function (ViewElementReuseStrategy) {\n    /**\n     * Reuse early created view element when it state changed\n     */\n    ViewElementReuseStrategy[ViewElementReuseStrategy[\"Reuse\"] = 0] = \"Reuse\";\n    /**\n     * Rerender(recreate) view element when it state changed\n     */\n    ViewElementReuseStrategy[ViewElementReuseStrategy[\"Rerender\"] = 1] = \"Rerender\";\n  })(ViewElementReuseStrategy || (ViewElementReuseStrategy = {}));\n  return ViewElementReuseStrategy;\n})();\n/**\n * @public\n * @description Abstract Base Validator class for designing custom validators.\n * @example\n * @CrtValidator({\n *    type: 'crt.Required',\n * })\n * export class RequiredValidator extends BaseValidator {\n *    protected override async = false;\n *    public validate(controlState: CrtControlState, params?: ValidatorParametersValues): CrtValidationErrors | null {\n *      Implementation here...\n *    }\n * }\n */\nlet BaseValidator = /*#__PURE__*/(() => {\n  class BaseValidator {\n    /**\n     * @description getter for async/sync indicator\n     */\n    get isAsync() {\n      return this.async;\n    }\n    /**\n     * @description Function used for validation\n     */\n    get validateFn() {\n      return this.validate.bind(this);\n    }\n    /**\n     * @internal\n     */\n    static [Symbol.hasInstance](instance) {\n      return instance?.constructor?.['_instanceOfKey'] === BaseValidator._instanceOfKey;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  BaseValidator._instanceOfKey = 'devkit_BaseValidator';\n\n  /**\n   * @public\n   */\n  return BaseValidator;\n})();\nlet LocalizableValue = /*#__PURE__*/(() => {\n  class LocalizableValue {\n    constructor(key) {\n      this.key = key;\n    }\n    /**\n     * @internal\n     */\n    static [Symbol.hasInstance](instance) {\n      return instance?.constructor?.['_instanceOfKey'] === LocalizableValue._instanceOfKey;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  LocalizableValue._instanceOfKey = 'devkit_LocalizableValue';\n\n  /**\n   * @internal\n   */\n  return LocalizableValue;\n})();\nfunction applyLocalizeMetadataFn(obj, localizeMetadata) {\n  const localizableEntries = objectDeepKeys(obj).map(path => ({\n    path,\n    value: get(obj, path)\n  })).filter(({\n    value\n  }) => value instanceof LocalizableValue);\n  if (localizableEntries.length === 0) {\n    return obj;\n  }\n  const localized = cloneDeep(obj);\n  if (!localizeMetadata) {\n    console.error(\"Unable to localize metadata. 'localizeMetadata' bootstrap option was not provided.\");\n  }\n  localizableEntries.forEach(({\n    path,\n    value\n  }) => {\n    const localizedValue = localizeMetadata?.(value.key) ?? value.key;\n    set(localized, path, localizedValue);\n  });\n  return localized;\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtDesignTimeViewElement(config) {\n  return function (type) {\n    const registrationConfig = {\n      ...config,\n      typeRef: type\n    };\n    setDesignTimeViewElementMetadata(registrationConfig, type);\n  };\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtRequest(config) {\n  return function (type) {\n    checkTypeNameFormat(config.type, 'RequestTypeName');\n    checkCrtTypeNamePascalCase(config.type);\n    RequestRegistryService.register(config, type);\n  };\n}\n\n/**\n * @internal\n * @hostPublicApi\n */\nclass InterfaceDesignerItemRegistrationConfig {}\n\n/**\n * @internal\n * @class MethodInvokeRequest\n * @description Definition of invoke method request.\n * @extends {ɵBaseRequest} {@link ɵBaseRequest}\n * @property {string} method - method name.\n * @property {unknown[]} args - arguments passing to the method.\n */\nclass MethodInvokeRequest extends ɵBaseRequest {}\n\n/**\n * @internal\n */\nvar RemoteEntryType = /*#__PURE__*/(() => {\n  (function (RemoteEntryType) {\n    RemoteEntryType[\"Script\"] = \"script\";\n    RemoteEntryType[\"Module\"] = \"module\";\n  })(RemoteEntryType || (RemoteEntryType = {}));\n  return RemoteEntryType;\n})();\n/**\n * @public\n * @description Creatio platform interacts with input's of user-defined component through CrtInput decorator.\n * @param config {@link CrtInputRegistrationConfig}\n *\n * @example\n * export class AppComponent {\n *    @CrtInput()\n *    public value!: string;\n *  }\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtInput(config) {\n  return function (target, propertyKey) {\n    if (!config) {\n      config = {\n        propertyBindable: false\n      };\n    }\n    Reflect.defineMetadata(crtInputPrefix + propertyKey.toString(), config, target.constructor);\n  };\n}\n\n/**\n * @public\n * @description User-defined components could notify Creatio platform about changes through CrtOutput decorator.\n * @example\n * export class AppComponent {\n *     @Input()\n *     @CrtOutput()\n *     public valueChange;\n *  }\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtOutput() {\n  return function (target, propertyKey) {\n    Reflect.defineMetadata(crtOutputPrefix + propertyKey.toString(), {}, target.constructor);\n  };\n}\n\n/**\n * @public\n * @description User-defined components receive validationInfo changes through CrtValidationInput decorator.\n * Make sure you have defined input for every validationInfo input.\n * To properly declare validationInfo field:\n * 1. Declare input field inside inputs section. For example `value`\n * 2. In validationInputs section declare same field which ends with ValidationInfo.\n * For previous example `valueValidationInfo`\n *\n * @example\n * export class AppComponent {\n *      @CrtInput()\n        public value;\n *\n *     \t@CrtValidationInput()\n *      public valueValidationInfo;\n *  }\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtValidationInput() {\n  return function (target, propertyKey) {\n    Reflect.defineMetadata(crtValidationInputPrefix + propertyKey.toString(), {}, target.constructor);\n  };\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtViewElement(config) {\n  return function (type) {\n    checkTypeNamePascalCase(config.type);\n    const inputs = getCrtInputsMetadata(type);\n    const outputs = getCrtOutputsMetadata(type);\n    const validationInputs = getCrtValidationInputsMetadata(type);\n    const baseRegistrationConfig = {\n      ...config,\n      inputs,\n      outputs,\n      validationInputs\n    };\n    const registrationConfig = 'selector' in config ? {\n      ...baseRegistrationConfig,\n      selector: config.selector\n    } : {\n      ...baseRegistrationConfig,\n      typeRef: type\n    };\n    setViewElementMetadata(registrationConfig, type);\n  };\n}\n\n/**\n * @public\n * @description CrtModule decorator is a 'container' where user actually setup elements.\n * In could contain viewElements, definitions of other CrtModules.\n * @param moduleDefinition - {@link ModuleDefinition}\n *\n * @example\n *  @CrtModule({\n *      viewElements: [AppComponent],\n *      requestHandlers: [SomeRequestHandler],\n *      validators: [SomeValidator],\n *  })\n *  @NgModule({\n *      declarations: [AppComponent],\n *      imports: [BrowserModule],\n *      providers: [],\n *  })\n *  export class AppModule {}\n */\nfunction CrtModule(moduleDefinition) {\n  return type => setModuleMetadata(moduleDefinition, type);\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtInterfaceDesignerItem(config) {\n  function _applyTypeCaption() {\n    if (!config.typeCaption && config.toolbarConfig) {\n      const toolbarConfig = Array.isArray(config.toolbarConfig) ? config.toolbarConfig[0] : config.toolbarConfig;\n      config.typeCaption = toolbarConfig.caption;\n    }\n  }\n  return function (type) {\n    config.typeRef = type;\n    config.viewElementGroupType ?? (config.viewElementGroupType = ViewElementGroupType.CustomElements);\n    _applyTypeCaption();\n    setInterfaceDesignerItemMetadata(config, type);\n  };\n}\n\n/**\n * @public\n * @description\n * Constructor parameter decorator.\n * Mark parameter as dependency that should be obtained by token.\n * @param token - token by which the dependency instance will be obtained\n * @example\n * class MyHandler {\n * \tconstructor(@CrtInject(USER_NAME_TOKEN) userName: string) {}\n * }\n */\nfunction CrtInject(token) {\n  return function (target, paramKey, paramIndex) {\n    Reflect.defineMetadata(crtInjectPrefix + paramIndex, token, target);\n  };\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtValidator(config) {\n  if (!config) {\n    return type => {\n      // the decorator won't do anything by itself,\n      // but will be used by the compiler to generate class metadata,\n      // which is required for DI\n    };\n  }\n  return function (type) {\n    checkTypeNameFormat(config.type, 'ValidatorTypeName');\n    const registrationConfig = {\n      ...config,\n      typeRef: type\n    };\n    setValidatorMetadata(registrationConfig, type);\n  };\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtRequestHandler(config) {\n  if (!config) {\n    return type => {\n      // the decorator won't do anything by itself,\n      // but will be used by the compiler to generate class metadata,\n      // which is required for DI\n    };\n  }\n  return function (type) {\n    checkTypeNameFormat(config.type, 'RequestHandlerTypeName');\n    checkCrtTypeNamePascalCase(config.type);\n    setRequestHandlerMetadata(config, type);\n  };\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CrtConverter(config) {\n  if (!config) {\n    return type => {};\n  }\n  return function (typeRef) {\n    const type = typeof config === 'string' ? config : config.type;\n    checkTypeNameFormat(type, 'converterTypeName');\n    const registrationConfig = {\n      type: type,\n      typeRef: typeRef\n    };\n    setConverterMetadata(registrationConfig, typeRef);\n  };\n}\n\n/**\n * @internal\n */\nvar DataSourceLoadType = /*#__PURE__*/(() => {\n  (function (DataSourceLoadType) {\n    DataSourceLoadType[\"LoadNext\"] = \"loadNext\";\n    DataSourceLoadType[\"Load\"] = \"load\";\n    DataSourceLoadType[\"Reload\"] = \"reload\";\n  })(DataSourceLoadType || (DataSourceLoadType = {}));\n  return DataSourceLoadType;\n})();\n/**\n * @public\n * @description Function allows to register user-defined component as view element in Creatio platform.\n * @param config - registration config. {@link ViewElementRegistrationConfig}\n * @example\n * sdk.registerViewElement({\n *      type: 'usr.Timeline',\n *      selector: 'usr-timeline',\n *      inputs: {\n *          primaryColumnValue: {},\n *          cardSchemaName: {},\n *          entitySchemaName: {}\n *      }\n * });\n */\nfunction registerViewElement(config) {\n  ViewElementRegistry.validate(config);\n  ViewElementRegistry.register(config);\n}\n\n/**\n * @internal\n * @description Function allows to register angular component as view element in Creatio platform.\n */\nfunction registerAngularViewElement(config, typeRef) {\n  ViewElementRegistry.validate(config);\n  ViewElementRegistry.register({\n    ...config,\n    typeRef\n  });\n}\nfunction checkRemoteName(remoteName) {\n  if (!RemoteEntriesRegistry.items.has(remoteName)) {\n    throw new Error(`Remote entry with name '${remoteName}' does not exist`);\n  }\n}\n/**\n * @internal\n */\nfunction resistantForEach(items, callback) {\n  items.forEach(item => {\n    try {\n      callback(item);\n    } catch (error) {\n      console.error(error);\n    }\n  });\n}\n/**\n * @internal\n */\nfunction registerViewElements(types) {\n  resistantForEach(types, type => {\n    const registrationConfig = getViewElementMetadata(type);\n    ViewElementRegistry.validate(registrationConfig);\n    ViewElementRegistry.register(registrationConfig);\n  });\n}\n/**\n * @internal\n */\nfunction registerInterfaceDesignerItems(types, localizeFn) {\n  resistantForEach(types, type => {\n    if (!hasInterfaceDesignerItemMetadata(type)) {\n      return;\n    }\n    let config = getInterfaceDesignerItemMetadata(type);\n    config = applyLocalizeMetadataFn(config, localizeFn);\n    const viewElementMetadata = getViewElementMetadata(type);\n    config.type = viewElementMetadata.type;\n    InterfaceDesignerItemRegistry.validate(config);\n    InterfaceDesignerItemRegistry.register(config);\n  });\n}\n/**\n * @internal\n */\nfunction registerDesignTimeViewElements(types) {\n  resistantForEach(types, type => {\n    const registrationConfig = getDesignTimeViewElementMetadata(type);\n    DesignTimeViewElementRegistry.validate(registrationConfig);\n    DesignTimeViewElementRegistry.register(registrationConfig);\n  });\n}\n/**\n * @internal\n */\nfunction registerValidators(types, options) {\n  resistantForEach(types, type => {\n    const metadata = getValidatorMetadata(type);\n    const registrationConfig = {\n      ...metadata,\n      instantiate: function (injectionContext) {\n        const resolveDependency = options?.resolveDependency ? token => options.resolveDependency(token, injectionContext) : null;\n        return instantiate(type, resolveDependency);\n      }\n    };\n    ValidatorRegistry.validate(registrationConfig);\n    ValidatorRegistry.register(registrationConfig);\n  });\n}\n/**\n * @internal\n */\nfunction registerConverters(types, options) {\n  resistantForEach(types, type => {\n    const metadata = getConverterMetadata(type);\n    const registrationConfig = {\n      ...metadata,\n      instantiate: function (injectionContext) {\n        const resolveDependency = options?.resolveDependency ? token => options.resolveDependency(token, injectionContext) : null;\n        return instantiate(type, resolveDependency);\n      }\n    };\n    ConverterRegistry.register(registrationConfig);\n  });\n}\n/**\n * @internal\n */\nfunction registerRequestHandlers(types, options, remoteName) {\n  if (options.moduleType === 'remote' && !remoteName) {\n    console.error(\"To use request handlers, 'remoteName' parameter should be specified.\");\n    return;\n  }\n  resistantForEach(types, type => {\n    const metadata = getRequestHandlerMetadata(type);\n    let registrationConfig;\n    const createHandler = injectionContext => {\n      const resolveDependency = options?.resolveDependency ? token => options.resolveDependency(token, injectionContext) : null;\n      return instantiate(type, resolveDependency);\n    };\n    if (options.moduleType === 'host') {\n      registrationConfig = {\n        ...metadata,\n        source: {\n          type: HandlerSourceType.Host\n        },\n        createHandler\n      };\n    } else {\n      const remote = RemoteEntriesRegistry.items.get(remoteName);\n      registrationConfig = {\n        ...metadata,\n        source: {\n          type: HandlerSourceType.Remote,\n          packageName: remote.packageName\n        },\n        createHandler\n      };\n    }\n    RequestHandlerRegistryService.register(registrationConfig, type);\n  });\n}\nfunction bootstrapDefaultCrtModule(name, type, options) {\n  try {\n    const moduleDefinition = getModuleMetadata(type);\n    if (moduleDefinition.viewElements) {\n      registerViewElements(moduleDefinition.viewElements);\n      registerInterfaceDesignerItems(moduleDefinition.viewElements, options?.localizeMetadata);\n    }\n    if (moduleDefinition.designTimeViewElements) {\n      registerDesignTimeViewElements(moduleDefinition.designTimeViewElements);\n    }\n    if (moduleDefinition.requestHandlers) {\n      registerRequestHandlers(moduleDefinition.requestHandlers, options, name);\n    }\n    if (moduleDefinition.validators) {\n      registerValidators(moduleDefinition.validators, options);\n    }\n    if (moduleDefinition.converters) {\n      registerConverters(moduleDefinition.converters, options);\n    }\n    moduleDefinition.includes?.forEach(t => {\n      bootstrapDefaultCrtModule(name, t, options);\n      bootstrapPredefinedModules(name, t, options);\n    });\n  } catch (error) {\n    console.error(error);\n  }\n}\n/**\n * @internal\n */\nfunction bootstrapPredefinedModules(name, type, options) {\n  const modulePrefix = 'module:';\n  const metadataKeys = Reflect.getOwnMetadataKeys(type);\n  for (const key of metadataKeys) {\n    if (typeof key === 'string' && key.startsWith(modulePrefix)) {\n      const moduleType = key.substring(modulePrefix.length);\n      const predefinedBootstrapper = Reflect.getOwnMetadata('moduleBootstrapper:' + moduleType, type);\n      try {\n        predefinedBootstrapper(name, type, options);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}\n/**\n * @internal\n */\nfunction bootstrapCrtModule(...args) {\n  const name = typeof args[0] === 'string' ? args.shift() : undefined;\n  const type = args[0];\n  const options = args[1] ?? {};\n  options.moduleType ?? (options.moduleType = 'remote');\n  if (name) {\n    if (options.moduleType === 'remote') {\n      checkRemoteName(name);\n    } else {\n      throw new Error('Host module cannot have name');\n    }\n  }\n  bootstrapDefaultCrtModule(name, type, options);\n  bootstrapPredefinedModules(name, type, options);\n  if (options.moduleType === 'remote') {\n    BootstrapNotifier.instance.notify(type);\n  }\n}\n\n/**\n * @public\n * @description Use this function in decorators to indicate that a value should be localized.\n * Note that the \"localizeMetadata\" bootstrap option should be provided,\n * otherwise the value cannot be localized.\n *\n * @example\n *\n * ### Using 'localize' in decorator\n * ```ts\n * @CrtInterfaceDesignerItem({\n *    toolbarConfig: {\n *      caption: localize('MyElement.Caption')\n * \t  }\n * })\n * class MyElement {}\n * ```\n * ### Passing 'localizeMetadata' bootstrap option\n * ```ts\n * bootstrapCrtModule(MyModule, {\n *    localizeMetadata: (key: string) => thirdPartyTranslateService.translate(key)\n * });\n * ```\n */\nfunction localize(key) {\n  return new LocalizableValue(key);\n}\n\n/**\n * @internal\n */\nfunction registerHandlerChainServices(types) {\n  types?.forEach(type => {\n    const registrationConfig = getHandlerChainServiceMetadata(type);\n    HandlerChainServicesRegistry.register(registrationConfig);\n  });\n}\n/**\n * @internal\n */\nfunction _bootstrapCrtModuleHandlerChainServices(type) {\n  const moduleDefinition = getModuleMetadata(type);\n  if (moduleDefinition.handlerChainServices) {\n    registerHandlerChainServices(moduleDefinition.handlerChainServices);\n  }\n  moduleDefinition.includes?.forEach(t => _bootstrapCrtModuleHandlerChainServices(t));\n}\n/**\n * @internal\n */\nfunction bootstrapCrtModuleHandlerChainServices(type) {\n  _bootstrapCrtModuleHandlerChainServices(type);\n}\n\n/**\n * @public\n * @abstract\n * @classdesc Class for designing request handlers.\n */\nlet BaseRequestHandler = /*#__PURE__*/(() => {\n  class BaseRequestHandler {\n    constructor() {\n      this.handlerChain = HandlerChainService.instance;\n    }\n    get next() {\n      return this._next;\n    }\n    /**\n     * @internal\n     */\n    static [Symbol.hasInstance](instance) {\n      return instance?.constructor?.['_instanceOfKey'] === BaseRequestHandler._instanceOfKey;\n    }\n    /**\n     * @description Method to set request handler to handler chain.\n     * @param next - link for next request handler - {@link ɵRequestHandler}\n     */\n    setNext(next) {\n      if (this._next) {\n        throw new ɵNextHandlerAlreadySpecifiedException();\n      }\n      this._next = next;\n    }\n  }\n  /**\n   * @internal\n   * @dontChange\n   */\n  BaseRequestHandler._instanceOfKey = 'devkit_BaseRequestHandler';\n  return BaseRequestHandler;\n})();\nclass BaseHandlerChainService {}\n\n/**\n * @public\n * @classdesc Service to working with Creatio platform features using handler chain\n * @extends {BaseHandlerChainService}\n */\nlet FeatureService = /*#__PURE__*/(() => {\n  class FeatureService extends BaseHandlerChainService {\n    constructor() {\n      super(...arguments);\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.FeatureService';\n    }\n  }\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], FeatureService.prototype, \"getFeatureState\", void 0);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], FeatureService.prototype, \"getFeaturesState\", void 0);\n\n  /**\n   * @public\n   * @classdesc Service to working rights using handler chain\n   * @extends {BaseHandlerChainService}\n   */\n  return FeatureService;\n})();\nlet RightsService = /*#__PURE__*/(() => {\n  class RightsService extends BaseHandlerChainService {\n    constructor() {\n      super(...arguments);\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.RightsService';\n    }\n  }\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], RightsService.prototype, \"getCanExecuteOperation\", void 0);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], RightsService.prototype, \"getCanExecuteOperations\", void 0);\n\n  /**\n   * @public\n   * @class SysSettingsService\n   * @classdesc Service to working with system settings using handler chain\n   * @extends {BaseHandlerChainService}\n   */\n  // TODO RND-45286 (implement BaseSysSettingsService)\n  return RightsService;\n})();\nlet SysSettingsService = /*#__PURE__*/(() => {\n  class SysSettingsService extends BaseHandlerChainService {\n    constructor() {\n      super(...arguments);\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.SysSettingsService';\n    }\n  }\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], SysSettingsService.prototype, \"getByCodes\", void 0);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], SysSettingsService.prototype, \"getByCode\", void 0);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], SysSettingsService.prototype, \"update\", void 0);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], SysSettingsService.prototype, \"updateMany\", void 0);\n\n  /**\n   * @public\n   * @class SysSetting\n   * @classdesc Class contains info related system setting\n   * @property {ɵGuid} id - id of system setting.\n   * @property {string} name - name of system setting.\n   * @property {string} code - code of system setting.\n   * @property {isCacheable} boolean - indicator whether system setting is cacheable\n   * @property {any} value - value of system setting\n   * @property {string} displayValue - display value of system setting\n   * @property {ɵDataValueType} ɵDataValueType - system setting {@link ɵDataValueType}\n   */\n  return SysSettingsService;\n})();\nclass SysSetting {}\n/**\n * @public\n * @class SysSettingValue\n * @classdesc Shape to describe system setting value\n * @property {string} code - code of system setting\n * @property {any} value - value of system setting\n */\nclass SysSettingValue {}\n\n/**\n * @public\n * @classdesc\n * @class SysValuesService  Service to working with system values using handler chain\n * @extends {BaseHandlerChainService}\n */\nlet SysValuesService = /*#__PURE__*/(() => {\n  class SysValuesService extends BaseHandlerChainService {\n    constructor() {\n      super(...arguments);\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.SysValuesService';\n    }\n  }\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], SysValuesService.prototype, \"loadSysValues\", void 0);\n\n  /**\n   * @public\n   * @classdesc Http service to perform Http requests\n   * @extends {BaseHandlerChainService}\n   */\n  return SysValuesService;\n})();\nlet HttpClientService = /*#__PURE__*/(() => {\n  class HttpClientService extends BaseHandlerChainService {\n    constructor() {\n      super(...arguments);\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.HttpClientService';\n    }\n    /**\n     * @description HTTP GET request.\n     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}\n     */\n    get() {\n      // the method will be implemented dynamically by the decorator\n    }\n    /**\n     * @description HTTP POST request.\n     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}\n     */\n    post() {\n      // the method will be implemented dynamically by the decorator\n    }\n    /**\n     * @description HTTP DELETE request.\n     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}\n     */\n    delete() {\n      // the method will be implemented dynamically by the decorator\n    }\n    /**\n     * @description HTTP PUT request.\n     * @return `Promise<HttpResponse> | void``  {(Promise<HttpResponse> | void)}\n     */\n    put() {\n      // the method will be implemented dynamically by the decorator\n    }\n    /**\n     * @description HTTP PATCH request.\n     * @return `Promise<HttpResponse> | void`  {(Promise<HttpResponse> | void)}\n     */\n    patch() {\n      // the method will be implemented dynamically by the decorator\n    }\n  }\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Object)], HttpClientService.prototype, \"get\", null);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Object)], HttpClientService.prototype, \"post\", null);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Object)], HttpClientService.prototype, \"delete\", null);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Object)], HttpClientService.prototype, \"put\", null);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Object)], HttpClientService.prototype, \"patch\", null);\n\n  /**\n   * @internal\n   */\n  return HttpClientService;\n})();\nvar SchemaViewMaskRequestAction = /*#__PURE__*/(() => {\n  (function (SchemaViewMaskRequestAction) {\n    SchemaViewMaskRequestAction[\"AddTask\"] = \"addTask\";\n    SchemaViewMaskRequestAction[\"RemoveTask\"] = \"removeTask\";\n  })(SchemaViewMaskRequestAction || (SchemaViewMaskRequestAction = {}));\n  return SchemaViewMaskRequestAction;\n})();\n/**\n * @internal\n */\nclass SchemaViewMaskRequest extends ɵBaseRequest {\n  constructor(action, taskName, $context) {\n    super();\n    this.action = action;\n    this.taskName = taskName;\n    this.$context = $context;\n    this.type = 'crt.SchemaViewMaskRequest';\n  }\n}\n\n/**\n * @public\n * @classdesc Service to working with mask using handler chain\n * @extends {BaseHandlerChainService}\n */\nlet MaskService = /*#__PURE__*/(() => {\n  class MaskService extends BaseHandlerChainService {\n    constructor() {\n      super(...arguments);\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.MaskService';\n    }\n    /**\n     * @internal\n     * @param taskName\n     * @param context\n     */\n    showMask(taskName, context) {\n      return _asyncToGenerator(function* () {\n        const request = new SchemaViewMaskRequest(SchemaViewMaskRequestAction.AddTask, taskName, context);\n        yield HandlerChainService.instance.process(request);\n      })();\n    }\n    /**\n     * @internal\n     * @param taskName\n     * @param context\n     */\n    hideMask(taskName, context) {\n      return _asyncToGenerator(function* () {\n        const request = new SchemaViewMaskRequest(SchemaViewMaskRequestAction.RemoveTask, taskName, context);\n        yield HandlerChainService.instance.process(request);\n      })();\n    }\n  }\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], MaskService.prototype, \"showBodyMask\", void 0);\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], MaskService.prototype, \"hideBodyMask\", void 0);\n\n  /**\n   * @internal\n   */\n  return MaskService;\n})();\nconst _from = Symbol('CreateModelFrom');\n/**\n * @public\n */\nlet Model = /*#__PURE__*/(() => {\n  class Model extends BaseHandlerChainService {\n    constructor(crtModel) {\n      super();\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.ModelGenerator';\n      this._crtModel = crtModel;\n    }\n    static get instance() {\n      if (!this._instance) {\n        this._instance = new Model();\n      }\n      return this._instance;\n    }\n    /**\n     * @internal\n     * Gets the model name.\n     */\n    get name() {\n      return this._crtModel?.name;\n    }\n    /**\n     * @internal\n     */\n    static [_from](crtModel) {\n      return new Model(crtModel);\n    }\n    static create(dataSchema) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const crtModel = yield _this2.instance._create({\n          type: 'crt.EntityDataSource',\n          config: {\n            entitySchemaName: dataSchema\n          }\n        }, '');\n        return new Model(crtModel);\n      })();\n    }\n    getSchema() {\n      return this._crtModel._getAsyncResult(this._crtModel.getSchema());\n    }\n    load(config) {\n      return this._crtModel._getAsyncResult(this._crtModel.load(config));\n    }\n    insert(dto) {\n      return this._crtModel._getAsyncResult(this._crtModel.insert(dto));\n    }\n    update(dto, parameters) {\n      return this._crtModel._getAsyncResult(this._crtModel.update(dto, parameters));\n    }\n    copy(primaryColumnValue, data = {}) {\n      return this._crtModel._getAsyncResult(this._crtModel.copy(primaryColumnValue, data));\n    }\n    create(data = {}) {\n      return this._crtModel._getAsyncResult(this._crtModel.create(data));\n    }\n    delete(parameters) {\n      return this._crtModel._getAsyncResult(this._crtModel.delete(parameters));\n    }\n    canSave(params) {\n      return this._crtModel._getAsyncResult(this._crtModel.canSave(params));\n    }\n    canDelete(params) {\n      return this._crtModel._getAsyncResult(this._crtModel.canDelete(params));\n    }\n  }\n  __decorate([ImplementUsingHandlerChain({\n    methodName: 'generateOne'\n  }), __metadata(\"design:type\", Function)], Model.prototype, \"_create\", void 0);\n\n  /**\n   * @public\n   * @classdesc Service to handling a way of tasks execution in Creatio plaform\n   * @extends {BaseHandlerChainService}\n   */\n  return Model;\n})();\nlet CrtZoneService = /*#__PURE__*/(() => {\n  class CrtZoneService extends BaseHandlerChainService {\n    constructor() {\n      super(...arguments);\n      /**\n       * @internal\n       */\n      this.requestType = 'crt.ZoneService';\n    }\n  }\n  __decorate([ImplementUsingHandlerChain(), __metadata(\"design:type\", Function)], CrtZoneService.prototype, \"runOutside\", void 0);\n\n  /**\n   * Generated bundle index. Do not edit.\n   */\n  return CrtZoneService;\n})();\nexport { BaseRequestHandler, BaseValidator, BootstrapNotifier, ConverterRegistry, CrtConverter, CrtDesignTimeViewElement, CrtInject, CrtInput, CrtInputRegistrationConfig, CrtInterfaceDesignerItem, CrtModule, CrtOutput, CrtRequest, CrtRequestHandler, CrtValidationInput, CrtValidator, CrtViewElement, CrtZoneService, DataRequest, DataSourceLoadType, DesignTimeViewElementRegistry, DesignerToolGroupType, FeatureService, HandlerChainService, HandlerChainServicesRegistry, HandlerSourceType, HandlersOrderComparer, HttpClientService, ImplementUsingHandlerChain, InterfaceDesignerItemRegistrationConfig, InterfaceDesignerItemRegistry, InternalRequestHandlerRegistry, InternalRequestHandlerRegistryType, LocalizableValue, MaskService, MethodInvokeRequest, Model, ModelInPageAction, PkgTopology, RemoteEntriesRegistry, RemoteEntryType, RequestHandlerRegistryService, RequestRegistryService, RightsService, SchemaViewMaskRequest, SchemaViewMaskRequestAction, SysSetting, SysSettingValue, SysSettingsService, SysValuesService, ValidatorMapValue, ValidatorRegistry, ViewElementDataGroupType, ViewElementGroupType, ViewElementRegistry, ViewElementReuseStrategy, _from, applyLocalizeMetadataFn, bootstrapCrtModule, bootstrapCrtModuleHandlerChainServices, checkCrtTypeNamePascalCase, checkIfTypeRegistered, checkOnlyOneRegistration, checkTypeNameFormat, checkTypeNamePascalCase, crtInjectPrefix, crtInputPrefix, crtOutputPrefix, crtValidationInputPrefix, designTimeViewElementRegistryKey, getConverterMetadata, getCrtInputsMetadata, getCrtOutputsMetadata, getCrtValidationInputsMetadata, getDesignTimeViewElementMetadata, getHandlerChainServiceMetadata, getInterfaceDesignerItemMetadata, getModuleMetadata, getRequestHandlerMetadata, getTypeDependencies, getValidatorMetadata, getViewElementMetadata, hasInterfaceDesignerItemMetadata, instantiate, interfaceDesignerItemRegistryKey, isComponentPropertyBindable, localize, objectDeepKeys, registerAngularViewElement, registerViewElement, setConverterMetadata, setDesignTimeViewElementMetadata, setInterfaceDesignerItemMetadata, setModuleMetadata, setRequestHandlerMetadata, setValidatorMetadata, setViewElementMetadata, toAggregationEval, toAggregationEvalType, toAggregationFunction, toAggregationType, toDatePart, toDatePartType, toNumericFunctionType, toOrderDirection, toPascalCase, toSortDirection, toStringFunctionType, validatorRegistryKey, viewElementRegistryKey, ɵBaseRegistry, ɵcheckTypeNameFormat, ɵinstantiate };\n//# sourceMappingURL=creatio-devkit-common.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}