{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, Context) {\n  var getDomain = Promise._getDomain;\n  var async = Promise._async;\n  var Warning = require(\"./errors\").Warning;\n  var util = require(\"./util\");\n  var canAttachTrace = util.canAttachTrace;\n  var unhandledRejectionHandled;\n  var possiblyUnhandledRejection;\n  var bluebirdFramePattern = /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\n  var nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\n  var parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\n  var stackFramePattern = null;\n  var formatStack = null;\n  var indentStackFrames = false;\n  var printWarning;\n  var debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 && (false || util.env(\"BLUEBIRD_DEBUG\") || util.env(\"NODE_ENV\") === \"development\"));\n  var warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 && (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n  var longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 && (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n  var wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 && (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n  Promise.prototype.suppressUnhandledRejections = function () {\n    var target = this._target();\n    target._bitField = target._bitField & ~1048576 | 524288;\n  };\n  Promise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 524288) !== 0) return;\n    this._setRejectionIsUnhandled();\n    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n  };\n  Promise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    fireRejectionEvent(\"rejectionHandled\", unhandledRejectionHandled, undefined, this);\n  };\n  Promise.prototype._setReturnedNonUndefined = function () {\n    this._bitField = this._bitField | 268435456;\n  };\n  Promise.prototype._returnedNonUndefined = function () {\n    return (this._bitField & 268435456) !== 0;\n  };\n  Promise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n      var reason = this._settledValue();\n      this._setUnhandledRejectionIsNotified();\n      fireRejectionEvent(\"unhandledRejection\", possiblyUnhandledRejection, reason, this);\n    }\n  };\n  Promise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 262144;\n  };\n  Promise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & ~262144;\n  };\n  Promise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 262144) > 0;\n  };\n  Promise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 1048576;\n  };\n  Promise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & ~1048576;\n    if (this._isUnhandledRejectionNotified()) {\n      this._unsetUnhandledRejectionIsNotified();\n      this._notifyUnhandledRejectionIsHandled();\n    }\n  };\n  Promise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 1048576) > 0;\n  };\n  Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {\n    return warn(message, shouldUseOwnTrace, promise || this);\n  };\n  Promise.onPossiblyUnhandledRejection = function (fn) {\n    var domain = getDomain();\n    possiblyUnhandledRejection = typeof fn === \"function\" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;\n  };\n  Promise.onUnhandledRejectionHandled = function (fn) {\n    var domain = getDomain();\n    unhandledRejectionHandled = typeof fn === \"function\" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;\n  };\n  var disableLongStackTraces = function () {};\n  Promise.longStackTraces = function () {\n    if (async.haveItemsQueued() && !config.longStackTraces) {\n      throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (!config.longStackTraces && longStackTracesIsSupported()) {\n      var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n      var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n      config.longStackTraces = true;\n      disableLongStackTraces = function () {\n        if (async.haveItemsQueued() && !config.longStackTraces) {\n          throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n        }\n        Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n        Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n        Context.deactivateLongStackTraces();\n        async.enableTrampoline();\n        config.longStackTraces = false;\n      };\n      Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n      Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n      Context.activateLongStackTraces();\n      async.disableTrampolineIfNecessary();\n    }\n  };\n  Promise.hasLongStackTraces = function () {\n    return config.longStackTraces && longStackTracesIsSupported();\n  };\n  var fireDomEvent = function () {\n    try {\n      if (typeof CustomEvent === \"function\") {\n        var event = new CustomEvent(\"CustomEvent\");\n        util.global.dispatchEvent(event);\n        return function (name, event) {\n          var domEvent = new CustomEvent(name.toLowerCase(), {\n            detail: event,\n            cancelable: true\n          });\n          return !util.global.dispatchEvent(domEvent);\n        };\n      } else if (typeof Event === \"function\") {\n        var event = new Event(\"CustomEvent\");\n        util.global.dispatchEvent(event);\n        return function (name, event) {\n          var domEvent = new Event(name.toLowerCase(), {\n            cancelable: true\n          });\n          domEvent.detail = event;\n          return !util.global.dispatchEvent(domEvent);\n        };\n      } else {\n        var event = document.createEvent(\"CustomEvent\");\n        event.initCustomEvent(\"testingtheevent\", false, true, {});\n        util.global.dispatchEvent(event);\n        return function (name, event) {\n          var domEvent = document.createEvent(\"CustomEvent\");\n          domEvent.initCustomEvent(name.toLowerCase(), false, true, event);\n          return !util.global.dispatchEvent(domEvent);\n        };\n      }\n    } catch (e) {}\n    return function () {\n      return false;\n    };\n  }();\n  var fireGlobalEvent = function () {\n    if (util.isNode) {\n      return function () {\n        return process.emit.apply(process, arguments);\n      };\n    } else {\n      if (!util.global) {\n        return function () {\n          return false;\n        };\n      }\n      return function (name) {\n        var methodName = \"on\" + name.toLowerCase();\n        var method = util.global[methodName];\n        if (!method) return false;\n        method.apply(util.global, [].slice.call(arguments, 1));\n        return true;\n      };\n    }\n  }();\n  function generatePromiseLifecycleEventObject(name, promise) {\n    return {\n      promise: promise\n    };\n  }\n  var eventToObjectGenerator = {\n    promiseCreated: generatePromiseLifecycleEventObject,\n    promiseFulfilled: generatePromiseLifecycleEventObject,\n    promiseRejected: generatePromiseLifecycleEventObject,\n    promiseResolved: generatePromiseLifecycleEventObject,\n    promiseCancelled: generatePromiseLifecycleEventObject,\n    promiseChained: function (name, promise, child) {\n      return {\n        promise: promise,\n        child: child\n      };\n    },\n    warning: function (name, warning) {\n      return {\n        warning: warning\n      };\n    },\n    unhandledRejection: function (name, reason, promise) {\n      return {\n        reason: reason,\n        promise: promise\n      };\n    },\n    rejectionHandled: generatePromiseLifecycleEventObject\n  };\n  var activeFireEvent = function (name) {\n    var globalEventFired = false;\n    try {\n      globalEventFired = fireGlobalEvent.apply(null, arguments);\n    } catch (e) {\n      async.throwLater(e);\n      globalEventFired = true;\n    }\n    var domEventFired = false;\n    try {\n      domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));\n    } catch (e) {\n      async.throwLater(e);\n      domEventFired = true;\n    }\n    return domEventFired || globalEventFired;\n  };\n  Promise.config = function (opts) {\n    opts = Object(opts);\n    if (\"longStackTraces\" in opts) {\n      if (opts.longStackTraces) {\n        Promise.longStackTraces();\n      } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n        disableLongStackTraces();\n      }\n    }\n    if (\"warnings\" in opts) {\n      var warningsOption = opts.warnings;\n      config.warnings = !!warningsOption;\n      wForgottenReturn = config.warnings;\n      if (util.isObject(warningsOption)) {\n        if (\"wForgottenReturn\" in warningsOption) {\n          wForgottenReturn = !!warningsOption.wForgottenReturn;\n        }\n      }\n    }\n    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n      if (async.haveItemsQueued()) {\n        throw new Error(\"cannot enable cancellation after promises are in use\");\n      }\n      Promise.prototype._clearCancellationData = cancellationClearCancellationData;\n      Promise.prototype._propagateFrom = cancellationPropagateFrom;\n      Promise.prototype._onCancel = cancellationOnCancel;\n      Promise.prototype._setOnCancel = cancellationSetOnCancel;\n      Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;\n      Promise.prototype._execute = cancellationExecute;\n      propagateFromFunction = cancellationPropagateFrom;\n      config.cancellation = true;\n    }\n    if (\"monitoring\" in opts) {\n      if (opts.monitoring && !config.monitoring) {\n        config.monitoring = true;\n        Promise.prototype._fireEvent = activeFireEvent;\n      } else if (!opts.monitoring && config.monitoring) {\n        config.monitoring = false;\n        Promise.prototype._fireEvent = defaultFireEvent;\n      }\n    }\n    return Promise;\n  };\n  function defaultFireEvent() {\n    return false;\n  }\n  Promise.prototype._fireEvent = defaultFireEvent;\n  Promise.prototype._execute = function (executor, resolve, reject) {\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      return e;\n    }\n  };\n  Promise.prototype._onCancel = function () {};\n  Promise.prototype._setOnCancel = function (handler) {\n    ;\n  };\n  Promise.prototype._attachCancellationCallback = function (onCancel) {\n    ;\n  };\n  Promise.prototype._captureStackTrace = function () {};\n  Promise.prototype._attachExtraTrace = function () {};\n  Promise.prototype._clearCancellationData = function () {};\n  Promise.prototype._propagateFrom = function (parent, flags) {\n    ;\n    ;\n  };\n  function cancellationExecute(executor, resolve, reject) {\n    var promise = this;\n    try {\n      executor(resolve, reject, function (onCancel) {\n        if (typeof onCancel !== \"function\") {\n          throw new TypeError(\"onCancel must be a function, got: \" + util.toString(onCancel));\n        }\n        promise._attachCancellationCallback(onCancel);\n      });\n    } catch (e) {\n      return e;\n    }\n  }\n  function cancellationAttachCancellationCallback(onCancel) {\n    if (!this._isCancellable()) return this;\n    var previousOnCancel = this._onCancel();\n    if (previousOnCancel !== undefined) {\n      if (util.isArray(previousOnCancel)) {\n        previousOnCancel.push(onCancel);\n      } else {\n        this._setOnCancel([previousOnCancel, onCancel]);\n      }\n    } else {\n      this._setOnCancel(onCancel);\n    }\n  }\n  function cancellationOnCancel() {\n    return this._onCancelField;\n  }\n  function cancellationSetOnCancel(onCancel) {\n    this._onCancelField = onCancel;\n  }\n  function cancellationClearCancellationData() {\n    this._cancellationParent = undefined;\n    this._onCancelField = undefined;\n  }\n  function cancellationPropagateFrom(parent, flags) {\n    if ((flags & 1) !== 0) {\n      this._cancellationParent = parent;\n      var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n      if (branchesRemainingToCancel === undefined) {\n        branchesRemainingToCancel = 0;\n      }\n      parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n    }\n    if ((flags & 2) !== 0 && parent._isBound()) {\n      this._setBoundTo(parent._boundTo);\n    }\n  }\n  function bindingPropagateFrom(parent, flags) {\n    if ((flags & 2) !== 0 && parent._isBound()) {\n      this._setBoundTo(parent._boundTo);\n    }\n  }\n  var propagateFromFunction = bindingPropagateFrom;\n  function boundValueFunction() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n      if (ret instanceof Promise) {\n        if (ret.isFulfilled()) {\n          return ret.value();\n        } else {\n          return undefined;\n        }\n      }\n    }\n    return ret;\n  }\n  function longStackTracesCaptureStackTrace() {\n    this._trace = new CapturedTrace(this._peekContext());\n  }\n  function longStackTracesAttachExtraTrace(error, ignoreSelf) {\n    if (canAttachTrace(error)) {\n      var trace = this._trace;\n      if (trace !== undefined) {\n        if (ignoreSelf) trace = trace._parent;\n      }\n      if (trace !== undefined) {\n        trace.attachExtraTrace(error);\n      } else if (!error.__stackCleaned__) {\n        var parsed = parseStackAndMessage(error);\n        util.notEnumerableProp(error, \"stack\", parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n        util.notEnumerableProp(error, \"__stackCleaned__\", true);\n      }\n    }\n  }\n  function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {\n    if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {\n      if (parent !== undefined && parent._returnedNonUndefined()) return;\n      if ((promise._bitField & 65535) === 0) return;\n      if (name) name = name + \" \";\n      var handlerLine = \"\";\n      var creatorLine = \"\";\n      if (promiseCreated._trace) {\n        var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n        var stack = cleanStack(traceLines);\n        for (var i = stack.length - 1; i >= 0; --i) {\n          var line = stack[i];\n          if (!nodeFramePattern.test(line)) {\n            var lineMatches = line.match(parseLinePattern);\n            if (lineMatches) {\n              handlerLine = \"at \" + lineMatches[1] + \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n            }\n            break;\n          }\n        }\n        if (stack.length > 0) {\n          var firstUserLine = stack[0];\n          for (var i = 0; i < traceLines.length; ++i) {\n            if (traceLines[i] === firstUserLine) {\n              if (i > 0) {\n                creatorLine = \"\\n\" + traceLines[i - 1];\n              }\n              break;\n            }\n          }\n        }\n      }\n      var msg = \"a promise was created in a \" + name + \"handler \" + handlerLine + \"but was not returned from it, \" + \"see http://goo.gl/rRqMUw\" + creatorLine;\n      promise._warn(msg, true, promiseCreated);\n    }\n  }\n  function deprecated(name, replacement) {\n    var message = name + \" is deprecated and will be removed in a future version.\";\n    if (replacement) message += \" Use \" + replacement + \" instead.\";\n    return warn(message);\n  }\n  function warn(message, shouldUseOwnTrace, promise) {\n    if (!config.warnings) return;\n    var warning = new Warning(message);\n    var ctx;\n    if (shouldUseOwnTrace) {\n      promise._attachExtraTrace(warning);\n    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n      ctx.attachExtraTrace(warning);\n    } else {\n      var parsed = parseStackAndMessage(warning);\n      warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n    if (!activeFireEvent(\"warning\", warning)) {\n      formatAndLogError(warning, \"\", true);\n    }\n  }\n  function reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n      stacks[i].push(\"From previous event:\");\n      stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n      stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n  }\n  function removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n      if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {\n        stacks.splice(i, 1);\n        i--;\n      }\n    }\n  }\n  function removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n      var prev = stacks[i];\n      var currentLastIndex = current.length - 1;\n      var currentLastLine = current[currentLastIndex];\n      var commonRootMeetPoint = -1;\n      for (var j = prev.length - 1; j >= 0; --j) {\n        if (prev[j] === currentLastLine) {\n          commonRootMeetPoint = j;\n          break;\n        }\n      }\n      for (var j = commonRootMeetPoint; j >= 0; --j) {\n        var line = prev[j];\n        if (current[currentLastIndex] === line) {\n          current.pop();\n          currentLastIndex--;\n        } else {\n          break;\n        }\n      }\n      current = prev;\n    }\n  }\n  function cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n      var line = stack[i];\n      var isTraceLine = \"    (No stack trace)\" === line || stackFramePattern.test(line);\n      var isInternalFrame = isTraceLine && shouldIgnore(line);\n      if (isTraceLine && !isInternalFrame) {\n        if (indentStackFrames && line.charAt(0) !== \" \") {\n          line = \"    \" + line;\n        }\n        ret.push(line);\n      }\n    }\n    return ret;\n  }\n  function stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n      var line = stack[i];\n      if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n        break;\n      }\n    }\n    if (i > 0 && error.name != \"SyntaxError\") {\n      stack = stack.slice(i);\n    }\n    return stack;\n  }\n  function parseStackAndMessage(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0 ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n      message: message,\n      stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n    };\n  }\n  function formatAndLogError(error, title, isSoft) {\n    if (typeof console !== \"undefined\") {\n      var message;\n      if (util.isObject(error)) {\n        var stack = error.stack;\n        message = title + formatStack(stack, error);\n      } else {\n        message = title + String(error);\n      }\n      if (typeof printWarning === \"function\") {\n        printWarning(message, isSoft);\n      } else if (typeof console.log === \"function\" || typeof console.log === \"object\") {\n        console.log(message);\n      }\n    }\n  }\n  function fireRejectionEvent(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n      if (typeof localHandler === \"function\") {\n        localEventFired = true;\n        if (name === \"rejectionHandled\") {\n          localHandler(promise);\n        } else {\n          localHandler(reason, promise);\n        }\n      }\n    } catch (e) {\n      async.throwLater(e);\n    }\n    if (name === \"unhandledRejection\") {\n      if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n        formatAndLogError(reason, \"Unhandled rejection \");\n      }\n    } else {\n      activeFireEvent(name, promise);\n    }\n  }\n  function formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n      str = \"[function \" + (obj.name || \"anonymous\") + \"]\";\n    } else {\n      str = obj && typeof obj.toString === \"function\" ? obj.toString() : util.toString(obj);\n      var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n      if (ruselessToString.test(str)) {\n        try {\n          var newStr = JSON.stringify(obj);\n          str = newStr;\n        } catch (e) {}\n      }\n      if (str.length === 0) {\n        str = \"(empty array)\";\n      }\n    }\n    return \"(<\" + snip(str) + \">, no stack trace)\";\n  }\n  function snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n      return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n  }\n  function longStackTracesIsSupported() {\n    return typeof captureStackTrace === \"function\";\n  }\n  var shouldIgnore = function () {\n    return false;\n  };\n  var parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\n  function parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n      return {\n        fileName: matches[1],\n        line: parseInt(matches[2], 10)\n      };\n    }\n  }\n  function setBounds(firstLineError, lastLineError) {\n    if (!longStackTracesIsSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n      var result = parseLineInfo(firstStackLines[i]);\n      if (result) {\n        firstFileName = result.fileName;\n        firstIndex = result.line;\n        break;\n      }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n      var result = parseLineInfo(lastStackLines[i]);\n      if (result) {\n        lastFileName = result.fileName;\n        lastIndex = result.line;\n        break;\n      }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {\n      return;\n    }\n    shouldIgnore = function (line) {\n      if (bluebirdFramePattern.test(line)) return true;\n      var info = parseLineInfo(line);\n      if (info) {\n        if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {\n          return true;\n        }\n      }\n      return false;\n    };\n  }\n  function CapturedTrace(parent) {\n    this._parent = parent;\n    this._promisesCreated = 0;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n  }\n  util.inherits(CapturedTrace, Error);\n  Context.CapturedTrace = CapturedTrace;\n  CapturedTrace.prototype.uncycle = function () {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n    for (var i = 0, node = this; node !== undefined; ++i) {\n      nodes.push(node);\n      node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n      var stack = nodes[i].stack;\n      if (stackToIndex[stack] === undefined) {\n        stackToIndex[stack] = i;\n      }\n    }\n    for (var i = 0; i < length; ++i) {\n      var currentStack = nodes[i].stack;\n      var index = stackToIndex[currentStack];\n      if (index !== undefined && index !== i) {\n        if (index > 0) {\n          nodes[index - 1]._parent = undefined;\n          nodes[index - 1]._length = 1;\n        }\n        nodes[i]._parent = undefined;\n        nodes[i]._length = 1;\n        var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n        if (index < length - 1) {\n          cycleEdgeNode._parent = nodes[index + 1];\n          cycleEdgeNode._parent.uncycle();\n          cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;\n        } else {\n          cycleEdgeNode._parent = undefined;\n          cycleEdgeNode._length = 1;\n        }\n        var currentChildLength = cycleEdgeNode._length + 1;\n        for (var j = i - 2; j >= 0; --j) {\n          nodes[j]._length = currentChildLength;\n          currentChildLength++;\n        }\n        return;\n      }\n    }\n  };\n  CapturedTrace.prototype.attachExtraTrace = function (error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n    var trace = this;\n    while (trace !== undefined) {\n      stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n      trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n  };\n  var captureStackTrace = function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function (stack, error) {\n      if (typeof stack === \"string\") return stack;\n      if (error.name !== undefined && error.message !== undefined) {\n        return error.toString();\n      }\n      return formatNonError(error);\n    };\n    if (typeof Error.stackTraceLimit === \"number\" && typeof Error.captureStackTrace === \"function\") {\n      Error.stackTraceLimit += 6;\n      stackFramePattern = v8stackFramePattern;\n      formatStack = v8stackFormatter;\n      var captureStackTrace = Error.captureStackTrace;\n      shouldIgnore = function (line) {\n        return bluebirdFramePattern.test(line);\n      };\n      return function (receiver, ignoreUntil) {\n        Error.stackTraceLimit += 6;\n        captureStackTrace(receiver, ignoreUntil);\n        Error.stackTraceLimit -= 6;\n      };\n    }\n    var err = new Error();\n    if (typeof err.stack === \"string\" && err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n      stackFramePattern = /@/;\n      formatStack = v8stackFormatter;\n      indentStackFrames = true;\n      return function captureStackTrace(o) {\n        o.stack = new Error().stack;\n      };\n    }\n    var hasStackAfterThrow;\n    try {\n      throw new Error();\n    } catch (e) {\n      hasStackAfterThrow = \"stack\" in e;\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === \"number\") {\n      stackFramePattern = v8stackFramePattern;\n      formatStack = v8stackFormatter;\n      return function captureStackTrace(o) {\n        Error.stackTraceLimit += 6;\n        try {\n          throw new Error();\n        } catch (e) {\n          o.stack = e.stack;\n        }\n        Error.stackTraceLimit -= 6;\n      };\n    }\n    formatStack = function (stack, error) {\n      if (typeof stack === \"string\") return stack;\n      if ((typeof error === \"object\" || typeof error === \"function\") && error.name !== undefined && error.message !== undefined) {\n        return error.toString();\n      }\n      return formatNonError(error);\n    };\n    return null;\n  }([]);\n  if (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    printWarning = function (message) {\n      console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n      printWarning = function (message, isSoft) {\n        var color = isSoft ? \"\\u001b[33m\" : \"\\u001b[31m\";\n        console.warn(color + message + \"\\u001b[0m\\n\");\n      };\n    } else if (!util.isNode && typeof new Error().stack === \"string\") {\n      printWarning = function (message, isSoft) {\n        console.warn(\"%c\" + message, isSoft ? \"color: darkorange\" : \"color: red\");\n      };\n    }\n  }\n  var config = {\n    warnings: warnings,\n    longStackTraces: false,\n    cancellation: false,\n    monitoring: false\n  };\n  if (longStackTraces) Promise.longStackTraces();\n  return {\n    longStackTraces: function () {\n      return config.longStackTraces;\n    },\n    warnings: function () {\n      return config.warnings;\n    },\n    cancellation: function () {\n      return config.cancellation;\n    },\n    monitoring: function () {\n      return config.monitoring;\n    },\n    propagateFromFunction: function () {\n      return propagateFromFunction;\n    },\n    boundValueFunction: function () {\n      return boundValueFunction;\n    },\n    checkForgottenReturns: checkForgottenReturns,\n    setBounds: setBounds,\n    warn: warn,\n    deprecated: deprecated,\n    CapturedTrace: CapturedTrace,\n    fireDomEvent: fireDomEvent,\n    fireGlobalEvent: fireGlobalEvent\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}