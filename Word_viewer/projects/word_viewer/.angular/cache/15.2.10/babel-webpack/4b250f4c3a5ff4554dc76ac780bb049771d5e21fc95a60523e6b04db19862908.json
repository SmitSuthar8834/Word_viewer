{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, PromiseArray, apiRejection, debug) {\n  var util = require(\"./util\");\n  var tryCatch = util.tryCatch;\n  var errorObj = util.errorObj;\n  var async = Promise._async;\n  Promise.prototype[\"break\"] = Promise.prototype.cancel = function () {\n    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n    var promise = this;\n    var child = promise;\n    while (promise._isCancellable()) {\n      if (!promise._cancelBy(child)) {\n        if (child._isFollowing()) {\n          child._followee().cancel();\n        } else {\n          child._cancelBranched();\n        }\n        break;\n      }\n      var parent = promise._cancellationParent;\n      if (parent == null || !parent._isCancellable()) {\n        if (promise._isFollowing()) {\n          promise._followee().cancel();\n        } else {\n          promise._cancelBranched();\n        }\n        break;\n      } else {\n        if (promise._isFollowing()) promise._followee().cancel();\n        promise._setWillBeCancelled();\n        child = promise;\n        promise = parent;\n      }\n    }\n  };\n  Promise.prototype._branchHasCancelled = function () {\n    this._branchesRemainingToCancel--;\n  };\n  Promise.prototype._enoughBranchesHaveCancelled = function () {\n    return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;\n  };\n  Promise.prototype._cancelBy = function (canceller) {\n    if (canceller === this) {\n      this._branchesRemainingToCancel = 0;\n      this._invokeOnCancel();\n      return true;\n    } else {\n      this._branchHasCancelled();\n      if (this._enoughBranchesHaveCancelled()) {\n        this._invokeOnCancel();\n        return true;\n      }\n    }\n    return false;\n  };\n  Promise.prototype._cancelBranched = function () {\n    if (this._enoughBranchesHaveCancelled()) {\n      this._cancel();\n    }\n  };\n  Promise.prototype._cancel = function () {\n    if (!this._isCancellable()) return;\n    this._setCancelled();\n    async.invoke(this._cancelPromises, this, undefined);\n  };\n  Promise.prototype._cancelPromises = function () {\n    if (this._length() > 0) this._settlePromises();\n  };\n  Promise.prototype._unsetOnCancel = function () {\n    this._onCancelField = undefined;\n  };\n  Promise.prototype._isCancellable = function () {\n    return this.isPending() && !this._isCancelled();\n  };\n  Promise.prototype.isCancellable = function () {\n    return this.isPending() && !this.isCancelled();\n  };\n  Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {\n    if (util.isArray(onCancelCallback)) {\n      for (var i = 0; i < onCancelCallback.length; ++i) {\n        this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n      }\n    } else if (onCancelCallback !== undefined) {\n      if (typeof onCancelCallback === \"function\") {\n        if (!internalOnly) {\n          var e = tryCatch(onCancelCallback).call(this._boundValue());\n          if (e === errorObj) {\n            this._attachExtraTrace(e.e);\n            async.throwLater(e.e);\n          }\n        }\n      } else {\n        onCancelCallback._resultCancelled(this);\n      }\n    }\n  };\n  Promise.prototype._invokeOnCancel = function () {\n    var onCancelCallback = this._onCancel();\n    this._unsetOnCancel();\n    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n  };\n  Promise.prototype._invokeInternalOnCancel = function () {\n    if (this._isCancellable()) {\n      this._doInvokeOnCancel(this._onCancel(), true);\n      this._unsetOnCancel();\n    }\n  };\n  Promise.prototype._resultCancelled = function () {\n    this.cancel();\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}